#ifndef _CONTROLLER_H_
#define _CONTROLLER_H_

#include <memory>
#include <string>

#include "common/proto/control_cmd.pb.h"
#include "common/proto/control_conf.pb.h"
#include "common/proto/planning.pb.h"
#include "common/proto/pnc_point.pb.h"
#include "control/control/dependency_injector.h"
#include "control/control/status.h"

/**
 * @class Controller
 *
 * @brief base class for all controllers.
 */
class Controller {
 public:
  /**
   * @brief constructor
   */
  Controller() = default;

  /**
   * @brief destructor
   */
  virtual ~Controller() = default;

  /**
   * @brief initialize Controller
   * @param control_conf control configurations
   * @return Status initialization status
   */
  virtual Status Init(std::shared_ptr<DependencyInjector> injector,
                      const controller::ControlConf *control_conf) = 0;

  /**
   * @brief compute control command based on current vehicle status
   *        and target trajectory
   * @param localization vehicle location
   * @param chassis vehicle status e.g., speed, acceleration
   * @param trajectory trajectory generated by planning
   * @param cmd control command
   * @return Status computation status
   */
  virtual Status ComputeControlCommand(
      const controller::LocalizationEstimate *localization,
      const canbus::Chassis *chassis, const planning::ADCTrajectory *trajectory,
      controller::ControlCommand *cmd) = 0;

  /**
   * @brief reset Controller
   * @return Status reset status
   */
  virtual Status Reset() = 0;

  /**
   * @brief controller name
   * @return string controller name in string
   */
  virtual std::string Name() const = 0;

  /**
   * @brief stop controller
   */
  virtual void Stop() = 0;

  virtual bool get_reached() { return reached_; }

  virtual points::TrajectoryPoint get_target_point() { return target_point_; }

 protected:
  bool reached_ = false;
  points::TrajectoryPoint target_point_;
};

#endif
