#ifndef _SIMPLE_PID_LAT_LON_CONTROLLER_H_
#define _SIMPLE_PID_LAT_LON_CONTROLLER_H_

#include <memory>
#include <string>
#include <vector>

#include "common/config/flags.h"
#include "common/math/math_utils.h"
#include "common/math/vec2d.h"
#include "common/proto/vehicle_config.pb.h"
#include "control/control/pid_controller.h"
#include "control/control/status.h"
#include "control/control/trajectory_analyzer.h"
#include "control/filters/digital_filter.h"
#include "control/filters/digital_filter_coefficients.h"
#include "control/filters/mean_filter.h"
#include "controller.h"

/**
 * @class SimplePIDLatLonController
 * @brief Use simple pid controller to computer speed and steer wheel angle
 */
class SimplePIDLatLonController : public Controller {
 public:
  SimplePIDLatLonController();
  virtual ~SimplePIDLatLonController();

  /**
   * @brief initialize Longitudinal Controller
   * @param control_conf control configurations
   * @return Status initialization status
   */
  Status Init(std::shared_ptr<DependencyInjector> injector,
              const controller::ControlConf* control_conf) override;

  /**
   * @brief compute brake / throttle values based on current vehicle status
   *        and target trajectory
   * @param localization vehicle location
   * @param chassis vehicle status e.g., speed, acceleration
   * @param trajectory trajectory generated by planning
   * @param cmd control command
   * @return Status computation status
   */
  Status ComputeControlCommand(
      const controller::LocalizationEstimate* localization,
      const canbus::Chassis* chassis, const planning::ADCTrajectory* trajectory,
      controller::ControlCommand* cmd) override;

  /**
   * @brief reset longitudinal controller
   * @return Status reset status
   */
  Status Reset() override;

  /**
   * @brief longitudinal controller name
   * @return string controller name in string
   */
  std::string Name() const override { return "Simple PID Lat Lon Controller"; }

  void Stop() override;

 private:
  void CloseFile();

  void InitializeFilters(const controller::ControlConf* control_conf);

  points::TrajectoryPoint GetTargetPoint(const double x, const double y,
                                         const bool forward,
                                         const double theta);
  double GetDistance(const points::PathPoint& p1, const points::PathPoint& p2);

 private:
  FILE* sim_pid_log_file_ = nullptr;

  DigitalFilter digital_filter_;
  MeanFilter yaw_error_filter_;

  const controller::ControlConf* control_conf_ = nullptr;
  PIDController station_pid_controller_;
  PIDController yaw_pid_controller_;
  double dt_ = 0.01;

  const vehicle::VehicleParam vehicle_param_ = vehicle::VehicleParam();

  double station_error_ = 0.0;
  double yaw_error_ = 0.0;
  size_t last_index_ = 0;
  double look_ahead_distance_ = 0.0;
  double speed_controller_input_limit_ = 0.0;

  const controller::LocalizationEstimate* localization_ = nullptr;
  const canbus::Chassis* chassis_ = nullptr;
  planning::ADCTrajectory trajectory_;

  std::shared_ptr<DependencyInjector> injector_;
  TrajectoryAnalyzer trajectory_analyzer_;
  double s_matched_, s_dot_matched_, d_matched_, d_dot_matched_;
};

#endif
