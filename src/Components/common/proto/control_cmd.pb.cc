// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: control_cmd.proto

#include "control_cmd.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_control_5fcmd_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_LatencyStats_control_5fcmd_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_control_5fcmd_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_MracAdaptiveGain_control_5fcmd_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_control_5fcmd_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_SimpleMPCDebug_control_5fcmd_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_control_5fcmd_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_InputDebug_control_5fcmd_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_control_5fcmd_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_MracDebug_control_5fcmd_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_control_5fcmd_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_SimpleLongitudinalDebug_control_5fcmd_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_control_5fcmd_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_SimplePIDLatLonDebug_control_5fcmd_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_control_5fcmd_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_SimpleLateralDebug_control_5fcmd_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_control_5fcmd_2eproto ::google::protobuf::internal::SCCInfo<5> scc_info_Debug_control_5fcmd_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_header_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_Header_header_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pnc_5fpoint_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_TrajectoryPoint_pnc_5fpoint_2eproto;
namespace controller {
class LatencyStatsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<LatencyStats> _instance;
} _LatencyStats_default_instance_;
class ControlCommandDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ControlCommand> _instance;
} _ControlCommand_default_instance_;
class SimpleLongitudinalDebugDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SimpleLongitudinalDebug> _instance;
} _SimpleLongitudinalDebug_default_instance_;
class SimpleLateralDebugDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SimpleLateralDebug> _instance;
} _SimpleLateralDebug_default_instance_;
class SimpleMPCDebugDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SimpleMPCDebug> _instance;
} _SimpleMPCDebug_default_instance_;
class SimplePIDLatLonDebugDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SimplePIDLatLonDebug> _instance;
} _SimplePIDLatLonDebug_default_instance_;
class MracDebugDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<MracDebug> _instance;
} _MracDebug_default_instance_;
class MracAdaptiveGainDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<MracAdaptiveGain> _instance;
} _MracAdaptiveGain_default_instance_;
class InputDebugDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<InputDebug> _instance;
} _InputDebug_default_instance_;
class DebugDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Debug> _instance;
} _Debug_default_instance_;
}  // namespace controller
static void InitDefaultsLatencyStats_control_5fcmd_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::controller::_LatencyStats_default_instance_;
    new (ptr) ::controller::LatencyStats();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::controller::LatencyStats::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_LatencyStats_control_5fcmd_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsLatencyStats_control_5fcmd_2eproto}, {}};

static void InitDefaultsControlCommand_control_5fcmd_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::controller::_ControlCommand_default_instance_;
    new (ptr) ::controller::ControlCommand();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::controller::ControlCommand::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<3> scc_info_ControlCommand_control_5fcmd_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsControlCommand_control_5fcmd_2eproto}, {
      &scc_info_Header_header_2eproto.base,
      &scc_info_Debug_control_5fcmd_2eproto.base,
      &scc_info_LatencyStats_control_5fcmd_2eproto.base,}};

static void InitDefaultsSimpleLongitudinalDebug_control_5fcmd_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::controller::_SimpleLongitudinalDebug_default_instance_;
    new (ptr) ::controller::SimpleLongitudinalDebug();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::controller::SimpleLongitudinalDebug::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_SimpleLongitudinalDebug_control_5fcmd_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsSimpleLongitudinalDebug_control_5fcmd_2eproto}, {
      &scc_info_TrajectoryPoint_pnc_5fpoint_2eproto.base,}};

static void InitDefaultsSimpleLateralDebug_control_5fcmd_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::controller::_SimpleLateralDebug_default_instance_;
    new (ptr) ::controller::SimpleLateralDebug();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::controller::SimpleLateralDebug::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_SimpleLateralDebug_control_5fcmd_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsSimpleLateralDebug_control_5fcmd_2eproto}, {
      &scc_info_TrajectoryPoint_pnc_5fpoint_2eproto.base,
      &scc_info_MracDebug_control_5fcmd_2eproto.base,}};

static void InitDefaultsSimpleMPCDebug_control_5fcmd_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::controller::_SimpleMPCDebug_default_instance_;
    new (ptr) ::controller::SimpleMPCDebug();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::controller::SimpleMPCDebug::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SimpleMPCDebug_control_5fcmd_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSimpleMPCDebug_control_5fcmd_2eproto}, {}};

static void InitDefaultsSimplePIDLatLonDebug_control_5fcmd_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::controller::_SimplePIDLatLonDebug_default_instance_;
    new (ptr) ::controller::SimplePIDLatLonDebug();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::controller::SimplePIDLatLonDebug::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_SimplePIDLatLonDebug_control_5fcmd_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsSimplePIDLatLonDebug_control_5fcmd_2eproto}, {
      &scc_info_TrajectoryPoint_pnc_5fpoint_2eproto.base,}};

static void InitDefaultsMracDebug_control_5fcmd_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::controller::_MracDebug_default_instance_;
    new (ptr) ::controller::MracDebug();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::controller::MracDebug::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_MracDebug_control_5fcmd_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsMracDebug_control_5fcmd_2eproto}, {
      &scc_info_MracAdaptiveGain_control_5fcmd_2eproto.base,}};

static void InitDefaultsMracAdaptiveGain_control_5fcmd_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::controller::_MracAdaptiveGain_default_instance_;
    new (ptr) ::controller::MracAdaptiveGain();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::controller::MracAdaptiveGain::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_MracAdaptiveGain_control_5fcmd_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsMracAdaptiveGain_control_5fcmd_2eproto}, {}};

static void InitDefaultsInputDebug_control_5fcmd_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::controller::_InputDebug_default_instance_;
    new (ptr) ::controller::InputDebug();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::controller::InputDebug::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_InputDebug_control_5fcmd_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsInputDebug_control_5fcmd_2eproto}, {
      &scc_info_Header_header_2eproto.base,}};

static void InitDefaultsDebug_control_5fcmd_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::controller::_Debug_default_instance_;
    new (ptr) ::controller::Debug();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::controller::Debug::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<5> scc_info_Debug_control_5fcmd_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 5, InitDefaultsDebug_control_5fcmd_2eproto}, {
      &scc_info_SimpleLongitudinalDebug_control_5fcmd_2eproto.base,
      &scc_info_SimpleLateralDebug_control_5fcmd_2eproto.base,
      &scc_info_InputDebug_control_5fcmd_2eproto.base,
      &scc_info_SimpleMPCDebug_control_5fcmd_2eproto.base,
      &scc_info_SimplePIDLatLonDebug_control_5fcmd_2eproto.base,}};

void InitDefaults_control_5fcmd_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_LatencyStats_control_5fcmd_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ControlCommand_control_5fcmd_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SimpleLongitudinalDebug_control_5fcmd_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SimpleLateralDebug_control_5fcmd_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SimpleMPCDebug_control_5fcmd_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SimplePIDLatLonDebug_control_5fcmd_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_MracDebug_control_5fcmd_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_MracAdaptiveGain_control_5fcmd_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_InputDebug_control_5fcmd_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Debug_control_5fcmd_2eproto.base);
}

::google::protobuf::Metadata file_level_metadata_control_5fcmd_2eproto[10];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors_control_5fcmd_2eproto[1];
constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_control_5fcmd_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_control_5fcmd_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::controller::LatencyStats, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::controller::LatencyStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::controller::LatencyStats, total_time_ms_),
  PROTOBUF_FIELD_OFFSET(::controller::LatencyStats, controller_time_ms_),
  PROTOBUF_FIELD_OFFSET(::controller::LatencyStats, total_time_exceeded_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, header_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, throttle_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, brake_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, steering_rate_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, steering_target_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, parking_brake_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, speed_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, acceleration_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, reset_model_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, engine_on_off_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, trajectory_fraction_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, driving_mode_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, gear_location_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, debug_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, latency_stats_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, is_in_safe_mode_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, left_turn_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, right_turn_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, high_beam_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, low_beam_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, horn_),
  PROTOBUF_FIELD_OFFSET(::controller::ControlCommand, turnsignal_),
  0,
  3,
  4,
  5,
  6,
  14,
  7,
  8,
  15,
  16,
  19,
  18,
  20,
  1,
  2,
  17,
  9,
  10,
  11,
  12,
  13,
  21,
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, station_reference_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, station_error_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, station_error_limited_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, preview_station_error_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, speed_reference_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, speed_error_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, speed_controller_input_limited_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, preview_speed_reference_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, preview_speed_error_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, preview_acceleration_reference_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, acceleration_cmd_closeloop_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, acceleration_cmd_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, acceleration_lookup_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, speed_lookup_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, calibration_value_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, throttle_cmd_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, brake_cmd_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, is_full_stop_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, slope_offset_compensation_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, current_station_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, path_remain_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, pid_saturation_status_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, leadlag_saturation_status_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, speed_offset_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, current_speed_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, acceleration_reference_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, current_acceleration_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, acceleration_error_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, jerk_reference_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, current_jerk_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, jerk_error_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, current_matched_point_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, current_reference_point_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLongitudinalDebug, preview_reference_point_),
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  22,
  20,
  21,
  24,
  23,
  33,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, lateral_error_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, ref_heading_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, heading_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, heading_error_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, heading_error_rate_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, lateral_error_rate_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, curvature_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, steer_angle_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, steer_angle_feedforward_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, steer_angle_lateral_contribution_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, steer_angle_lateral_rate_contribution_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, steer_angle_heading_contribution_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, steer_angle_heading_rate_contribution_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, steer_angle_feedback_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, steering_position_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, ref_speed_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, steer_angle_limited_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, lateral_acceleration_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, lateral_jerk_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, ref_heading_rate_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, heading_rate_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, ref_heading_acceleration_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, heading_acceleration_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, heading_error_acceleration_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, ref_heading_jerk_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, heading_jerk_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, heading_error_jerk_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, lateral_error_feedback_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, heading_error_feedback_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, current_target_point_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, steer_angle_feedback_augment_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, steer_mrac_debug_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleLateralDebug, steer_mrac_enable_status_),
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  0,
  31,
  1,
  32,
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, lateral_error_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, ref_heading_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, heading_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, heading_error_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, heading_error_rate_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, lateral_error_rate_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, curvature_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, steer_angle_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, steer_angle_feedforward_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, steer_angle_lateral_contribution_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, steer_angle_lateral_rate_contribution_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, steer_angle_heading_contribution_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, steer_angle_heading_rate_contribution_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, steer_angle_feedback_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, steering_position_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, ref_speed_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, steer_angle_limited_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, station_reference_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, station_error_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, speed_reference_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, speed_error_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, acceleration_reference_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, is_full_stop_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, station_feedback_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, speed_feedback_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, acceleration_cmd_closeloop_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, acceleration_cmd_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, acceleration_lookup_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, speed_lookup_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, calibration_value_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, steer_unconstrained_control_diff_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, steer_angle_feedforward_compensation_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, matrix_q_updated_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, matrix_r_updated_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, lateral_acceleration_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, lateral_jerk_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, ref_heading_rate_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, heading_rate_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, ref_heading_acceleration_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, heading_acceleration_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, heading_error_acceleration_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, ref_heading_jerk_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, heading_jerk_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, heading_error_jerk_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, acceleration_feedback_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, acceleration_error_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, jerk_reference_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, jerk_feedback_),
  PROTOBUF_FIELD_OFFSET(::controller::SimpleMPCDebug, jerk_error_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  46,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  ~0u,
  ~0u,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  PROTOBUF_FIELD_OFFSET(::controller::SimplePIDLatLonDebug, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::controller::SimplePIDLatLonDebug, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::controller::SimplePIDLatLonDebug, look_ahead_station_),
  PROTOBUF_FIELD_OFFSET(::controller::SimplePIDLatLonDebug, station_error_),
  PROTOBUF_FIELD_OFFSET(::controller::SimplePIDLatLonDebug, current_speed_),
  PROTOBUF_FIELD_OFFSET(::controller::SimplePIDLatLonDebug, current_heading_),
  PROTOBUF_FIELD_OFFSET(::controller::SimplePIDLatLonDebug, heading_error_),
  PROTOBUF_FIELD_OFFSET(::controller::SimplePIDLatLonDebug, current_steer_wheel_angle_),
  PROTOBUF_FIELD_OFFSET(::controller::SimplePIDLatLonDebug, speed_cmd_),
  PROTOBUF_FIELD_OFFSET(::controller::SimplePIDLatLonDebug, steer_angle_cmd_),
  PROTOBUF_FIELD_OFFSET(::controller::SimplePIDLatLonDebug, target_point_),
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  0,
  PROTOBUF_FIELD_OFFSET(::controller::MracDebug, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::controller::MracDebug, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::controller::MracDebug, mrac_model_order_),
  PROTOBUF_FIELD_OFFSET(::controller::MracDebug, mrac_reference_state_),
  PROTOBUF_FIELD_OFFSET(::controller::MracDebug, mrac_state_error_),
  PROTOBUF_FIELD_OFFSET(::controller::MracDebug, mrac_adaptive_gain_),
  PROTOBUF_FIELD_OFFSET(::controller::MracDebug, mrac_reference_saturation_status_),
  PROTOBUF_FIELD_OFFSET(::controller::MracDebug, mrac_control_saturation_status_),
  1,
  ~0u,
  ~0u,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::controller::MracAdaptiveGain, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::controller::MracAdaptiveGain, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::controller::MracAdaptiveGain, state_adaptive_gain_),
  PROTOBUF_FIELD_OFFSET(::controller::MracAdaptiveGain, input_adaptive_gain_),
  PROTOBUF_FIELD_OFFSET(::controller::MracAdaptiveGain, nonlinear_adaptive_gain_),
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::controller::InputDebug, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::controller::InputDebug, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::controller::InputDebug, localization_header_),
  PROTOBUF_FIELD_OFFSET(::controller::InputDebug, canbus_header_),
  PROTOBUF_FIELD_OFFSET(::controller::InputDebug, trajectory_header_),
  PROTOBUF_FIELD_OFFSET(::controller::InputDebug, latest_replan_trajectory_header_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::controller::Debug, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::controller::Debug, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::controller::Debug, simple_lon_debug_),
  PROTOBUF_FIELD_OFFSET(::controller::Debug, simple_lat_debug_),
  PROTOBUF_FIELD_OFFSET(::controller::Debug, input_debug_),
  PROTOBUF_FIELD_OFFSET(::controller::Debug, simple_mpc_debug_),
  PROTOBUF_FIELD_OFFSET(::controller::Debug, simple_pid_lat_lon_debug_),
  0,
  1,
  2,
  3,
  4,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, sizeof(::controller::LatencyStats)},
  { 11, 38, sizeof(::controller::ControlCommand)},
  { 60, 99, sizeof(::controller::SimpleLongitudinalDebug)},
  { 133, 171, sizeof(::controller::SimpleLateralDebug)},
  { 204, 258, sizeof(::controller::SimpleMPCDebug)},
  { 307, 321, sizeof(::controller::SimplePIDLatLonDebug)},
  { 330, 341, sizeof(::controller::MracDebug)},
  { 347, 355, sizeof(::controller::MracAdaptiveGain)},
  { 358, 367, sizeof(::controller::InputDebug)},
  { 371, 381, sizeof(::controller::Debug)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::controller::_LatencyStats_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::controller::_ControlCommand_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::controller::_SimpleLongitudinalDebug_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::controller::_SimpleLateralDebug_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::controller::_SimpleMPCDebug_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::controller::_SimplePIDLatLonDebug_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::controller::_MracDebug_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::controller::_MracAdaptiveGain_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::controller::_InputDebug_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::controller::_Debug_default_instance_),
};

::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_control_5fcmd_2eproto = {
  {}, AddDescriptors_control_5fcmd_2eproto, "control_cmd.proto", schemas,
  file_default_instances, TableStruct_control_5fcmd_2eproto::offsets,
  file_level_metadata_control_5fcmd_2eproto, 10, file_level_enum_descriptors_control_5fcmd_2eproto, file_level_service_descriptors_control_5fcmd_2eproto,
};

const char descriptor_table_protodef_control_5fcmd_2eproto[] =
  "\n\021control_cmd.proto\022\ncontroller\032\rchassis"
  ".proto\032\014header.proto\032\017pnc_point.proto\"^\n"
  "\014LatencyStats\022\025\n\rtotal_time_ms\030\001 \001(\001\022\032\n\022"
  "controller_time_ms\030\002 \003(\001\022\033\n\023total_time_e"
  "xceeded\030\003 \001(\010\"\213\005\n\016ControlCommand\022\"\n\006head"
  "er\030\001 \001(\0132\022.controller.Header\022\020\n\010throttle"
  "\030\003 \001(\001\022\r\n\005brake\030\004 \001(\001\022\025\n\rsteering_rate\030\006"
  " \001(\001\022\027\n\017steering_target\030\007 \001(\001\022\025\n\rparking"
  "_brake\030\010 \001(\010\022\r\n\005speed\030\t \001(\001\022\024\n\014accelerat"
  "ion\030\n \001(\001\022\027\n\013reset_model\030\020 \001(\010B\002\030\001\022\025\n\ren"
  "gine_on_off\030\021 \001(\010\022\033\n\023trajectory_fraction"
  "\030\022 \001(\001\0225\n\014driving_mode\030\023 \001(\0162\033.canbus.Ch"
  "assis.DrivingModeB\002\030\001\0223\n\rgear_location\030\024"
  " \001(\0162\034.canbus.Chassis.GearPosition\022 \n\005de"
  "bug\030\026 \001(\0132\021.controller.Debug\022/\n\rlatency_"
  "stats\030\030 \001(\0132\030.controller.LatencyStats\022\036\n"
  "\017is_in_safe_mode\030\033 \001(\010:\005false\022\025\n\tleft_tu"
  "rn\030\r \001(\010B\002\030\001\022\026\n\nright_turn\030\016 \001(\010B\002\030\001\022\025\n\t"
  "high_beam\030\013 \001(\010B\002\030\001\022\024\n\010low_beam\030\014 \001(\010B\002\030"
  "\001\022\020\n\004horn\030\017 \001(\010B\002\030\001\022.\n\nturnsignal\030\025 \001(\0162"
  "\026.controller.TurnSignalB\002\030\001\"\230\010\n\027SimpleLo"
  "ngitudinalDebug\022\031\n\021station_reference\030\001 \001"
  "(\001\022\025\n\rstation_error\030\002 \001(\001\022\035\n\025station_err"
  "or_limited\030\003 \001(\001\022\035\n\025preview_station_erro"
  "r\030\004 \001(\001\022\027\n\017speed_reference\030\005 \001(\001\022\023\n\013spee"
  "d_error\030\006 \001(\001\022&\n\036speed_controller_input_"
  "limited\030\007 \001(\001\022\037\n\027preview_speed_reference"
  "\030\010 \001(\001\022\033\n\023preview_speed_error\030\t \001(\001\022&\n\036p"
  "review_acceleration_reference\030\n \001(\001\022\"\n\032a"
  "cceleration_cmd_closeloop\030\013 \001(\001\022\030\n\020accel"
  "eration_cmd\030\014 \001(\001\022\033\n\023acceleration_lookup"
  "\030\r \001(\001\022\024\n\014speed_lookup\030\016 \001(\001\022\031\n\021calibrat"
  "ion_value\030\017 \001(\001\022\024\n\014throttle_cmd\030\020 \001(\001\022\021\n"
  "\tbrake_cmd\030\021 \001(\001\022\024\n\014is_full_stop\030\022 \001(\010\022!"
  "\n\031slope_offset_compensation\030\023 \001(\001\022\027\n\017cur"
  "rent_station\030\024 \001(\001\022\023\n\013path_remain\030\025 \001(\001\022"
  "\035\n\025pid_saturation_status\030\026 \001(\005\022!\n\031leadla"
  "g_saturation_status\030\027 \001(\005\022\024\n\014speed_offse"
  "t\030\030 \001(\001\022\025\n\rcurrent_speed\030\031 \001(\001\022\036\n\026accele"
  "ration_reference\030\032 \001(\001\022\034\n\024current_accele"
  "ration\030\033 \001(\001\022\032\n\022acceleration_error\030\034 \001(\001"
  "\022\026\n\016jerk_reference\030\035 \001(\001\022\024\n\014current_jerk"
  "\030\036 \001(\001\022\022\n\njerk_error\030\037 \001(\001\0226\n\025current_ma"
  "tched_point\030  \001(\0132\027.points.TrajectoryPoi"
  "nt\0228\n\027current_reference_point\030! \001(\0132\027.po"
  "ints.TrajectoryPoint\0228\n\027preview_referenc"
  "e_point\030\" \001(\0132\027.points.TrajectoryPoint\"\210"
  "\010\n\022SimpleLateralDebug\022\025\n\rlateral_error\030\001"
  " \001(\001\022\023\n\013ref_heading\030\002 \001(\001\022\017\n\007heading\030\003 \001"
  "(\001\022\025\n\rheading_error\030\004 \001(\001\022\032\n\022heading_err"
  "or_rate\030\005 \001(\001\022\032\n\022lateral_error_rate\030\006 \001("
  "\001\022\021\n\tcurvature\030\007 \001(\001\022\023\n\013steer_angle\030\010 \001("
  "\001\022\037\n\027steer_angle_feedforward\030\t \001(\001\022(\n st"
  "eer_angle_lateral_contribution\030\n \001(\001\022-\n%"
  "steer_angle_lateral_rate_contribution\030\013 "
  "\001(\001\022(\n steer_angle_heading_contribution\030"
  "\014 \001(\001\022-\n%steer_angle_heading_rate_contri"
  "bution\030\r \001(\001\022\034\n\024steer_angle_feedback\030\016 \001"
  "(\001\022\031\n\021steering_position\030\017 \001(\001\022\021\n\tref_spe"
  "ed\030\020 \001(\001\022\033\n\023steer_angle_limited\030\021 \001(\001\022\034\n"
  "\024lateral_acceleration\030\022 \001(\001\022\024\n\014lateral_j"
  "erk\030\023 \001(\001\022\030\n\020ref_heading_rate\030\024 \001(\001\022\024\n\014h"
  "eading_rate\030\025 \001(\001\022 \n\030ref_heading_acceler"
  "ation\030\026 \001(\001\022\034\n\024heading_acceleration\030\027 \001("
  "\001\022\"\n\032heading_error_acceleration\030\030 \001(\001\022\030\n"
  "\020ref_heading_jerk\030\031 \001(\001\022\024\n\014heading_jerk\030"
  "\032 \001(\001\022\032\n\022heading_error_jerk\030\033 \001(\001\022\036\n\026lat"
  "eral_error_feedback\030\034 \001(\001\022\036\n\026heading_err"
  "or_feedback\030\035 \001(\001\0225\n\024current_target_poin"
  "t\030\036 \001(\0132\027.points.TrajectoryPoint\022$\n\034stee"
  "r_angle_feedback_augment\030\037 \001(\001\022/\n\020steer_"
  "mrac_debug\030  \001(\0132\025.controller.MracDebug\022"
  " \n\030steer_mrac_enable_status\030! \001(\010\"\362\n\n\016Si"
  "mpleMPCDebug\022\025\n\rlateral_error\030\001 \001(\001\022\023\n\013r"
  "ef_heading\030\002 \001(\001\022\017\n\007heading\030\003 \001(\001\022\025\n\rhea"
  "ding_error\030\004 \001(\001\022\032\n\022heading_error_rate\030\005"
  " \001(\001\022\032\n\022lateral_error_rate\030\006 \001(\001\022\021\n\tcurv"
  "ature\030\007 \001(\001\022\023\n\013steer_angle\030\010 \001(\001\022\037\n\027stee"
  "r_angle_feedforward\030\t \001(\001\022(\n steer_angle"
  "_lateral_contribution\030\n \001(\001\022-\n%steer_ang"
  "le_lateral_rate_contribution\030\013 \001(\001\022(\n st"
  "eer_angle_heading_contribution\030\014 \001(\001\022-\n%"
  "steer_angle_heading_rate_contribution\030\r "
  "\001(\001\022\034\n\024steer_angle_feedback\030\016 \001(\001\022\031\n\021ste"
  "ering_position\030\017 \001(\001\022\021\n\tref_speed\030\020 \001(\001\022"
  "\033\n\023steer_angle_limited\030\021 \001(\001\022\031\n\021station_"
  "reference\030\022 \001(\001\022\025\n\rstation_error\030\023 \001(\001\022\027"
  "\n\017speed_reference\030\024 \001(\001\022\023\n\013speed_error\030\025"
  " \001(\001\022\036\n\026acceleration_reference\030\026 \001(\001\022\024\n\014"
  "is_full_stop\030\027 \001(\010\022\030\n\020station_feedback\030\030"
  " \001(\001\022\026\n\016speed_feedback\030\031 \001(\001\022\"\n\032accelera"
  "tion_cmd_closeloop\030\032 \001(\001\022\030\n\020acceleration"
  "_cmd\030\033 \001(\001\022\033\n\023acceleration_lookup\030\034 \001(\001\022"
  "\024\n\014speed_lookup\030\035 \001(\001\022\031\n\021calibration_val"
  "ue\030\036 \001(\001\022(\n steer_unconstrained_control_"
  "diff\030\037 \001(\001\022,\n$steer_angle_feedforward_co"
  "mpensation\030  \001(\001\022\030\n\020matrix_q_updated\030! \003"
  "(\001\022\030\n\020matrix_r_updated\030\" \003(\001\022\034\n\024lateral_"
  "acceleration\030# \001(\001\022\024\n\014lateral_jerk\030$ \001(\001"
  "\022\030\n\020ref_heading_rate\030% \001(\001\022\024\n\014heading_ra"
  "te\030& \001(\001\022 \n\030ref_heading_acceleration\030\' \001"
  "(\001\022\034\n\024heading_acceleration\030( \001(\001\022\"\n\032head"
  "ing_error_acceleration\030) \001(\001\022\030\n\020ref_head"
  "ing_jerk\030* \001(\001\022\024\n\014heading_jerk\030+ \001(\001\022\032\n\022"
  "heading_error_jerk\030, \001(\001\022\035\n\025acceleration"
  "_feedback\030- \001(\001\022\032\n\022acceleration_error\030. "
  "\001(\001\022\026\n\016jerk_reference\030/ \001(\001\022\025\n\rjerk_feed"
  "back\0300 \001(\001\022\022\n\njerk_error\0301 \001(\001\"\216\002\n\024Simpl"
  "ePIDLatLonDebug\022\032\n\022look_ahead_station\030\001 "
  "\001(\001\022\025\n\rstation_error\030\002 \001(\001\022\025\n\rcurrent_sp"
  "eed\030\003 \001(\001\022\027\n\017current_heading\030\004 \001(\001\022\025\n\rhe"
  "ading_error\030\005 \001(\001\022!\n\031current_steer_wheel"
  "_angle\030\006 \001(\001\022\021\n\tspeed_cmd\030\007 \001(\001\022\027\n\017steer"
  "_angle_cmd\030\010 \001(\001\022-\n\014target_point\030\t \001(\0132\027"
  ".points.TrajectoryPoint\"\351\001\n\tMracDebug\022\030\n"
  "\020mrac_model_order\030\001 \001(\005\022\034\n\024mrac_referenc"
  "e_state\030\002 \003(\001\022\030\n\020mrac_state_error\030\003 \003(\001\022"
  "8\n\022mrac_adaptive_gain\030\004 \001(\0132\034.controller"
  ".MracAdaptiveGain\022(\n mrac_reference_satu"
  "ration_status\030\005 \001(\005\022&\n\036mrac_control_satu"
  "ration_status\030\006 \001(\005\"m\n\020MracAdaptiveGain\022"
  "\033\n\023state_adaptive_gain\030\001 \003(\001\022\033\n\023input_ad"
  "aptive_gain\030\002 \003(\001\022\037\n\027nonlinear_adaptive_"
  "gain\030\003 \003(\001\"\324\001\n\nInputDebug\022/\n\023localizatio"
  "n_header\030\001 \001(\0132\022.controller.Header\022)\n\rca"
  "nbus_header\030\002 \001(\0132\022.controller.Header\022-\n"
  "\021trajectory_header\030\003 \001(\0132\022.controller.He"
  "ader\022;\n\037latest_replan_trajectory_header\030"
  "\004 \001(\0132\022.controller.Header\"\247\002\n\005Debug\022=\n\020s"
  "imple_lon_debug\030\001 \001(\0132#.controller.Simpl"
  "eLongitudinalDebug\0228\n\020simple_lat_debug\030\002"
  " \001(\0132\036.controller.SimpleLateralDebug\022+\n\013"
  "input_debug\030\003 \001(\0132\026.controller.InputDebu"
  "g\0224\n\020simple_mpc_debug\030\004 \001(\0132\032.controller"
  ".SimpleMPCDebug\022B\n\030simple_pid_lat_lon_de"
  "bug\030\005 \001(\0132 .controller.SimplePIDLatLonDe"
  "bug*:\n\nTurnSignal\022\r\n\tTURN_NONE\020\000\022\r\n\tTURN"
  "_LEFT\020\001\022\016\n\nTURN_RIGHT\020\002"
  ;
::google::protobuf::internal::DescriptorTable descriptor_table_control_5fcmd_2eproto = {
  false, InitDefaults_control_5fcmd_2eproto, 
  descriptor_table_protodef_control_5fcmd_2eproto,
  "control_cmd.proto", &assign_descriptors_table_control_5fcmd_2eproto, 5503,
};

void AddDescriptors_control_5fcmd_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[3] =
  {
    ::AddDescriptors_chassis_2eproto,
    ::AddDescriptors_header_2eproto,
    ::AddDescriptors_pnc_5fpoint_2eproto,
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_control_5fcmd_2eproto, deps, 3);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_control_5fcmd_2eproto = []() { AddDescriptors_control_5fcmd_2eproto(); return true; }();
namespace controller {
const ::google::protobuf::EnumDescriptor* TurnSignal_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_control_5fcmd_2eproto);
  return file_level_enum_descriptors_control_5fcmd_2eproto[0];
}
bool TurnSignal_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void LatencyStats::InitAsDefaultInstance() {
}
class LatencyStats::HasBitSetters {
 public:
  static void set_has_total_time_ms(LatencyStats* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_total_time_exceeded(LatencyStats* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LatencyStats::kTotalTimeMsFieldNumber;
const int LatencyStats::kControllerTimeMsFieldNumber;
const int LatencyStats::kTotalTimeExceededFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LatencyStats::LatencyStats()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:controller.LatencyStats)
}
LatencyStats::LatencyStats(const LatencyStats& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      controller_time_ms_(from.controller_time_ms_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&total_time_ms_, &from.total_time_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&total_time_exceeded_) -
    reinterpret_cast<char*>(&total_time_ms_)) + sizeof(total_time_exceeded_));
  // @@protoc_insertion_point(copy_constructor:controller.LatencyStats)
}

void LatencyStats::SharedCtor() {
  ::memset(&total_time_ms_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&total_time_exceeded_) -
      reinterpret_cast<char*>(&total_time_ms_)) + sizeof(total_time_exceeded_));
}

LatencyStats::~LatencyStats() {
  // @@protoc_insertion_point(destructor:controller.LatencyStats)
  SharedDtor();
}

void LatencyStats::SharedDtor() {
}

void LatencyStats::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LatencyStats& LatencyStats::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_LatencyStats_control_5fcmd_2eproto.base);
  return *internal_default_instance();
}


void LatencyStats::Clear() {
// @@protoc_insertion_point(message_clear_start:controller.LatencyStats)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  controller_time_ms_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&total_time_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&total_time_exceeded_) -
        reinterpret_cast<char*>(&total_time_ms_)) + sizeof(total_time_exceeded_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* LatencyStats::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<LatencyStats*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional double total_time_ms = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_total_time_ms(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // repeated double controller_time_ms = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) == 17) {
          do {
            msg->add_controller_time_ms(::google::protobuf::io::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 17 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedDoubleParser;
        object = msg->mutable_controller_time_ms();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // optional bool total_time_exceeded = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_total_time_exceeded(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool LatencyStats::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:controller.LatencyStats)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double total_time_ms = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_total_time_ms(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &total_time_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double controller_time_ms = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 17u, input, this->mutable_controller_time_ms())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_controller_time_ms())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool total_time_exceeded = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_total_time_exceeded(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &total_time_exceeded_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:controller.LatencyStats)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:controller.LatencyStats)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void LatencyStats::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:controller.LatencyStats)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double total_time_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->total_time_ms(), output);
  }

  // repeated double controller_time_ms = 2;
  for (int i = 0, n = this->controller_time_ms_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      2, this->controller_time_ms(i), output);
  }

  // optional bool total_time_exceeded = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->total_time_exceeded(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:controller.LatencyStats)
}

::google::protobuf::uint8* LatencyStats::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:controller.LatencyStats)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double total_time_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->total_time_ms(), target);
  }

  // repeated double controller_time_ms = 2;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(2, this->controller_time_ms_, target);

  // optional bool total_time_exceeded = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->total_time_exceeded(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:controller.LatencyStats)
  return target;
}

size_t LatencyStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:controller.LatencyStats)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double controller_time_ms = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->controller_time_ms_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->controller_time_ms_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double total_time_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional bool total_time_exceeded = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LatencyStats::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:controller.LatencyStats)
  GOOGLE_DCHECK_NE(&from, this);
  const LatencyStats* source =
      ::google::protobuf::DynamicCastToGenerated<LatencyStats>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:controller.LatencyStats)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:controller.LatencyStats)
    MergeFrom(*source);
  }
}

void LatencyStats::MergeFrom(const LatencyStats& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:controller.LatencyStats)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  controller_time_ms_.MergeFrom(from.controller_time_ms_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      total_time_ms_ = from.total_time_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      total_time_exceeded_ = from.total_time_exceeded_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LatencyStats::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:controller.LatencyStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LatencyStats::CopyFrom(const LatencyStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:controller.LatencyStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LatencyStats::IsInitialized() const {
  return true;
}

void LatencyStats::Swap(LatencyStats* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LatencyStats::InternalSwap(LatencyStats* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  controller_time_ms_.InternalSwap(&other->controller_time_ms_);
  swap(total_time_ms_, other->total_time_ms_);
  swap(total_time_exceeded_, other->total_time_exceeded_);
}

::google::protobuf::Metadata LatencyStats::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_control_5fcmd_2eproto);
  return ::file_level_metadata_control_5fcmd_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ControlCommand::InitAsDefaultInstance() {
  ::controller::_ControlCommand_default_instance_._instance.get_mutable()->header_ = const_cast< ::controller::Header*>(
      ::controller::Header::internal_default_instance());
  ::controller::_ControlCommand_default_instance_._instance.get_mutable()->debug_ = const_cast< ::controller::Debug*>(
      ::controller::Debug::internal_default_instance());
  ::controller::_ControlCommand_default_instance_._instance.get_mutable()->latency_stats_ = const_cast< ::controller::LatencyStats*>(
      ::controller::LatencyStats::internal_default_instance());
}
class ControlCommand::HasBitSetters {
 public:
  static const ::controller::Header& header(const ControlCommand* msg);
  static void set_has_header(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_throttle(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_brake(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_steering_rate(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_steering_target(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_parking_brake(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00004000u;
  }
  static void set_has_speed(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_acceleration(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_reset_model(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00008000u;
  }
  static void set_has_engine_on_off(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00010000u;
  }
  static void set_has_trajectory_fraction(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00080000u;
  }
  static void set_has_driving_mode(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00040000u;
  }
  static void set_has_gear_location(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00100000u;
  }
  static const ::controller::Debug& debug(const ControlCommand* msg);
  static void set_has_debug(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::controller::LatencyStats& latency_stats(const ControlCommand* msg);
  static void set_has_latency_stats(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_is_in_safe_mode(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00020000u;
  }
  static void set_has_left_turn(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
  static void set_has_right_turn(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static void set_has_high_beam(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00000800u;
  }
  static void set_has_low_beam(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00001000u;
  }
  static void set_has_horn(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00002000u;
  }
  static void set_has_turnsignal(ControlCommand* msg) {
    msg->_has_bits_[0] |= 0x00200000u;
  }
};

const ::controller::Header&
ControlCommand::HasBitSetters::header(const ControlCommand* msg) {
  return *msg->header_;
}
const ::controller::Debug&
ControlCommand::HasBitSetters::debug(const ControlCommand* msg) {
  return *msg->debug_;
}
const ::controller::LatencyStats&
ControlCommand::HasBitSetters::latency_stats(const ControlCommand* msg) {
  return *msg->latency_stats_;
}
void ControlCommand::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ControlCommand::kHeaderFieldNumber;
const int ControlCommand::kThrottleFieldNumber;
const int ControlCommand::kBrakeFieldNumber;
const int ControlCommand::kSteeringRateFieldNumber;
const int ControlCommand::kSteeringTargetFieldNumber;
const int ControlCommand::kParkingBrakeFieldNumber;
const int ControlCommand::kSpeedFieldNumber;
const int ControlCommand::kAccelerationFieldNumber;
const int ControlCommand::kResetModelFieldNumber;
const int ControlCommand::kEngineOnOffFieldNumber;
const int ControlCommand::kTrajectoryFractionFieldNumber;
const int ControlCommand::kDrivingModeFieldNumber;
const int ControlCommand::kGearLocationFieldNumber;
const int ControlCommand::kDebugFieldNumber;
const int ControlCommand::kLatencyStatsFieldNumber;
const int ControlCommand::kIsInSafeModeFieldNumber;
const int ControlCommand::kLeftTurnFieldNumber;
const int ControlCommand::kRightTurnFieldNumber;
const int ControlCommand::kHighBeamFieldNumber;
const int ControlCommand::kLowBeamFieldNumber;
const int ControlCommand::kHornFieldNumber;
const int ControlCommand::kTurnsignalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ControlCommand::ControlCommand()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:controller.ControlCommand)
}
ControlCommand::ControlCommand(const ControlCommand& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::controller::Header(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from.has_debug()) {
    debug_ = new ::controller::Debug(*from.debug_);
  } else {
    debug_ = nullptr;
  }
  if (from.has_latency_stats()) {
    latency_stats_ = new ::controller::LatencyStats(*from.latency_stats_);
  } else {
    latency_stats_ = nullptr;
  }
  ::memcpy(&throttle_, &from.throttle_,
    static_cast<size_t>(reinterpret_cast<char*>(&turnsignal_) -
    reinterpret_cast<char*>(&throttle_)) + sizeof(turnsignal_));
  // @@protoc_insertion_point(copy_constructor:controller.ControlCommand)
}

void ControlCommand::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ControlCommand_control_5fcmd_2eproto.base);
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&turnsignal_) -
      reinterpret_cast<char*>(&header_)) + sizeof(turnsignal_));
}

ControlCommand::~ControlCommand() {
  // @@protoc_insertion_point(destructor:controller.ControlCommand)
  SharedDtor();
}

void ControlCommand::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete debug_;
  if (this != internal_default_instance()) delete latency_stats_;
}

void ControlCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ControlCommand& ControlCommand::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ControlCommand_control_5fcmd_2eproto.base);
  return *internal_default_instance();
}


void ControlCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:controller.ControlCommand)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != nullptr);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(debug_ != nullptr);
      debug_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(latency_stats_ != nullptr);
      latency_stats_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&throttle_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&speed_) -
        reinterpret_cast<char*>(&throttle_)) + sizeof(speed_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&acceleration_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&reset_model_) -
        reinterpret_cast<char*>(&acceleration_)) + sizeof(reset_model_));
  }
  if (cached_has_bits & 0x003f0000u) {
    ::memset(&engine_on_off_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&turnsignal_) -
        reinterpret_cast<char*>(&engine_on_off_)) + sizeof(turnsignal_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ControlCommand::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ControlCommand*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .controller.Header header = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::controller::Header::_InternalParse;
        object = msg->mutable_header();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional double throttle = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_throttle(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double brake = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_brake(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steering_rate = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 49) goto handle_unusual;
        msg->set_steering_rate(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steering_target = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 57) goto handle_unusual;
        msg->set_steering_target(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional bool parking_brake = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        msg->set_parking_brake(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional double speed = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 73) goto handle_unusual;
        msg->set_speed(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double acceleration = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 81) goto handle_unusual;
        msg->set_acceleration(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional bool high_beam = 11 [deprecated = true];
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 88) goto handle_unusual;
        msg->set_high_beam(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool low_beam = 12 [deprecated = true];
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        msg->set_low_beam(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool left_turn = 13 [deprecated = true];
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 104) goto handle_unusual;
        msg->set_left_turn(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool right_turn = 14 [deprecated = true];
      case 14: {
        if (static_cast<::google::protobuf::uint8>(tag) != 112) goto handle_unusual;
        msg->set_right_turn(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool horn = 15 [deprecated = true];
      case 15: {
        if (static_cast<::google::protobuf::uint8>(tag) != 120) goto handle_unusual;
        msg->set_horn(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool reset_model = 16 [deprecated = true];
      case 16: {
        if (static_cast<::google::protobuf::uint8>(tag) != 128) goto handle_unusual;
        msg->set_reset_model(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool engine_on_off = 17;
      case 17: {
        if (static_cast<::google::protobuf::uint8>(tag) != 136) goto handle_unusual;
        msg->set_engine_on_off(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional double trajectory_fraction = 18;
      case 18: {
        if (static_cast<::google::protobuf::uint8>(tag) != 145) goto handle_unusual;
        msg->set_trajectory_fraction(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional .canbus.Chassis.DrivingMode driving_mode = 19 [deprecated = true];
      case 19: {
        if (static_cast<::google::protobuf::uint8>(tag) != 152) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::canbus::Chassis_DrivingMode_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(19, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_driving_mode(static_cast<::canbus::Chassis_DrivingMode>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .canbus.Chassis.GearPosition gear_location = 20;
      case 20: {
        if (static_cast<::google::protobuf::uint8>(tag) != 160) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::canbus::Chassis_GearPosition_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(20, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_gear_location(static_cast<::canbus::Chassis_GearPosition>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .controller.TurnSignal turnsignal = 21 [deprecated = true];
      case 21: {
        if (static_cast<::google::protobuf::uint8>(tag) != 168) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::controller::TurnSignal_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(21, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_turnsignal(static_cast<::controller::TurnSignal>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .controller.Debug debug = 22;
      case 22: {
        if (static_cast<::google::protobuf::uint8>(tag) != 178) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::controller::Debug::_InternalParse;
        object = msg->mutable_debug();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .controller.LatencyStats latency_stats = 24;
      case 24: {
        if (static_cast<::google::protobuf::uint8>(tag) != 194) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::controller::LatencyStats::_InternalParse;
        object = msg->mutable_latency_stats();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional bool is_in_safe_mode = 27 [default = false];
      case 27: {
        if (static_cast<::google::protobuf::uint8>(tag) != 216) goto handle_unusual;
        msg->set_is_in_safe_mode(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ControlCommand::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:controller.ControlCommand)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .controller.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double throttle = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_throttle(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &throttle_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double brake = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {
          HasBitSetters::set_has_brake(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &brake_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steering_rate = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (49 & 0xFF)) {
          HasBitSetters::set_has_steering_rate(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steering_rate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steering_target = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (57 & 0xFF)) {
          HasBitSetters::set_has_steering_target(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steering_target_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool parking_brake = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_parking_brake(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &parking_brake_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double speed = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (73 & 0xFF)) {
          HasBitSetters::set_has_speed(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &speed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double acceleration = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (81 & 0xFF)) {
          HasBitSetters::set_has_acceleration(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &acceleration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool high_beam = 11 [deprecated = true];
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (88 & 0xFF)) {
          HasBitSetters::set_has_high_beam(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &high_beam_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool low_beam = 12 [deprecated = true];
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_low_beam(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &low_beam_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool left_turn = 13 [deprecated = true];
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (104 & 0xFF)) {
          HasBitSetters::set_has_left_turn(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &left_turn_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool right_turn = 14 [deprecated = true];
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (112 & 0xFF)) {
          HasBitSetters::set_has_right_turn(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &right_turn_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool horn = 15 [deprecated = true];
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (120 & 0xFF)) {
          HasBitSetters::set_has_horn(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &horn_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool reset_model = 16 [deprecated = true];
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (128 & 0xFF)) {
          HasBitSetters::set_has_reset_model(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &reset_model_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool engine_on_off = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (136 & 0xFF)) {
          HasBitSetters::set_has_engine_on_off(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &engine_on_off_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double trajectory_fraction = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (145 & 0xFF)) {
          HasBitSetters::set_has_trajectory_fraction(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &trajectory_fraction_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .canbus.Chassis.DrivingMode driving_mode = 19 [deprecated = true];
      case 19: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (152 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::canbus::Chassis_DrivingMode_IsValid(value)) {
            set_driving_mode(static_cast< ::canbus::Chassis_DrivingMode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                19, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .canbus.Chassis.GearPosition gear_location = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (160 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::canbus::Chassis_GearPosition_IsValid(value)) {
            set_gear_location(static_cast< ::canbus::Chassis_GearPosition >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                20, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .controller.TurnSignal turnsignal = 21 [deprecated = true];
      case 21: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (168 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::controller::TurnSignal_IsValid(value)) {
            set_turnsignal(static_cast< ::controller::TurnSignal >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                21, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .controller.Debug debug = 22;
      case 22: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (178 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_debug()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .controller.LatencyStats latency_stats = 24;
      case 24: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (194 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_latency_stats()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_in_safe_mode = 27 [default = false];
      case 27: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (216 & 0xFF)) {
          HasBitSetters::set_has_is_in_safe_mode(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_in_safe_mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:controller.ControlCommand)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:controller.ControlCommand)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ControlCommand::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:controller.ControlCommand)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .controller.Header header = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::header(this), output);
  }

  // optional double throttle = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->throttle(), output);
  }

  // optional double brake = 4;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->brake(), output);
  }

  // optional double steering_rate = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->steering_rate(), output);
  }

  // optional double steering_target = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->steering_target(), output);
  }

  // optional bool parking_brake = 8;
  if (cached_has_bits & 0x00004000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->parking_brake(), output);
  }

  // optional double speed = 9;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->speed(), output);
  }

  // optional double acceleration = 10;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(10, this->acceleration(), output);
  }

  // optional bool high_beam = 11 [deprecated = true];
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->high_beam(), output);
  }

  // optional bool low_beam = 12 [deprecated = true];
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->low_beam(), output);
  }

  // optional bool left_turn = 13 [deprecated = true];
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->left_turn(), output);
  }

  // optional bool right_turn = 14 [deprecated = true];
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->right_turn(), output);
  }

  // optional bool horn = 15 [deprecated = true];
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->horn(), output);
  }

  // optional bool reset_model = 16 [deprecated = true];
  if (cached_has_bits & 0x00008000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(16, this->reset_model(), output);
  }

  // optional bool engine_on_off = 17;
  if (cached_has_bits & 0x00010000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(17, this->engine_on_off(), output);
  }

  // optional double trajectory_fraction = 18;
  if (cached_has_bits & 0x00080000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(18, this->trajectory_fraction(), output);
  }

  // optional .canbus.Chassis.DrivingMode driving_mode = 19 [deprecated = true];
  if (cached_has_bits & 0x00040000u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      19, this->driving_mode(), output);
  }

  // optional .canbus.Chassis.GearPosition gear_location = 20;
  if (cached_has_bits & 0x00100000u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      20, this->gear_location(), output);
  }

  // optional .controller.TurnSignal turnsignal = 21 [deprecated = true];
  if (cached_has_bits & 0x00200000u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      21, this->turnsignal(), output);
  }

  // optional .controller.Debug debug = 22;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      22, HasBitSetters::debug(this), output);
  }

  // optional .controller.LatencyStats latency_stats = 24;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      24, HasBitSetters::latency_stats(this), output);
  }

  // optional bool is_in_safe_mode = 27 [default = false];
  if (cached_has_bits & 0x00020000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(27, this->is_in_safe_mode(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:controller.ControlCommand)
}

::google::protobuf::uint8* ControlCommand::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:controller.ControlCommand)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .controller.Header header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::header(this), target);
  }

  // optional double throttle = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->throttle(), target);
  }

  // optional double brake = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->brake(), target);
  }

  // optional double steering_rate = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->steering_rate(), target);
  }

  // optional double steering_target = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->steering_target(), target);
  }

  // optional bool parking_brake = 8;
  if (cached_has_bits & 0x00004000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->parking_brake(), target);
  }

  // optional double speed = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->speed(), target);
  }

  // optional double acceleration = 10;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(10, this->acceleration(), target);
  }

  // optional bool high_beam = 11 [deprecated = true];
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->high_beam(), target);
  }

  // optional bool low_beam = 12 [deprecated = true];
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->low_beam(), target);
  }

  // optional bool left_turn = 13 [deprecated = true];
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->left_turn(), target);
  }

  // optional bool right_turn = 14 [deprecated = true];
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(14, this->right_turn(), target);
  }

  // optional bool horn = 15 [deprecated = true];
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(15, this->horn(), target);
  }

  // optional bool reset_model = 16 [deprecated = true];
  if (cached_has_bits & 0x00008000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(16, this->reset_model(), target);
  }

  // optional bool engine_on_off = 17;
  if (cached_has_bits & 0x00010000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(17, this->engine_on_off(), target);
  }

  // optional double trajectory_fraction = 18;
  if (cached_has_bits & 0x00080000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(18, this->trajectory_fraction(), target);
  }

  // optional .canbus.Chassis.DrivingMode driving_mode = 19 [deprecated = true];
  if (cached_has_bits & 0x00040000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      19, this->driving_mode(), target);
  }

  // optional .canbus.Chassis.GearPosition gear_location = 20;
  if (cached_has_bits & 0x00100000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      20, this->gear_location(), target);
  }

  // optional .controller.TurnSignal turnsignal = 21 [deprecated = true];
  if (cached_has_bits & 0x00200000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      21, this->turnsignal(), target);
  }

  // optional .controller.Debug debug = 22;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        22, HasBitSetters::debug(this), target);
  }

  // optional .controller.LatencyStats latency_stats = 24;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        24, HasBitSetters::latency_stats(this), target);
  }

  // optional bool is_in_safe_mode = 27 [default = false];
  if (cached_has_bits & 0x00020000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(27, this->is_in_safe_mode(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:controller.ControlCommand)
  return target;
}

size_t ControlCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:controller.ControlCommand)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .controller.Header header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *header_);
    }

    // optional .controller.Debug debug = 22;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *debug_);
    }

    // optional .controller.LatencyStats latency_stats = 24;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *latency_stats_);
    }

    // optional double throttle = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double brake = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double steering_rate = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double steering_target = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double speed = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double acceleration = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional bool left_turn = 13 [deprecated = true];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool right_turn = 14 [deprecated = true];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool high_beam = 11 [deprecated = true];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool low_beam = 12 [deprecated = true];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool horn = 15 [deprecated = true];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool parking_brake = 8;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool reset_model = 16 [deprecated = true];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x003f0000u) {
    // optional bool engine_on_off = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool is_in_safe_mode = 27 [default = false];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional .canbus.Chassis.DrivingMode driving_mode = 19 [deprecated = true];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->driving_mode());
    }

    // optional double trajectory_fraction = 18;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 8;
    }

    // optional .canbus.Chassis.GearPosition gear_location = 20;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->gear_location());
    }

    // optional .controller.TurnSignal turnsignal = 21 [deprecated = true];
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->turnsignal());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ControlCommand::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:controller.ControlCommand)
  GOOGLE_DCHECK_NE(&from, this);
  const ControlCommand* source =
      ::google::protobuf::DynamicCastToGenerated<ControlCommand>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:controller.ControlCommand)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:controller.ControlCommand)
    MergeFrom(*source);
  }
}

void ControlCommand::MergeFrom(const ControlCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:controller.ControlCommand)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_header()->::controller::Header::MergeFrom(from.header());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_debug()->::controller::Debug::MergeFrom(from.debug());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_latency_stats()->::controller::LatencyStats::MergeFrom(from.latency_stats());
    }
    if (cached_has_bits & 0x00000008u) {
      throttle_ = from.throttle_;
    }
    if (cached_has_bits & 0x00000010u) {
      brake_ = from.brake_;
    }
    if (cached_has_bits & 0x00000020u) {
      steering_rate_ = from.steering_rate_;
    }
    if (cached_has_bits & 0x00000040u) {
      steering_target_ = from.steering_target_;
    }
    if (cached_has_bits & 0x00000080u) {
      speed_ = from.speed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      acceleration_ = from.acceleration_;
    }
    if (cached_has_bits & 0x00000200u) {
      left_turn_ = from.left_turn_;
    }
    if (cached_has_bits & 0x00000400u) {
      right_turn_ = from.right_turn_;
    }
    if (cached_has_bits & 0x00000800u) {
      high_beam_ = from.high_beam_;
    }
    if (cached_has_bits & 0x00001000u) {
      low_beam_ = from.low_beam_;
    }
    if (cached_has_bits & 0x00002000u) {
      horn_ = from.horn_;
    }
    if (cached_has_bits & 0x00004000u) {
      parking_brake_ = from.parking_brake_;
    }
    if (cached_has_bits & 0x00008000u) {
      reset_model_ = from.reset_model_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x003f0000u) {
    if (cached_has_bits & 0x00010000u) {
      engine_on_off_ = from.engine_on_off_;
    }
    if (cached_has_bits & 0x00020000u) {
      is_in_safe_mode_ = from.is_in_safe_mode_;
    }
    if (cached_has_bits & 0x00040000u) {
      driving_mode_ = from.driving_mode_;
    }
    if (cached_has_bits & 0x00080000u) {
      trajectory_fraction_ = from.trajectory_fraction_;
    }
    if (cached_has_bits & 0x00100000u) {
      gear_location_ = from.gear_location_;
    }
    if (cached_has_bits & 0x00200000u) {
      turnsignal_ = from.turnsignal_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ControlCommand::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:controller.ControlCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ControlCommand::CopyFrom(const ControlCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:controller.ControlCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControlCommand::IsInitialized() const {
  return true;
}

void ControlCommand::Swap(ControlCommand* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ControlCommand::InternalSwap(ControlCommand* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(header_, other->header_);
  swap(debug_, other->debug_);
  swap(latency_stats_, other->latency_stats_);
  swap(throttle_, other->throttle_);
  swap(brake_, other->brake_);
  swap(steering_rate_, other->steering_rate_);
  swap(steering_target_, other->steering_target_);
  swap(speed_, other->speed_);
  swap(acceleration_, other->acceleration_);
  swap(left_turn_, other->left_turn_);
  swap(right_turn_, other->right_turn_);
  swap(high_beam_, other->high_beam_);
  swap(low_beam_, other->low_beam_);
  swap(horn_, other->horn_);
  swap(parking_brake_, other->parking_brake_);
  swap(reset_model_, other->reset_model_);
  swap(engine_on_off_, other->engine_on_off_);
  swap(is_in_safe_mode_, other->is_in_safe_mode_);
  swap(driving_mode_, other->driving_mode_);
  swap(trajectory_fraction_, other->trajectory_fraction_);
  swap(gear_location_, other->gear_location_);
  swap(turnsignal_, other->turnsignal_);
}

::google::protobuf::Metadata ControlCommand::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_control_5fcmd_2eproto);
  return ::file_level_metadata_control_5fcmd_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SimpleLongitudinalDebug::InitAsDefaultInstance() {
  ::controller::_SimpleLongitudinalDebug_default_instance_._instance.get_mutable()->current_matched_point_ = const_cast< ::points::TrajectoryPoint*>(
      ::points::TrajectoryPoint::internal_default_instance());
  ::controller::_SimpleLongitudinalDebug_default_instance_._instance.get_mutable()->current_reference_point_ = const_cast< ::points::TrajectoryPoint*>(
      ::points::TrajectoryPoint::internal_default_instance());
  ::controller::_SimpleLongitudinalDebug_default_instance_._instance.get_mutable()->preview_reference_point_ = const_cast< ::points::TrajectoryPoint*>(
      ::points::TrajectoryPoint::internal_default_instance());
}
class SimpleLongitudinalDebug::HasBitSetters {
 public:
  static void set_has_station_reference(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_station_error(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_station_error_limited(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_preview_station_error(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_speed_reference(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_speed_error(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_speed_controller_input_limited(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
  static void set_has_preview_speed_reference(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static void set_has_preview_speed_error(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00000800u;
  }
  static void set_has_preview_acceleration_reference(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00001000u;
  }
  static void set_has_acceleration_cmd_closeloop(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00002000u;
  }
  static void set_has_acceleration_cmd(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00004000u;
  }
  static void set_has_acceleration_lookup(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00008000u;
  }
  static void set_has_speed_lookup(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00010000u;
  }
  static void set_has_calibration_value(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00020000u;
  }
  static void set_has_throttle_cmd(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00040000u;
  }
  static void set_has_brake_cmd(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00080000u;
  }
  static void set_has_is_full_stop(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00400000u;
  }
  static void set_has_slope_offset_compensation(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00100000u;
  }
  static void set_has_current_station(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00200000u;
  }
  static void set_has_path_remain(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x01000000u;
  }
  static void set_has_pid_saturation_status(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00800000u;
  }
  static void set_has_leadlag_saturation_status(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[1] |= 0x00000002u;
  }
  static void set_has_speed_offset(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x02000000u;
  }
  static void set_has_current_speed(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x04000000u;
  }
  static void set_has_acceleration_reference(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x08000000u;
  }
  static void set_has_current_acceleration(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x10000000u;
  }
  static void set_has_acceleration_error(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x20000000u;
  }
  static void set_has_jerk_reference(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x40000000u;
  }
  static void set_has_current_jerk(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x80000000u;
  }
  static void set_has_jerk_error(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[1] |= 0x00000001u;
  }
  static const ::points::TrajectoryPoint& current_matched_point(const SimpleLongitudinalDebug* msg);
  static void set_has_current_matched_point(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::points::TrajectoryPoint& current_reference_point(const SimpleLongitudinalDebug* msg);
  static void set_has_current_reference_point(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::points::TrajectoryPoint& preview_reference_point(const SimpleLongitudinalDebug* msg);
  static void set_has_preview_reference_point(SimpleLongitudinalDebug* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::points::TrajectoryPoint&
SimpleLongitudinalDebug::HasBitSetters::current_matched_point(const SimpleLongitudinalDebug* msg) {
  return *msg->current_matched_point_;
}
const ::points::TrajectoryPoint&
SimpleLongitudinalDebug::HasBitSetters::current_reference_point(const SimpleLongitudinalDebug* msg) {
  return *msg->current_reference_point_;
}
const ::points::TrajectoryPoint&
SimpleLongitudinalDebug::HasBitSetters::preview_reference_point(const SimpleLongitudinalDebug* msg) {
  return *msg->preview_reference_point_;
}
void SimpleLongitudinalDebug::clear_current_matched_point() {
  if (current_matched_point_ != nullptr) current_matched_point_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void SimpleLongitudinalDebug::clear_current_reference_point() {
  if (current_reference_point_ != nullptr) current_reference_point_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void SimpleLongitudinalDebug::clear_preview_reference_point() {
  if (preview_reference_point_ != nullptr) preview_reference_point_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SimpleLongitudinalDebug::kStationReferenceFieldNumber;
const int SimpleLongitudinalDebug::kStationErrorFieldNumber;
const int SimpleLongitudinalDebug::kStationErrorLimitedFieldNumber;
const int SimpleLongitudinalDebug::kPreviewStationErrorFieldNumber;
const int SimpleLongitudinalDebug::kSpeedReferenceFieldNumber;
const int SimpleLongitudinalDebug::kSpeedErrorFieldNumber;
const int SimpleLongitudinalDebug::kSpeedControllerInputLimitedFieldNumber;
const int SimpleLongitudinalDebug::kPreviewSpeedReferenceFieldNumber;
const int SimpleLongitudinalDebug::kPreviewSpeedErrorFieldNumber;
const int SimpleLongitudinalDebug::kPreviewAccelerationReferenceFieldNumber;
const int SimpleLongitudinalDebug::kAccelerationCmdCloseloopFieldNumber;
const int SimpleLongitudinalDebug::kAccelerationCmdFieldNumber;
const int SimpleLongitudinalDebug::kAccelerationLookupFieldNumber;
const int SimpleLongitudinalDebug::kSpeedLookupFieldNumber;
const int SimpleLongitudinalDebug::kCalibrationValueFieldNumber;
const int SimpleLongitudinalDebug::kThrottleCmdFieldNumber;
const int SimpleLongitudinalDebug::kBrakeCmdFieldNumber;
const int SimpleLongitudinalDebug::kIsFullStopFieldNumber;
const int SimpleLongitudinalDebug::kSlopeOffsetCompensationFieldNumber;
const int SimpleLongitudinalDebug::kCurrentStationFieldNumber;
const int SimpleLongitudinalDebug::kPathRemainFieldNumber;
const int SimpleLongitudinalDebug::kPidSaturationStatusFieldNumber;
const int SimpleLongitudinalDebug::kLeadlagSaturationStatusFieldNumber;
const int SimpleLongitudinalDebug::kSpeedOffsetFieldNumber;
const int SimpleLongitudinalDebug::kCurrentSpeedFieldNumber;
const int SimpleLongitudinalDebug::kAccelerationReferenceFieldNumber;
const int SimpleLongitudinalDebug::kCurrentAccelerationFieldNumber;
const int SimpleLongitudinalDebug::kAccelerationErrorFieldNumber;
const int SimpleLongitudinalDebug::kJerkReferenceFieldNumber;
const int SimpleLongitudinalDebug::kCurrentJerkFieldNumber;
const int SimpleLongitudinalDebug::kJerkErrorFieldNumber;
const int SimpleLongitudinalDebug::kCurrentMatchedPointFieldNumber;
const int SimpleLongitudinalDebug::kCurrentReferencePointFieldNumber;
const int SimpleLongitudinalDebug::kPreviewReferencePointFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SimpleLongitudinalDebug::SimpleLongitudinalDebug()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:controller.SimpleLongitudinalDebug)
}
SimpleLongitudinalDebug::SimpleLongitudinalDebug(const SimpleLongitudinalDebug& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_current_matched_point()) {
    current_matched_point_ = new ::points::TrajectoryPoint(*from.current_matched_point_);
  } else {
    current_matched_point_ = nullptr;
  }
  if (from.has_current_reference_point()) {
    current_reference_point_ = new ::points::TrajectoryPoint(*from.current_reference_point_);
  } else {
    current_reference_point_ = nullptr;
  }
  if (from.has_preview_reference_point()) {
    preview_reference_point_ = new ::points::TrajectoryPoint(*from.preview_reference_point_);
  } else {
    preview_reference_point_ = nullptr;
  }
  ::memcpy(&station_reference_, &from.station_reference_,
    static_cast<size_t>(reinterpret_cast<char*>(&leadlag_saturation_status_) -
    reinterpret_cast<char*>(&station_reference_)) + sizeof(leadlag_saturation_status_));
  // @@protoc_insertion_point(copy_constructor:controller.SimpleLongitudinalDebug)
}

void SimpleLongitudinalDebug::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_SimpleLongitudinalDebug_control_5fcmd_2eproto.base);
  ::memset(&current_matched_point_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&leadlag_saturation_status_) -
      reinterpret_cast<char*>(&current_matched_point_)) + sizeof(leadlag_saturation_status_));
}

SimpleLongitudinalDebug::~SimpleLongitudinalDebug() {
  // @@protoc_insertion_point(destructor:controller.SimpleLongitudinalDebug)
  SharedDtor();
}

void SimpleLongitudinalDebug::SharedDtor() {
  if (this != internal_default_instance()) delete current_matched_point_;
  if (this != internal_default_instance()) delete current_reference_point_;
  if (this != internal_default_instance()) delete preview_reference_point_;
}

void SimpleLongitudinalDebug::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SimpleLongitudinalDebug& SimpleLongitudinalDebug::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SimpleLongitudinalDebug_control_5fcmd_2eproto.base);
  return *internal_default_instance();
}


void SimpleLongitudinalDebug::Clear() {
// @@protoc_insertion_point(message_clear_start:controller.SimpleLongitudinalDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(current_matched_point_ != nullptr);
      current_matched_point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(current_reference_point_ != nullptr);
      current_reference_point_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(preview_reference_point_ != nullptr);
      preview_reference_point_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&station_reference_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&speed_reference_) -
        reinterpret_cast<char*>(&station_reference_)) + sizeof(speed_reference_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&speed_error_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&acceleration_lookup_) -
        reinterpret_cast<char*>(&speed_error_)) + sizeof(acceleration_lookup_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&speed_lookup_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pid_saturation_status_) -
        reinterpret_cast<char*>(&speed_lookup_)) + sizeof(pid_saturation_status_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&path_remain_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&current_jerk_) -
        reinterpret_cast<char*>(&path_remain_)) + sizeof(current_jerk_));
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&jerk_error_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&leadlag_saturation_status_) -
        reinterpret_cast<char*>(&jerk_error_)) + sizeof(leadlag_saturation_status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SimpleLongitudinalDebug::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SimpleLongitudinalDebug*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional double station_reference = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_station_reference(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double station_error = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_station_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double station_error_limited = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_station_error_limited(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double preview_station_error = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_preview_station_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double speed_reference = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 41) goto handle_unusual;
        msg->set_speed_reference(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double speed_error = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 49) goto handle_unusual;
        msg->set_speed_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double speed_controller_input_limited = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 57) goto handle_unusual;
        msg->set_speed_controller_input_limited(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double preview_speed_reference = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 65) goto handle_unusual;
        msg->set_preview_speed_reference(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double preview_speed_error = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 73) goto handle_unusual;
        msg->set_preview_speed_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double preview_acceleration_reference = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 81) goto handle_unusual;
        msg->set_preview_acceleration_reference(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double acceleration_cmd_closeloop = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 89) goto handle_unusual;
        msg->set_acceleration_cmd_closeloop(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double acceleration_cmd = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 97) goto handle_unusual;
        msg->set_acceleration_cmd(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double acceleration_lookup = 13;
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 105) goto handle_unusual;
        msg->set_acceleration_lookup(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double speed_lookup = 14;
      case 14: {
        if (static_cast<::google::protobuf::uint8>(tag) != 113) goto handle_unusual;
        msg->set_speed_lookup(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double calibration_value = 15;
      case 15: {
        if (static_cast<::google::protobuf::uint8>(tag) != 121) goto handle_unusual;
        msg->set_calibration_value(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double throttle_cmd = 16;
      case 16: {
        if (static_cast<::google::protobuf::uint8>(tag) != 129) goto handle_unusual;
        msg->set_throttle_cmd(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double brake_cmd = 17;
      case 17: {
        if (static_cast<::google::protobuf::uint8>(tag) != 137) goto handle_unusual;
        msg->set_brake_cmd(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional bool is_full_stop = 18;
      case 18: {
        if (static_cast<::google::protobuf::uint8>(tag) != 144) goto handle_unusual;
        msg->set_is_full_stop(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional double slope_offset_compensation = 19;
      case 19: {
        if (static_cast<::google::protobuf::uint8>(tag) != 153) goto handle_unusual;
        msg->set_slope_offset_compensation(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double current_station = 20;
      case 20: {
        if (static_cast<::google::protobuf::uint8>(tag) != 161) goto handle_unusual;
        msg->set_current_station(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double path_remain = 21;
      case 21: {
        if (static_cast<::google::protobuf::uint8>(tag) != 169) goto handle_unusual;
        msg->set_path_remain(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional int32 pid_saturation_status = 22;
      case 22: {
        if (static_cast<::google::protobuf::uint8>(tag) != 176) goto handle_unusual;
        msg->set_pid_saturation_status(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 leadlag_saturation_status = 23;
      case 23: {
        if (static_cast<::google::protobuf::uint8>(tag) != 184) goto handle_unusual;
        msg->set_leadlag_saturation_status(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional double speed_offset = 24;
      case 24: {
        if (static_cast<::google::protobuf::uint8>(tag) != 193) goto handle_unusual;
        msg->set_speed_offset(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double current_speed = 25;
      case 25: {
        if (static_cast<::google::protobuf::uint8>(tag) != 201) goto handle_unusual;
        msg->set_current_speed(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double acceleration_reference = 26;
      case 26: {
        if (static_cast<::google::protobuf::uint8>(tag) != 209) goto handle_unusual;
        msg->set_acceleration_reference(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double current_acceleration = 27;
      case 27: {
        if (static_cast<::google::protobuf::uint8>(tag) != 217) goto handle_unusual;
        msg->set_current_acceleration(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double acceleration_error = 28;
      case 28: {
        if (static_cast<::google::protobuf::uint8>(tag) != 225) goto handle_unusual;
        msg->set_acceleration_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double jerk_reference = 29;
      case 29: {
        if (static_cast<::google::protobuf::uint8>(tag) != 233) goto handle_unusual;
        msg->set_jerk_reference(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double current_jerk = 30;
      case 30: {
        if (static_cast<::google::protobuf::uint8>(tag) != 241) goto handle_unusual;
        msg->set_current_jerk(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double jerk_error = 31;
      case 31: {
        if (static_cast<::google::protobuf::uint8>(tag) != 249) goto handle_unusual;
        msg->set_jerk_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional .points.TrajectoryPoint current_matched_point = 32;
      case 32: {
        if (static_cast<::google::protobuf::uint8>(tag) != 2) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::points::TrajectoryPoint::_InternalParse;
        object = msg->mutable_current_matched_point();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .points.TrajectoryPoint current_reference_point = 33;
      case 33: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::points::TrajectoryPoint::_InternalParse;
        object = msg->mutable_current_reference_point();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .points.TrajectoryPoint preview_reference_point = 34;
      case 34: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::points::TrajectoryPoint::_InternalParse;
        object = msg->mutable_preview_reference_point();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SimpleLongitudinalDebug::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:controller.SimpleLongitudinalDebug)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double station_reference = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_station_reference(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &station_reference_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double station_error = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_station_error(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &station_error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double station_error_limited = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_station_error_limited(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &station_error_limited_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double preview_station_error = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {
          HasBitSetters::set_has_preview_station_error(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &preview_station_error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double speed_reference = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (41 & 0xFF)) {
          HasBitSetters::set_has_speed_reference(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &speed_reference_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double speed_error = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (49 & 0xFF)) {
          HasBitSetters::set_has_speed_error(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &speed_error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double speed_controller_input_limited = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (57 & 0xFF)) {
          HasBitSetters::set_has_speed_controller_input_limited(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &speed_controller_input_limited_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double preview_speed_reference = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (65 & 0xFF)) {
          HasBitSetters::set_has_preview_speed_reference(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &preview_speed_reference_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double preview_speed_error = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (73 & 0xFF)) {
          HasBitSetters::set_has_preview_speed_error(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &preview_speed_error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double preview_acceleration_reference = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (81 & 0xFF)) {
          HasBitSetters::set_has_preview_acceleration_reference(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &preview_acceleration_reference_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double acceleration_cmd_closeloop = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (89 & 0xFF)) {
          HasBitSetters::set_has_acceleration_cmd_closeloop(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &acceleration_cmd_closeloop_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double acceleration_cmd = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (97 & 0xFF)) {
          HasBitSetters::set_has_acceleration_cmd(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &acceleration_cmd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double acceleration_lookup = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (105 & 0xFF)) {
          HasBitSetters::set_has_acceleration_lookup(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &acceleration_lookup_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double speed_lookup = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (113 & 0xFF)) {
          HasBitSetters::set_has_speed_lookup(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &speed_lookup_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double calibration_value = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (121 & 0xFF)) {
          HasBitSetters::set_has_calibration_value(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &calibration_value_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double throttle_cmd = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (129 & 0xFF)) {
          HasBitSetters::set_has_throttle_cmd(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &throttle_cmd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double brake_cmd = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (137 & 0xFF)) {
          HasBitSetters::set_has_brake_cmd(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &brake_cmd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_full_stop = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (144 & 0xFF)) {
          HasBitSetters::set_has_is_full_stop(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_full_stop_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double slope_offset_compensation = 19;
      case 19: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (153 & 0xFF)) {
          HasBitSetters::set_has_slope_offset_compensation(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &slope_offset_compensation_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double current_station = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (161 & 0xFF)) {
          HasBitSetters::set_has_current_station(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &current_station_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double path_remain = 21;
      case 21: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (169 & 0xFF)) {
          HasBitSetters::set_has_path_remain(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &path_remain_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 pid_saturation_status = 22;
      case 22: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (176 & 0xFF)) {
          HasBitSetters::set_has_pid_saturation_status(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pid_saturation_status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 leadlag_saturation_status = 23;
      case 23: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (184 & 0xFF)) {
          HasBitSetters::set_has_leadlag_saturation_status(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &leadlag_saturation_status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double speed_offset = 24;
      case 24: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (193 & 0xFF)) {
          HasBitSetters::set_has_speed_offset(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &speed_offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double current_speed = 25;
      case 25: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (201 & 0xFF)) {
          HasBitSetters::set_has_current_speed(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &current_speed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double acceleration_reference = 26;
      case 26: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (209 & 0xFF)) {
          HasBitSetters::set_has_acceleration_reference(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &acceleration_reference_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double current_acceleration = 27;
      case 27: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (217 & 0xFF)) {
          HasBitSetters::set_has_current_acceleration(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &current_acceleration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double acceleration_error = 28;
      case 28: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (225 & 0xFF)) {
          HasBitSetters::set_has_acceleration_error(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &acceleration_error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double jerk_reference = 29;
      case 29: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (233 & 0xFF)) {
          HasBitSetters::set_has_jerk_reference(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &jerk_reference_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double current_jerk = 30;
      case 30: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (241 & 0xFF)) {
          HasBitSetters::set_has_current_jerk(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &current_jerk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double jerk_error = 31;
      case 31: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (249 & 0xFF)) {
          HasBitSetters::set_has_jerk_error(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &jerk_error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .points.TrajectoryPoint current_matched_point = 32;
      case 32: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (258 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_current_matched_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .points.TrajectoryPoint current_reference_point = 33;
      case 33: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (266 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_current_reference_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .points.TrajectoryPoint preview_reference_point = 34;
      case 34: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (274 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_preview_reference_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:controller.SimpleLongitudinalDebug)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:controller.SimpleLongitudinalDebug)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SimpleLongitudinalDebug::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:controller.SimpleLongitudinalDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double station_reference = 1;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->station_reference(), output);
  }

  // optional double station_error = 2;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->station_error(), output);
  }

  // optional double station_error_limited = 3;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->station_error_limited(), output);
  }

  // optional double preview_station_error = 4;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->preview_station_error(), output);
  }

  // optional double speed_reference = 5;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->speed_reference(), output);
  }

  // optional double speed_error = 6;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->speed_error(), output);
  }

  // optional double speed_controller_input_limited = 7;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->speed_controller_input_limited(), output);
  }

  // optional double preview_speed_reference = 8;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->preview_speed_reference(), output);
  }

  // optional double preview_speed_error = 9;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->preview_speed_error(), output);
  }

  // optional double preview_acceleration_reference = 10;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(10, this->preview_acceleration_reference(), output);
  }

  // optional double acceleration_cmd_closeloop = 11;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(11, this->acceleration_cmd_closeloop(), output);
  }

  // optional double acceleration_cmd = 12;
  if (cached_has_bits & 0x00004000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(12, this->acceleration_cmd(), output);
  }

  // optional double acceleration_lookup = 13;
  if (cached_has_bits & 0x00008000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(13, this->acceleration_lookup(), output);
  }

  // optional double speed_lookup = 14;
  if (cached_has_bits & 0x00010000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(14, this->speed_lookup(), output);
  }

  // optional double calibration_value = 15;
  if (cached_has_bits & 0x00020000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(15, this->calibration_value(), output);
  }

  // optional double throttle_cmd = 16;
  if (cached_has_bits & 0x00040000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(16, this->throttle_cmd(), output);
  }

  // optional double brake_cmd = 17;
  if (cached_has_bits & 0x00080000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(17, this->brake_cmd(), output);
  }

  // optional bool is_full_stop = 18;
  if (cached_has_bits & 0x00400000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(18, this->is_full_stop(), output);
  }

  // optional double slope_offset_compensation = 19;
  if (cached_has_bits & 0x00100000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(19, this->slope_offset_compensation(), output);
  }

  // optional double current_station = 20;
  if (cached_has_bits & 0x00200000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(20, this->current_station(), output);
  }

  // optional double path_remain = 21;
  if (cached_has_bits & 0x01000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(21, this->path_remain(), output);
  }

  // optional int32 pid_saturation_status = 22;
  if (cached_has_bits & 0x00800000u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(22, this->pid_saturation_status(), output);
  }

  cached_has_bits = _has_bits_[1];
  // optional int32 leadlag_saturation_status = 23;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(23, this->leadlag_saturation_status(), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional double speed_offset = 24;
  if (cached_has_bits & 0x02000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(24, this->speed_offset(), output);
  }

  // optional double current_speed = 25;
  if (cached_has_bits & 0x04000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(25, this->current_speed(), output);
  }

  // optional double acceleration_reference = 26;
  if (cached_has_bits & 0x08000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(26, this->acceleration_reference(), output);
  }

  // optional double current_acceleration = 27;
  if (cached_has_bits & 0x10000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(27, this->current_acceleration(), output);
  }

  // optional double acceleration_error = 28;
  if (cached_has_bits & 0x20000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(28, this->acceleration_error(), output);
  }

  // optional double jerk_reference = 29;
  if (cached_has_bits & 0x40000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(29, this->jerk_reference(), output);
  }

  // optional double current_jerk = 30;
  if (cached_has_bits & 0x80000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(30, this->current_jerk(), output);
  }

  cached_has_bits = _has_bits_[1];
  // optional double jerk_error = 31;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(31, this->jerk_error(), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional .points.TrajectoryPoint current_matched_point = 32;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      32, HasBitSetters::current_matched_point(this), output);
  }

  // optional .points.TrajectoryPoint current_reference_point = 33;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      33, HasBitSetters::current_reference_point(this), output);
  }

  // optional .points.TrajectoryPoint preview_reference_point = 34;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      34, HasBitSetters::preview_reference_point(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:controller.SimpleLongitudinalDebug)
}

::google::protobuf::uint8* SimpleLongitudinalDebug::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:controller.SimpleLongitudinalDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double station_reference = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->station_reference(), target);
  }

  // optional double station_error = 2;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->station_error(), target);
  }

  // optional double station_error_limited = 3;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->station_error_limited(), target);
  }

  // optional double preview_station_error = 4;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->preview_station_error(), target);
  }

  // optional double speed_reference = 5;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->speed_reference(), target);
  }

  // optional double speed_error = 6;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->speed_error(), target);
  }

  // optional double speed_controller_input_limited = 7;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->speed_controller_input_limited(), target);
  }

  // optional double preview_speed_reference = 8;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->preview_speed_reference(), target);
  }

  // optional double preview_speed_error = 9;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->preview_speed_error(), target);
  }

  // optional double preview_acceleration_reference = 10;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(10, this->preview_acceleration_reference(), target);
  }

  // optional double acceleration_cmd_closeloop = 11;
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(11, this->acceleration_cmd_closeloop(), target);
  }

  // optional double acceleration_cmd = 12;
  if (cached_has_bits & 0x00004000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(12, this->acceleration_cmd(), target);
  }

  // optional double acceleration_lookup = 13;
  if (cached_has_bits & 0x00008000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(13, this->acceleration_lookup(), target);
  }

  // optional double speed_lookup = 14;
  if (cached_has_bits & 0x00010000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(14, this->speed_lookup(), target);
  }

  // optional double calibration_value = 15;
  if (cached_has_bits & 0x00020000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(15, this->calibration_value(), target);
  }

  // optional double throttle_cmd = 16;
  if (cached_has_bits & 0x00040000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(16, this->throttle_cmd(), target);
  }

  // optional double brake_cmd = 17;
  if (cached_has_bits & 0x00080000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(17, this->brake_cmd(), target);
  }

  // optional bool is_full_stop = 18;
  if (cached_has_bits & 0x00400000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(18, this->is_full_stop(), target);
  }

  // optional double slope_offset_compensation = 19;
  if (cached_has_bits & 0x00100000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(19, this->slope_offset_compensation(), target);
  }

  // optional double current_station = 20;
  if (cached_has_bits & 0x00200000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(20, this->current_station(), target);
  }

  // optional double path_remain = 21;
  if (cached_has_bits & 0x01000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(21, this->path_remain(), target);
  }

  // optional int32 pid_saturation_status = 22;
  if (cached_has_bits & 0x00800000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(22, this->pid_saturation_status(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional int32 leadlag_saturation_status = 23;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(23, this->leadlag_saturation_status(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional double speed_offset = 24;
  if (cached_has_bits & 0x02000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(24, this->speed_offset(), target);
  }

  // optional double current_speed = 25;
  if (cached_has_bits & 0x04000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(25, this->current_speed(), target);
  }

  // optional double acceleration_reference = 26;
  if (cached_has_bits & 0x08000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(26, this->acceleration_reference(), target);
  }

  // optional double current_acceleration = 27;
  if (cached_has_bits & 0x10000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(27, this->current_acceleration(), target);
  }

  // optional double acceleration_error = 28;
  if (cached_has_bits & 0x20000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(28, this->acceleration_error(), target);
  }

  // optional double jerk_reference = 29;
  if (cached_has_bits & 0x40000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(29, this->jerk_reference(), target);
  }

  // optional double current_jerk = 30;
  if (cached_has_bits & 0x80000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(30, this->current_jerk(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional double jerk_error = 31;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(31, this->jerk_error(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .points.TrajectoryPoint current_matched_point = 32;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        32, HasBitSetters::current_matched_point(this), target);
  }

  // optional .points.TrajectoryPoint current_reference_point = 33;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        33, HasBitSetters::current_reference_point(this), target);
  }

  // optional .points.TrajectoryPoint preview_reference_point = 34;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        34, HasBitSetters::preview_reference_point(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:controller.SimpleLongitudinalDebug)
  return target;
}

size_t SimpleLongitudinalDebug::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:controller.SimpleLongitudinalDebug)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .points.TrajectoryPoint current_matched_point = 32;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *current_matched_point_);
    }

    // optional .points.TrajectoryPoint current_reference_point = 33;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *current_reference_point_);
    }

    // optional .points.TrajectoryPoint preview_reference_point = 34;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *preview_reference_point_);
    }

    // optional double station_reference = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double station_error = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double station_error_limited = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double preview_station_error = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double speed_reference = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double speed_error = 6;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double speed_controller_input_limited = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional double preview_speed_reference = 8;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

    // optional double preview_speed_error = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

    // optional double preview_acceleration_reference = 10;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 8;
    }

    // optional double acceleration_cmd_closeloop = 11;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 8;
    }

    // optional double acceleration_cmd = 12;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 8;
    }

    // optional double acceleration_lookup = 13;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional double speed_lookup = 14;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 8;
    }

    // optional double calibration_value = 15;
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 8;
    }

    // optional double throttle_cmd = 16;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 8;
    }

    // optional double brake_cmd = 17;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 8;
    }

    // optional double slope_offset_compensation = 19;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 8;
    }

    // optional double current_station = 20;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 8;
    }

    // optional bool is_full_stop = 18;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional int32 pid_saturation_status = 22;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pid_saturation_status());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional double path_remain = 21;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 8;
    }

    // optional double speed_offset = 24;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 8;
    }

    // optional double current_speed = 25;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 8;
    }

    // optional double acceleration_reference = 26;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 8;
    }

    // optional double current_acceleration = 27;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 8;
    }

    // optional double acceleration_error = 28;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 8;
    }

    // optional double jerk_reference = 29;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 8;
    }

    // optional double current_jerk = 30;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 8;
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x00000003u) {
    // optional double jerk_error = 31;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 8;
    }

    // optional int32 leadlag_saturation_status = 23;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->leadlag_saturation_status());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SimpleLongitudinalDebug::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:controller.SimpleLongitudinalDebug)
  GOOGLE_DCHECK_NE(&from, this);
  const SimpleLongitudinalDebug* source =
      ::google::protobuf::DynamicCastToGenerated<SimpleLongitudinalDebug>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:controller.SimpleLongitudinalDebug)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:controller.SimpleLongitudinalDebug)
    MergeFrom(*source);
  }
}

void SimpleLongitudinalDebug::MergeFrom(const SimpleLongitudinalDebug& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:controller.SimpleLongitudinalDebug)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_current_matched_point()->::points::TrajectoryPoint::MergeFrom(from.current_matched_point());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_current_reference_point()->::points::TrajectoryPoint::MergeFrom(from.current_reference_point());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_preview_reference_point()->::points::TrajectoryPoint::MergeFrom(from.preview_reference_point());
    }
    if (cached_has_bits & 0x00000008u) {
      station_reference_ = from.station_reference_;
    }
    if (cached_has_bits & 0x00000010u) {
      station_error_ = from.station_error_;
    }
    if (cached_has_bits & 0x00000020u) {
      station_error_limited_ = from.station_error_limited_;
    }
    if (cached_has_bits & 0x00000040u) {
      preview_station_error_ = from.preview_station_error_;
    }
    if (cached_has_bits & 0x00000080u) {
      speed_reference_ = from.speed_reference_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      speed_error_ = from.speed_error_;
    }
    if (cached_has_bits & 0x00000200u) {
      speed_controller_input_limited_ = from.speed_controller_input_limited_;
    }
    if (cached_has_bits & 0x00000400u) {
      preview_speed_reference_ = from.preview_speed_reference_;
    }
    if (cached_has_bits & 0x00000800u) {
      preview_speed_error_ = from.preview_speed_error_;
    }
    if (cached_has_bits & 0x00001000u) {
      preview_acceleration_reference_ = from.preview_acceleration_reference_;
    }
    if (cached_has_bits & 0x00002000u) {
      acceleration_cmd_closeloop_ = from.acceleration_cmd_closeloop_;
    }
    if (cached_has_bits & 0x00004000u) {
      acceleration_cmd_ = from.acceleration_cmd_;
    }
    if (cached_has_bits & 0x00008000u) {
      acceleration_lookup_ = from.acceleration_lookup_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      speed_lookup_ = from.speed_lookup_;
    }
    if (cached_has_bits & 0x00020000u) {
      calibration_value_ = from.calibration_value_;
    }
    if (cached_has_bits & 0x00040000u) {
      throttle_cmd_ = from.throttle_cmd_;
    }
    if (cached_has_bits & 0x00080000u) {
      brake_cmd_ = from.brake_cmd_;
    }
    if (cached_has_bits & 0x00100000u) {
      slope_offset_compensation_ = from.slope_offset_compensation_;
    }
    if (cached_has_bits & 0x00200000u) {
      current_station_ = from.current_station_;
    }
    if (cached_has_bits & 0x00400000u) {
      is_full_stop_ = from.is_full_stop_;
    }
    if (cached_has_bits & 0x00800000u) {
      pid_saturation_status_ = from.pid_saturation_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      path_remain_ = from.path_remain_;
    }
    if (cached_has_bits & 0x02000000u) {
      speed_offset_ = from.speed_offset_;
    }
    if (cached_has_bits & 0x04000000u) {
      current_speed_ = from.current_speed_;
    }
    if (cached_has_bits & 0x08000000u) {
      acceleration_reference_ = from.acceleration_reference_;
    }
    if (cached_has_bits & 0x10000000u) {
      current_acceleration_ = from.current_acceleration_;
    }
    if (cached_has_bits & 0x20000000u) {
      acceleration_error_ = from.acceleration_error_;
    }
    if (cached_has_bits & 0x40000000u) {
      jerk_reference_ = from.jerk_reference_;
    }
    if (cached_has_bits & 0x80000000u) {
      current_jerk_ = from.current_jerk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      jerk_error_ = from.jerk_error_;
    }
    if (cached_has_bits & 0x00000002u) {
      leadlag_saturation_status_ = from.leadlag_saturation_status_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
}

void SimpleLongitudinalDebug::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:controller.SimpleLongitudinalDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SimpleLongitudinalDebug::CopyFrom(const SimpleLongitudinalDebug& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:controller.SimpleLongitudinalDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimpleLongitudinalDebug::IsInitialized() const {
  return true;
}

void SimpleLongitudinalDebug::Swap(SimpleLongitudinalDebug* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SimpleLongitudinalDebug::InternalSwap(SimpleLongitudinalDebug* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  swap(current_matched_point_, other->current_matched_point_);
  swap(current_reference_point_, other->current_reference_point_);
  swap(preview_reference_point_, other->preview_reference_point_);
  swap(station_reference_, other->station_reference_);
  swap(station_error_, other->station_error_);
  swap(station_error_limited_, other->station_error_limited_);
  swap(preview_station_error_, other->preview_station_error_);
  swap(speed_reference_, other->speed_reference_);
  swap(speed_error_, other->speed_error_);
  swap(speed_controller_input_limited_, other->speed_controller_input_limited_);
  swap(preview_speed_reference_, other->preview_speed_reference_);
  swap(preview_speed_error_, other->preview_speed_error_);
  swap(preview_acceleration_reference_, other->preview_acceleration_reference_);
  swap(acceleration_cmd_closeloop_, other->acceleration_cmd_closeloop_);
  swap(acceleration_cmd_, other->acceleration_cmd_);
  swap(acceleration_lookup_, other->acceleration_lookup_);
  swap(speed_lookup_, other->speed_lookup_);
  swap(calibration_value_, other->calibration_value_);
  swap(throttle_cmd_, other->throttle_cmd_);
  swap(brake_cmd_, other->brake_cmd_);
  swap(slope_offset_compensation_, other->slope_offset_compensation_);
  swap(current_station_, other->current_station_);
  swap(is_full_stop_, other->is_full_stop_);
  swap(pid_saturation_status_, other->pid_saturation_status_);
  swap(path_remain_, other->path_remain_);
  swap(speed_offset_, other->speed_offset_);
  swap(current_speed_, other->current_speed_);
  swap(acceleration_reference_, other->acceleration_reference_);
  swap(current_acceleration_, other->current_acceleration_);
  swap(acceleration_error_, other->acceleration_error_);
  swap(jerk_reference_, other->jerk_reference_);
  swap(current_jerk_, other->current_jerk_);
  swap(jerk_error_, other->jerk_error_);
  swap(leadlag_saturation_status_, other->leadlag_saturation_status_);
}

::google::protobuf::Metadata SimpleLongitudinalDebug::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_control_5fcmd_2eproto);
  return ::file_level_metadata_control_5fcmd_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SimpleLateralDebug::InitAsDefaultInstance() {
  ::controller::_SimpleLateralDebug_default_instance_._instance.get_mutable()->current_target_point_ = const_cast< ::points::TrajectoryPoint*>(
      ::points::TrajectoryPoint::internal_default_instance());
  ::controller::_SimpleLateralDebug_default_instance_._instance.get_mutable()->steer_mrac_debug_ = const_cast< ::controller::MracDebug*>(
      ::controller::MracDebug::internal_default_instance());
}
class SimpleLateralDebug::HasBitSetters {
 public:
  static void set_has_lateral_error(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_ref_heading(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_heading(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_heading_error(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_heading_error_rate(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_lateral_error_rate(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_curvature(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_steer_angle(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
  static void set_has_steer_angle_feedforward(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static void set_has_steer_angle_lateral_contribution(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00000800u;
  }
  static void set_has_steer_angle_lateral_rate_contribution(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00001000u;
  }
  static void set_has_steer_angle_heading_contribution(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00002000u;
  }
  static void set_has_steer_angle_heading_rate_contribution(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00004000u;
  }
  static void set_has_steer_angle_feedback(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00008000u;
  }
  static void set_has_steering_position(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00010000u;
  }
  static void set_has_ref_speed(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00020000u;
  }
  static void set_has_steer_angle_limited(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00040000u;
  }
  static void set_has_lateral_acceleration(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00080000u;
  }
  static void set_has_lateral_jerk(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00100000u;
  }
  static void set_has_ref_heading_rate(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00200000u;
  }
  static void set_has_heading_rate(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00400000u;
  }
  static void set_has_ref_heading_acceleration(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00800000u;
  }
  static void set_has_heading_acceleration(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x01000000u;
  }
  static void set_has_heading_error_acceleration(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x02000000u;
  }
  static void set_has_ref_heading_jerk(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x04000000u;
  }
  static void set_has_heading_jerk(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x08000000u;
  }
  static void set_has_heading_error_jerk(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x10000000u;
  }
  static void set_has_lateral_error_feedback(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x20000000u;
  }
  static void set_has_heading_error_feedback(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x40000000u;
  }
  static const ::points::TrajectoryPoint& current_target_point(const SimpleLateralDebug* msg);
  static void set_has_current_target_point(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_steer_angle_feedback_augment(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x80000000u;
  }
  static const ::controller::MracDebug& steer_mrac_debug(const SimpleLateralDebug* msg);
  static void set_has_steer_mrac_debug(SimpleLateralDebug* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_steer_mrac_enable_status(SimpleLateralDebug* msg) {
    msg->_has_bits_[1] |= 0x00000001u;
  }
};

const ::points::TrajectoryPoint&
SimpleLateralDebug::HasBitSetters::current_target_point(const SimpleLateralDebug* msg) {
  return *msg->current_target_point_;
}
const ::controller::MracDebug&
SimpleLateralDebug::HasBitSetters::steer_mrac_debug(const SimpleLateralDebug* msg) {
  return *msg->steer_mrac_debug_;
}
void SimpleLateralDebug::clear_current_target_point() {
  if (current_target_point_ != nullptr) current_target_point_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SimpleLateralDebug::kLateralErrorFieldNumber;
const int SimpleLateralDebug::kRefHeadingFieldNumber;
const int SimpleLateralDebug::kHeadingFieldNumber;
const int SimpleLateralDebug::kHeadingErrorFieldNumber;
const int SimpleLateralDebug::kHeadingErrorRateFieldNumber;
const int SimpleLateralDebug::kLateralErrorRateFieldNumber;
const int SimpleLateralDebug::kCurvatureFieldNumber;
const int SimpleLateralDebug::kSteerAngleFieldNumber;
const int SimpleLateralDebug::kSteerAngleFeedforwardFieldNumber;
const int SimpleLateralDebug::kSteerAngleLateralContributionFieldNumber;
const int SimpleLateralDebug::kSteerAngleLateralRateContributionFieldNumber;
const int SimpleLateralDebug::kSteerAngleHeadingContributionFieldNumber;
const int SimpleLateralDebug::kSteerAngleHeadingRateContributionFieldNumber;
const int SimpleLateralDebug::kSteerAngleFeedbackFieldNumber;
const int SimpleLateralDebug::kSteeringPositionFieldNumber;
const int SimpleLateralDebug::kRefSpeedFieldNumber;
const int SimpleLateralDebug::kSteerAngleLimitedFieldNumber;
const int SimpleLateralDebug::kLateralAccelerationFieldNumber;
const int SimpleLateralDebug::kLateralJerkFieldNumber;
const int SimpleLateralDebug::kRefHeadingRateFieldNumber;
const int SimpleLateralDebug::kHeadingRateFieldNumber;
const int SimpleLateralDebug::kRefHeadingAccelerationFieldNumber;
const int SimpleLateralDebug::kHeadingAccelerationFieldNumber;
const int SimpleLateralDebug::kHeadingErrorAccelerationFieldNumber;
const int SimpleLateralDebug::kRefHeadingJerkFieldNumber;
const int SimpleLateralDebug::kHeadingJerkFieldNumber;
const int SimpleLateralDebug::kHeadingErrorJerkFieldNumber;
const int SimpleLateralDebug::kLateralErrorFeedbackFieldNumber;
const int SimpleLateralDebug::kHeadingErrorFeedbackFieldNumber;
const int SimpleLateralDebug::kCurrentTargetPointFieldNumber;
const int SimpleLateralDebug::kSteerAngleFeedbackAugmentFieldNumber;
const int SimpleLateralDebug::kSteerMracDebugFieldNumber;
const int SimpleLateralDebug::kSteerMracEnableStatusFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SimpleLateralDebug::SimpleLateralDebug()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:controller.SimpleLateralDebug)
}
SimpleLateralDebug::SimpleLateralDebug(const SimpleLateralDebug& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_current_target_point()) {
    current_target_point_ = new ::points::TrajectoryPoint(*from.current_target_point_);
  } else {
    current_target_point_ = nullptr;
  }
  if (from.has_steer_mrac_debug()) {
    steer_mrac_debug_ = new ::controller::MracDebug(*from.steer_mrac_debug_);
  } else {
    steer_mrac_debug_ = nullptr;
  }
  ::memcpy(&lateral_error_, &from.lateral_error_,
    static_cast<size_t>(reinterpret_cast<char*>(&steer_mrac_enable_status_) -
    reinterpret_cast<char*>(&lateral_error_)) + sizeof(steer_mrac_enable_status_));
  // @@protoc_insertion_point(copy_constructor:controller.SimpleLateralDebug)
}

void SimpleLateralDebug::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_SimpleLateralDebug_control_5fcmd_2eproto.base);
  ::memset(&current_target_point_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&steer_mrac_enable_status_) -
      reinterpret_cast<char*>(&current_target_point_)) + sizeof(steer_mrac_enable_status_));
}

SimpleLateralDebug::~SimpleLateralDebug() {
  // @@protoc_insertion_point(destructor:controller.SimpleLateralDebug)
  SharedDtor();
}

void SimpleLateralDebug::SharedDtor() {
  if (this != internal_default_instance()) delete current_target_point_;
  if (this != internal_default_instance()) delete steer_mrac_debug_;
}

void SimpleLateralDebug::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SimpleLateralDebug& SimpleLateralDebug::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SimpleLateralDebug_control_5fcmd_2eproto.base);
  return *internal_default_instance();
}


void SimpleLateralDebug::Clear() {
// @@protoc_insertion_point(message_clear_start:controller.SimpleLateralDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(current_target_point_ != nullptr);
      current_target_point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(steer_mrac_debug_ != nullptr);
      steer_mrac_debug_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&lateral_error_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lateral_error_rate_) -
        reinterpret_cast<char*>(&lateral_error_)) + sizeof(lateral_error_rate_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&curvature_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&steer_angle_feedback_) -
        reinterpret_cast<char*>(&curvature_)) + sizeof(steer_angle_feedback_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&steering_position_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ref_heading_acceleration_) -
        reinterpret_cast<char*>(&steering_position_)) + sizeof(ref_heading_acceleration_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&heading_acceleration_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&steer_angle_feedback_augment_) -
        reinterpret_cast<char*>(&heading_acceleration_)) + sizeof(steer_angle_feedback_augment_));
  }
  steer_mrac_enable_status_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SimpleLateralDebug::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SimpleLateralDebug*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional double lateral_error = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_lateral_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double ref_heading = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_ref_heading(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_heading(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading_error = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_heading_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading_error_rate = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 41) goto handle_unusual;
        msg->set_heading_error_rate(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double lateral_error_rate = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 49) goto handle_unusual;
        msg->set_lateral_error_rate(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double curvature = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 57) goto handle_unusual;
        msg->set_curvature(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 65) goto handle_unusual;
        msg->set_steer_angle(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle_feedforward = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 73) goto handle_unusual;
        msg->set_steer_angle_feedforward(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle_lateral_contribution = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 81) goto handle_unusual;
        msg->set_steer_angle_lateral_contribution(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle_lateral_rate_contribution = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 89) goto handle_unusual;
        msg->set_steer_angle_lateral_rate_contribution(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle_heading_contribution = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 97) goto handle_unusual;
        msg->set_steer_angle_heading_contribution(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle_heading_rate_contribution = 13;
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 105) goto handle_unusual;
        msg->set_steer_angle_heading_rate_contribution(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle_feedback = 14;
      case 14: {
        if (static_cast<::google::protobuf::uint8>(tag) != 113) goto handle_unusual;
        msg->set_steer_angle_feedback(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steering_position = 15;
      case 15: {
        if (static_cast<::google::protobuf::uint8>(tag) != 121) goto handle_unusual;
        msg->set_steering_position(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double ref_speed = 16;
      case 16: {
        if (static_cast<::google::protobuf::uint8>(tag) != 129) goto handle_unusual;
        msg->set_ref_speed(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle_limited = 17;
      case 17: {
        if (static_cast<::google::protobuf::uint8>(tag) != 137) goto handle_unusual;
        msg->set_steer_angle_limited(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double lateral_acceleration = 18;
      case 18: {
        if (static_cast<::google::protobuf::uint8>(tag) != 145) goto handle_unusual;
        msg->set_lateral_acceleration(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double lateral_jerk = 19;
      case 19: {
        if (static_cast<::google::protobuf::uint8>(tag) != 153) goto handle_unusual;
        msg->set_lateral_jerk(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double ref_heading_rate = 20;
      case 20: {
        if (static_cast<::google::protobuf::uint8>(tag) != 161) goto handle_unusual;
        msg->set_ref_heading_rate(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading_rate = 21;
      case 21: {
        if (static_cast<::google::protobuf::uint8>(tag) != 169) goto handle_unusual;
        msg->set_heading_rate(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double ref_heading_acceleration = 22;
      case 22: {
        if (static_cast<::google::protobuf::uint8>(tag) != 177) goto handle_unusual;
        msg->set_ref_heading_acceleration(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading_acceleration = 23;
      case 23: {
        if (static_cast<::google::protobuf::uint8>(tag) != 185) goto handle_unusual;
        msg->set_heading_acceleration(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading_error_acceleration = 24;
      case 24: {
        if (static_cast<::google::protobuf::uint8>(tag) != 193) goto handle_unusual;
        msg->set_heading_error_acceleration(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double ref_heading_jerk = 25;
      case 25: {
        if (static_cast<::google::protobuf::uint8>(tag) != 201) goto handle_unusual;
        msg->set_ref_heading_jerk(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading_jerk = 26;
      case 26: {
        if (static_cast<::google::protobuf::uint8>(tag) != 209) goto handle_unusual;
        msg->set_heading_jerk(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading_error_jerk = 27;
      case 27: {
        if (static_cast<::google::protobuf::uint8>(tag) != 217) goto handle_unusual;
        msg->set_heading_error_jerk(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double lateral_error_feedback = 28;
      case 28: {
        if (static_cast<::google::protobuf::uint8>(tag) != 225) goto handle_unusual;
        msg->set_lateral_error_feedback(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading_error_feedback = 29;
      case 29: {
        if (static_cast<::google::protobuf::uint8>(tag) != 233) goto handle_unusual;
        msg->set_heading_error_feedback(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional .points.TrajectoryPoint current_target_point = 30;
      case 30: {
        if (static_cast<::google::protobuf::uint8>(tag) != 242) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::points::TrajectoryPoint::_InternalParse;
        object = msg->mutable_current_target_point();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional double steer_angle_feedback_augment = 31;
      case 31: {
        if (static_cast<::google::protobuf::uint8>(tag) != 249) goto handle_unusual;
        msg->set_steer_angle_feedback_augment(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional .controller.MracDebug steer_mrac_debug = 32;
      case 32: {
        if (static_cast<::google::protobuf::uint8>(tag) != 2) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::controller::MracDebug::_InternalParse;
        object = msg->mutable_steer_mrac_debug();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional bool steer_mrac_enable_status = 33;
      case 33: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_steer_mrac_enable_status(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SimpleLateralDebug::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:controller.SimpleLateralDebug)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double lateral_error = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_lateral_error(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lateral_error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double ref_heading = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_ref_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ref_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_error = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {
          HasBitSetters::set_has_heading_error(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_error_rate = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (41 & 0xFF)) {
          HasBitSetters::set_has_heading_error_rate(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_error_rate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double lateral_error_rate = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (49 & 0xFF)) {
          HasBitSetters::set_has_lateral_error_rate(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lateral_error_rate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double curvature = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (57 & 0xFF)) {
          HasBitSetters::set_has_curvature(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &curvature_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (65 & 0xFF)) {
          HasBitSetters::set_has_steer_angle(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_feedforward = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (73 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_feedforward(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_feedforward_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_lateral_contribution = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (81 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_lateral_contribution(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_lateral_contribution_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_lateral_rate_contribution = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (89 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_lateral_rate_contribution(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_lateral_rate_contribution_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_heading_contribution = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (97 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_heading_contribution(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_heading_contribution_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_heading_rate_contribution = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (105 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_heading_rate_contribution(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_heading_rate_contribution_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_feedback = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (113 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_feedback(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_feedback_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steering_position = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (121 & 0xFF)) {
          HasBitSetters::set_has_steering_position(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steering_position_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double ref_speed = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (129 & 0xFF)) {
          HasBitSetters::set_has_ref_speed(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ref_speed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_limited = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (137 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_limited(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_limited_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double lateral_acceleration = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (145 & 0xFF)) {
          HasBitSetters::set_has_lateral_acceleration(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lateral_acceleration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double lateral_jerk = 19;
      case 19: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (153 & 0xFF)) {
          HasBitSetters::set_has_lateral_jerk(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lateral_jerk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double ref_heading_rate = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (161 & 0xFF)) {
          HasBitSetters::set_has_ref_heading_rate(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ref_heading_rate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_rate = 21;
      case 21: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (169 & 0xFF)) {
          HasBitSetters::set_has_heading_rate(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_rate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double ref_heading_acceleration = 22;
      case 22: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (177 & 0xFF)) {
          HasBitSetters::set_has_ref_heading_acceleration(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ref_heading_acceleration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_acceleration = 23;
      case 23: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (185 & 0xFF)) {
          HasBitSetters::set_has_heading_acceleration(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_acceleration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_error_acceleration = 24;
      case 24: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (193 & 0xFF)) {
          HasBitSetters::set_has_heading_error_acceleration(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_error_acceleration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double ref_heading_jerk = 25;
      case 25: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (201 & 0xFF)) {
          HasBitSetters::set_has_ref_heading_jerk(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ref_heading_jerk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_jerk = 26;
      case 26: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (209 & 0xFF)) {
          HasBitSetters::set_has_heading_jerk(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_jerk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_error_jerk = 27;
      case 27: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (217 & 0xFF)) {
          HasBitSetters::set_has_heading_error_jerk(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_error_jerk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double lateral_error_feedback = 28;
      case 28: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (225 & 0xFF)) {
          HasBitSetters::set_has_lateral_error_feedback(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lateral_error_feedback_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_error_feedback = 29;
      case 29: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (233 & 0xFF)) {
          HasBitSetters::set_has_heading_error_feedback(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_error_feedback_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .points.TrajectoryPoint current_target_point = 30;
      case 30: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (242 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_current_target_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_feedback_augment = 31;
      case 31: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (249 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_feedback_augment(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_feedback_augment_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .controller.MracDebug steer_mrac_debug = 32;
      case 32: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (258 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_steer_mrac_debug()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool steer_mrac_enable_status = 33;
      case 33: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (264 & 0xFF)) {
          HasBitSetters::set_has_steer_mrac_enable_status(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &steer_mrac_enable_status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:controller.SimpleLateralDebug)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:controller.SimpleLateralDebug)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SimpleLateralDebug::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:controller.SimpleLateralDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double lateral_error = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->lateral_error(), output);
  }

  // optional double ref_heading = 2;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->ref_heading(), output);
  }

  // optional double heading = 3;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->heading(), output);
  }

  // optional double heading_error = 4;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->heading_error(), output);
  }

  // optional double heading_error_rate = 5;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->heading_error_rate(), output);
  }

  // optional double lateral_error_rate = 6;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->lateral_error_rate(), output);
  }

  // optional double curvature = 7;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->curvature(), output);
  }

  // optional double steer_angle = 8;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->steer_angle(), output);
  }

  // optional double steer_angle_feedforward = 9;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->steer_angle_feedforward(), output);
  }

  // optional double steer_angle_lateral_contribution = 10;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(10, this->steer_angle_lateral_contribution(), output);
  }

  // optional double steer_angle_lateral_rate_contribution = 11;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(11, this->steer_angle_lateral_rate_contribution(), output);
  }

  // optional double steer_angle_heading_contribution = 12;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(12, this->steer_angle_heading_contribution(), output);
  }

  // optional double steer_angle_heading_rate_contribution = 13;
  if (cached_has_bits & 0x00004000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(13, this->steer_angle_heading_rate_contribution(), output);
  }

  // optional double steer_angle_feedback = 14;
  if (cached_has_bits & 0x00008000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(14, this->steer_angle_feedback(), output);
  }

  // optional double steering_position = 15;
  if (cached_has_bits & 0x00010000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(15, this->steering_position(), output);
  }

  // optional double ref_speed = 16;
  if (cached_has_bits & 0x00020000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(16, this->ref_speed(), output);
  }

  // optional double steer_angle_limited = 17;
  if (cached_has_bits & 0x00040000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(17, this->steer_angle_limited(), output);
  }

  // optional double lateral_acceleration = 18;
  if (cached_has_bits & 0x00080000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(18, this->lateral_acceleration(), output);
  }

  // optional double lateral_jerk = 19;
  if (cached_has_bits & 0x00100000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(19, this->lateral_jerk(), output);
  }

  // optional double ref_heading_rate = 20;
  if (cached_has_bits & 0x00200000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(20, this->ref_heading_rate(), output);
  }

  // optional double heading_rate = 21;
  if (cached_has_bits & 0x00400000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(21, this->heading_rate(), output);
  }

  // optional double ref_heading_acceleration = 22;
  if (cached_has_bits & 0x00800000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(22, this->ref_heading_acceleration(), output);
  }

  // optional double heading_acceleration = 23;
  if (cached_has_bits & 0x01000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(23, this->heading_acceleration(), output);
  }

  // optional double heading_error_acceleration = 24;
  if (cached_has_bits & 0x02000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(24, this->heading_error_acceleration(), output);
  }

  // optional double ref_heading_jerk = 25;
  if (cached_has_bits & 0x04000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(25, this->ref_heading_jerk(), output);
  }

  // optional double heading_jerk = 26;
  if (cached_has_bits & 0x08000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(26, this->heading_jerk(), output);
  }

  // optional double heading_error_jerk = 27;
  if (cached_has_bits & 0x10000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(27, this->heading_error_jerk(), output);
  }

  // optional double lateral_error_feedback = 28;
  if (cached_has_bits & 0x20000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(28, this->lateral_error_feedback(), output);
  }

  // optional double heading_error_feedback = 29;
  if (cached_has_bits & 0x40000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(29, this->heading_error_feedback(), output);
  }

  // optional .points.TrajectoryPoint current_target_point = 30;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      30, HasBitSetters::current_target_point(this), output);
  }

  // optional double steer_angle_feedback_augment = 31;
  if (cached_has_bits & 0x80000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(31, this->steer_angle_feedback_augment(), output);
  }

  // optional .controller.MracDebug steer_mrac_debug = 32;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      32, HasBitSetters::steer_mrac_debug(this), output);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool steer_mrac_enable_status = 33;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(33, this->steer_mrac_enable_status(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:controller.SimpleLateralDebug)
}

::google::protobuf::uint8* SimpleLateralDebug::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:controller.SimpleLateralDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double lateral_error = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->lateral_error(), target);
  }

  // optional double ref_heading = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->ref_heading(), target);
  }

  // optional double heading = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->heading(), target);
  }

  // optional double heading_error = 4;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->heading_error(), target);
  }

  // optional double heading_error_rate = 5;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->heading_error_rate(), target);
  }

  // optional double lateral_error_rate = 6;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->lateral_error_rate(), target);
  }

  // optional double curvature = 7;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->curvature(), target);
  }

  // optional double steer_angle = 8;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->steer_angle(), target);
  }

  // optional double steer_angle_feedforward = 9;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->steer_angle_feedforward(), target);
  }

  // optional double steer_angle_lateral_contribution = 10;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(10, this->steer_angle_lateral_contribution(), target);
  }

  // optional double steer_angle_lateral_rate_contribution = 11;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(11, this->steer_angle_lateral_rate_contribution(), target);
  }

  // optional double steer_angle_heading_contribution = 12;
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(12, this->steer_angle_heading_contribution(), target);
  }

  // optional double steer_angle_heading_rate_contribution = 13;
  if (cached_has_bits & 0x00004000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(13, this->steer_angle_heading_rate_contribution(), target);
  }

  // optional double steer_angle_feedback = 14;
  if (cached_has_bits & 0x00008000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(14, this->steer_angle_feedback(), target);
  }

  // optional double steering_position = 15;
  if (cached_has_bits & 0x00010000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(15, this->steering_position(), target);
  }

  // optional double ref_speed = 16;
  if (cached_has_bits & 0x00020000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(16, this->ref_speed(), target);
  }

  // optional double steer_angle_limited = 17;
  if (cached_has_bits & 0x00040000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(17, this->steer_angle_limited(), target);
  }

  // optional double lateral_acceleration = 18;
  if (cached_has_bits & 0x00080000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(18, this->lateral_acceleration(), target);
  }

  // optional double lateral_jerk = 19;
  if (cached_has_bits & 0x00100000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(19, this->lateral_jerk(), target);
  }

  // optional double ref_heading_rate = 20;
  if (cached_has_bits & 0x00200000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(20, this->ref_heading_rate(), target);
  }

  // optional double heading_rate = 21;
  if (cached_has_bits & 0x00400000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(21, this->heading_rate(), target);
  }

  // optional double ref_heading_acceleration = 22;
  if (cached_has_bits & 0x00800000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(22, this->ref_heading_acceleration(), target);
  }

  // optional double heading_acceleration = 23;
  if (cached_has_bits & 0x01000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(23, this->heading_acceleration(), target);
  }

  // optional double heading_error_acceleration = 24;
  if (cached_has_bits & 0x02000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(24, this->heading_error_acceleration(), target);
  }

  // optional double ref_heading_jerk = 25;
  if (cached_has_bits & 0x04000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(25, this->ref_heading_jerk(), target);
  }

  // optional double heading_jerk = 26;
  if (cached_has_bits & 0x08000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(26, this->heading_jerk(), target);
  }

  // optional double heading_error_jerk = 27;
  if (cached_has_bits & 0x10000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(27, this->heading_error_jerk(), target);
  }

  // optional double lateral_error_feedback = 28;
  if (cached_has_bits & 0x20000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(28, this->lateral_error_feedback(), target);
  }

  // optional double heading_error_feedback = 29;
  if (cached_has_bits & 0x40000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(29, this->heading_error_feedback(), target);
  }

  // optional .points.TrajectoryPoint current_target_point = 30;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        30, HasBitSetters::current_target_point(this), target);
  }

  // optional double steer_angle_feedback_augment = 31;
  if (cached_has_bits & 0x80000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(31, this->steer_angle_feedback_augment(), target);
  }

  // optional .controller.MracDebug steer_mrac_debug = 32;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        32, HasBitSetters::steer_mrac_debug(this), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool steer_mrac_enable_status = 33;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(33, this->steer_mrac_enable_status(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:controller.SimpleLateralDebug)
  return target;
}

size_t SimpleLateralDebug::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:controller.SimpleLateralDebug)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .points.TrajectoryPoint current_target_point = 30;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *current_target_point_);
    }

    // optional .controller.MracDebug steer_mrac_debug = 32;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *steer_mrac_debug_);
    }

    // optional double lateral_error = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double ref_heading = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double heading = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double heading_error = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double heading_error_rate = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double lateral_error_rate = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double curvature = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double steer_angle = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional double steer_angle_feedforward = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

    // optional double steer_angle_lateral_contribution = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

    // optional double steer_angle_lateral_rate_contribution = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 8;
    }

    // optional double steer_angle_heading_contribution = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 8;
    }

    // optional double steer_angle_heading_rate_contribution = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 8;
    }

    // optional double steer_angle_feedback = 14;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional double steering_position = 15;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 8;
    }

    // optional double ref_speed = 16;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 8;
    }

    // optional double steer_angle_limited = 17;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 8;
    }

    // optional double lateral_acceleration = 18;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 8;
    }

    // optional double lateral_jerk = 19;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 8;
    }

    // optional double ref_heading_rate = 20;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 8;
    }

    // optional double heading_rate = 21;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 8;
    }

    // optional double ref_heading_acceleration = 22;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 8;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional double heading_acceleration = 23;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 8;
    }

    // optional double heading_error_acceleration = 24;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 8;
    }

    // optional double ref_heading_jerk = 25;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 8;
    }

    // optional double heading_jerk = 26;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 8;
    }

    // optional double heading_error_jerk = 27;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 8;
    }

    // optional double lateral_error_feedback = 28;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 8;
    }

    // optional double heading_error_feedback = 29;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 8;
    }

    // optional double steer_angle_feedback_augment = 31;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 8;
    }

  }
  // optional bool steer_mrac_enable_status = 33;
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SimpleLateralDebug::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:controller.SimpleLateralDebug)
  GOOGLE_DCHECK_NE(&from, this);
  const SimpleLateralDebug* source =
      ::google::protobuf::DynamicCastToGenerated<SimpleLateralDebug>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:controller.SimpleLateralDebug)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:controller.SimpleLateralDebug)
    MergeFrom(*source);
  }
}

void SimpleLateralDebug::MergeFrom(const SimpleLateralDebug& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:controller.SimpleLateralDebug)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_current_target_point()->::points::TrajectoryPoint::MergeFrom(from.current_target_point());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_steer_mrac_debug()->::controller::MracDebug::MergeFrom(from.steer_mrac_debug());
    }
    if (cached_has_bits & 0x00000004u) {
      lateral_error_ = from.lateral_error_;
    }
    if (cached_has_bits & 0x00000008u) {
      ref_heading_ = from.ref_heading_;
    }
    if (cached_has_bits & 0x00000010u) {
      heading_ = from.heading_;
    }
    if (cached_has_bits & 0x00000020u) {
      heading_error_ = from.heading_error_;
    }
    if (cached_has_bits & 0x00000040u) {
      heading_error_rate_ = from.heading_error_rate_;
    }
    if (cached_has_bits & 0x00000080u) {
      lateral_error_rate_ = from.lateral_error_rate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      curvature_ = from.curvature_;
    }
    if (cached_has_bits & 0x00000200u) {
      steer_angle_ = from.steer_angle_;
    }
    if (cached_has_bits & 0x00000400u) {
      steer_angle_feedforward_ = from.steer_angle_feedforward_;
    }
    if (cached_has_bits & 0x00000800u) {
      steer_angle_lateral_contribution_ = from.steer_angle_lateral_contribution_;
    }
    if (cached_has_bits & 0x00001000u) {
      steer_angle_lateral_rate_contribution_ = from.steer_angle_lateral_rate_contribution_;
    }
    if (cached_has_bits & 0x00002000u) {
      steer_angle_heading_contribution_ = from.steer_angle_heading_contribution_;
    }
    if (cached_has_bits & 0x00004000u) {
      steer_angle_heading_rate_contribution_ = from.steer_angle_heading_rate_contribution_;
    }
    if (cached_has_bits & 0x00008000u) {
      steer_angle_feedback_ = from.steer_angle_feedback_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      steering_position_ = from.steering_position_;
    }
    if (cached_has_bits & 0x00020000u) {
      ref_speed_ = from.ref_speed_;
    }
    if (cached_has_bits & 0x00040000u) {
      steer_angle_limited_ = from.steer_angle_limited_;
    }
    if (cached_has_bits & 0x00080000u) {
      lateral_acceleration_ = from.lateral_acceleration_;
    }
    if (cached_has_bits & 0x00100000u) {
      lateral_jerk_ = from.lateral_jerk_;
    }
    if (cached_has_bits & 0x00200000u) {
      ref_heading_rate_ = from.ref_heading_rate_;
    }
    if (cached_has_bits & 0x00400000u) {
      heading_rate_ = from.heading_rate_;
    }
    if (cached_has_bits & 0x00800000u) {
      ref_heading_acceleration_ = from.ref_heading_acceleration_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      heading_acceleration_ = from.heading_acceleration_;
    }
    if (cached_has_bits & 0x02000000u) {
      heading_error_acceleration_ = from.heading_error_acceleration_;
    }
    if (cached_has_bits & 0x04000000u) {
      ref_heading_jerk_ = from.ref_heading_jerk_;
    }
    if (cached_has_bits & 0x08000000u) {
      heading_jerk_ = from.heading_jerk_;
    }
    if (cached_has_bits & 0x10000000u) {
      heading_error_jerk_ = from.heading_error_jerk_;
    }
    if (cached_has_bits & 0x20000000u) {
      lateral_error_feedback_ = from.lateral_error_feedback_;
    }
    if (cached_has_bits & 0x40000000u) {
      heading_error_feedback_ = from.heading_error_feedback_;
    }
    if (cached_has_bits & 0x80000000u) {
      steer_angle_feedback_augment_ = from.steer_angle_feedback_augment_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (from.has_steer_mrac_enable_status()) {
    set_steer_mrac_enable_status(from.steer_mrac_enable_status());
  }
}

void SimpleLateralDebug::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:controller.SimpleLateralDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SimpleLateralDebug::CopyFrom(const SimpleLateralDebug& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:controller.SimpleLateralDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimpleLateralDebug::IsInitialized() const {
  return true;
}

void SimpleLateralDebug::Swap(SimpleLateralDebug* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SimpleLateralDebug::InternalSwap(SimpleLateralDebug* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  swap(current_target_point_, other->current_target_point_);
  swap(steer_mrac_debug_, other->steer_mrac_debug_);
  swap(lateral_error_, other->lateral_error_);
  swap(ref_heading_, other->ref_heading_);
  swap(heading_, other->heading_);
  swap(heading_error_, other->heading_error_);
  swap(heading_error_rate_, other->heading_error_rate_);
  swap(lateral_error_rate_, other->lateral_error_rate_);
  swap(curvature_, other->curvature_);
  swap(steer_angle_, other->steer_angle_);
  swap(steer_angle_feedforward_, other->steer_angle_feedforward_);
  swap(steer_angle_lateral_contribution_, other->steer_angle_lateral_contribution_);
  swap(steer_angle_lateral_rate_contribution_, other->steer_angle_lateral_rate_contribution_);
  swap(steer_angle_heading_contribution_, other->steer_angle_heading_contribution_);
  swap(steer_angle_heading_rate_contribution_, other->steer_angle_heading_rate_contribution_);
  swap(steer_angle_feedback_, other->steer_angle_feedback_);
  swap(steering_position_, other->steering_position_);
  swap(ref_speed_, other->ref_speed_);
  swap(steer_angle_limited_, other->steer_angle_limited_);
  swap(lateral_acceleration_, other->lateral_acceleration_);
  swap(lateral_jerk_, other->lateral_jerk_);
  swap(ref_heading_rate_, other->ref_heading_rate_);
  swap(heading_rate_, other->heading_rate_);
  swap(ref_heading_acceleration_, other->ref_heading_acceleration_);
  swap(heading_acceleration_, other->heading_acceleration_);
  swap(heading_error_acceleration_, other->heading_error_acceleration_);
  swap(ref_heading_jerk_, other->ref_heading_jerk_);
  swap(heading_jerk_, other->heading_jerk_);
  swap(heading_error_jerk_, other->heading_error_jerk_);
  swap(lateral_error_feedback_, other->lateral_error_feedback_);
  swap(heading_error_feedback_, other->heading_error_feedback_);
  swap(steer_angle_feedback_augment_, other->steer_angle_feedback_augment_);
  swap(steer_mrac_enable_status_, other->steer_mrac_enable_status_);
}

::google::protobuf::Metadata SimpleLateralDebug::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_control_5fcmd_2eproto);
  return ::file_level_metadata_control_5fcmd_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SimpleMPCDebug::InitAsDefaultInstance() {
}
class SimpleMPCDebug::HasBitSetters {
 public:
  static void set_has_lateral_error(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_ref_heading(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_heading(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_heading_error(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_heading_error_rate(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_lateral_error_rate(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_curvature(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_steer_angle(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_steer_angle_feedforward(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_steer_angle_lateral_contribution(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
  static void set_has_steer_angle_lateral_rate_contribution(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static void set_has_steer_angle_heading_contribution(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00000800u;
  }
  static void set_has_steer_angle_heading_rate_contribution(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00001000u;
  }
  static void set_has_steer_angle_feedback(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00002000u;
  }
  static void set_has_steering_position(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00004000u;
  }
  static void set_has_ref_speed(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00008000u;
  }
  static void set_has_steer_angle_limited(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00010000u;
  }
  static void set_has_station_reference(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00020000u;
  }
  static void set_has_station_error(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00040000u;
  }
  static void set_has_speed_reference(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00080000u;
  }
  static void set_has_speed_error(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00100000u;
  }
  static void set_has_acceleration_reference(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00200000u;
  }
  static void set_has_is_full_stop(SimpleMPCDebug* msg) {
    msg->_has_bits_[1] |= 0x00004000u;
  }
  static void set_has_station_feedback(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00400000u;
  }
  static void set_has_speed_feedback(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x00800000u;
  }
  static void set_has_acceleration_cmd_closeloop(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x01000000u;
  }
  static void set_has_acceleration_cmd(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x02000000u;
  }
  static void set_has_acceleration_lookup(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x04000000u;
  }
  static void set_has_speed_lookup(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x08000000u;
  }
  static void set_has_calibration_value(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x10000000u;
  }
  static void set_has_steer_unconstrained_control_diff(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x20000000u;
  }
  static void set_has_steer_angle_feedforward_compensation(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x40000000u;
  }
  static void set_has_lateral_acceleration(SimpleMPCDebug* msg) {
    msg->_has_bits_[0] |= 0x80000000u;
  }
  static void set_has_lateral_jerk(SimpleMPCDebug* msg) {
    msg->_has_bits_[1] |= 0x00000001u;
  }
  static void set_has_ref_heading_rate(SimpleMPCDebug* msg) {
    msg->_has_bits_[1] |= 0x00000002u;
  }
  static void set_has_heading_rate(SimpleMPCDebug* msg) {
    msg->_has_bits_[1] |= 0x00000004u;
  }
  static void set_has_ref_heading_acceleration(SimpleMPCDebug* msg) {
    msg->_has_bits_[1] |= 0x00000008u;
  }
  static void set_has_heading_acceleration(SimpleMPCDebug* msg) {
    msg->_has_bits_[1] |= 0x00000010u;
  }
  static void set_has_heading_error_acceleration(SimpleMPCDebug* msg) {
    msg->_has_bits_[1] |= 0x00000020u;
  }
  static void set_has_ref_heading_jerk(SimpleMPCDebug* msg) {
    msg->_has_bits_[1] |= 0x00000040u;
  }
  static void set_has_heading_jerk(SimpleMPCDebug* msg) {
    msg->_has_bits_[1] |= 0x00000080u;
  }
  static void set_has_heading_error_jerk(SimpleMPCDebug* msg) {
    msg->_has_bits_[1] |= 0x00000100u;
  }
  static void set_has_acceleration_feedback(SimpleMPCDebug* msg) {
    msg->_has_bits_[1] |= 0x00000200u;
  }
  static void set_has_acceleration_error(SimpleMPCDebug* msg) {
    msg->_has_bits_[1] |= 0x00000400u;
  }
  static void set_has_jerk_reference(SimpleMPCDebug* msg) {
    msg->_has_bits_[1] |= 0x00000800u;
  }
  static void set_has_jerk_feedback(SimpleMPCDebug* msg) {
    msg->_has_bits_[1] |= 0x00001000u;
  }
  static void set_has_jerk_error(SimpleMPCDebug* msg) {
    msg->_has_bits_[1] |= 0x00002000u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SimpleMPCDebug::kLateralErrorFieldNumber;
const int SimpleMPCDebug::kRefHeadingFieldNumber;
const int SimpleMPCDebug::kHeadingFieldNumber;
const int SimpleMPCDebug::kHeadingErrorFieldNumber;
const int SimpleMPCDebug::kHeadingErrorRateFieldNumber;
const int SimpleMPCDebug::kLateralErrorRateFieldNumber;
const int SimpleMPCDebug::kCurvatureFieldNumber;
const int SimpleMPCDebug::kSteerAngleFieldNumber;
const int SimpleMPCDebug::kSteerAngleFeedforwardFieldNumber;
const int SimpleMPCDebug::kSteerAngleLateralContributionFieldNumber;
const int SimpleMPCDebug::kSteerAngleLateralRateContributionFieldNumber;
const int SimpleMPCDebug::kSteerAngleHeadingContributionFieldNumber;
const int SimpleMPCDebug::kSteerAngleHeadingRateContributionFieldNumber;
const int SimpleMPCDebug::kSteerAngleFeedbackFieldNumber;
const int SimpleMPCDebug::kSteeringPositionFieldNumber;
const int SimpleMPCDebug::kRefSpeedFieldNumber;
const int SimpleMPCDebug::kSteerAngleLimitedFieldNumber;
const int SimpleMPCDebug::kStationReferenceFieldNumber;
const int SimpleMPCDebug::kStationErrorFieldNumber;
const int SimpleMPCDebug::kSpeedReferenceFieldNumber;
const int SimpleMPCDebug::kSpeedErrorFieldNumber;
const int SimpleMPCDebug::kAccelerationReferenceFieldNumber;
const int SimpleMPCDebug::kIsFullStopFieldNumber;
const int SimpleMPCDebug::kStationFeedbackFieldNumber;
const int SimpleMPCDebug::kSpeedFeedbackFieldNumber;
const int SimpleMPCDebug::kAccelerationCmdCloseloopFieldNumber;
const int SimpleMPCDebug::kAccelerationCmdFieldNumber;
const int SimpleMPCDebug::kAccelerationLookupFieldNumber;
const int SimpleMPCDebug::kSpeedLookupFieldNumber;
const int SimpleMPCDebug::kCalibrationValueFieldNumber;
const int SimpleMPCDebug::kSteerUnconstrainedControlDiffFieldNumber;
const int SimpleMPCDebug::kSteerAngleFeedforwardCompensationFieldNumber;
const int SimpleMPCDebug::kMatrixQUpdatedFieldNumber;
const int SimpleMPCDebug::kMatrixRUpdatedFieldNumber;
const int SimpleMPCDebug::kLateralAccelerationFieldNumber;
const int SimpleMPCDebug::kLateralJerkFieldNumber;
const int SimpleMPCDebug::kRefHeadingRateFieldNumber;
const int SimpleMPCDebug::kHeadingRateFieldNumber;
const int SimpleMPCDebug::kRefHeadingAccelerationFieldNumber;
const int SimpleMPCDebug::kHeadingAccelerationFieldNumber;
const int SimpleMPCDebug::kHeadingErrorAccelerationFieldNumber;
const int SimpleMPCDebug::kRefHeadingJerkFieldNumber;
const int SimpleMPCDebug::kHeadingJerkFieldNumber;
const int SimpleMPCDebug::kHeadingErrorJerkFieldNumber;
const int SimpleMPCDebug::kAccelerationFeedbackFieldNumber;
const int SimpleMPCDebug::kAccelerationErrorFieldNumber;
const int SimpleMPCDebug::kJerkReferenceFieldNumber;
const int SimpleMPCDebug::kJerkFeedbackFieldNumber;
const int SimpleMPCDebug::kJerkErrorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SimpleMPCDebug::SimpleMPCDebug()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:controller.SimpleMPCDebug)
}
SimpleMPCDebug::SimpleMPCDebug(const SimpleMPCDebug& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      matrix_q_updated_(from.matrix_q_updated_),
      matrix_r_updated_(from.matrix_r_updated_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&lateral_error_, &from.lateral_error_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_full_stop_) -
    reinterpret_cast<char*>(&lateral_error_)) + sizeof(is_full_stop_));
  // @@protoc_insertion_point(copy_constructor:controller.SimpleMPCDebug)
}

void SimpleMPCDebug::SharedCtor() {
  ::memset(&lateral_error_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_full_stop_) -
      reinterpret_cast<char*>(&lateral_error_)) + sizeof(is_full_stop_));
}

SimpleMPCDebug::~SimpleMPCDebug() {
  // @@protoc_insertion_point(destructor:controller.SimpleMPCDebug)
  SharedDtor();
}

void SimpleMPCDebug::SharedDtor() {
}

void SimpleMPCDebug::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SimpleMPCDebug& SimpleMPCDebug::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SimpleMPCDebug_control_5fcmd_2eproto.base);
  return *internal_default_instance();
}


void SimpleMPCDebug::Clear() {
// @@protoc_insertion_point(message_clear_start:controller.SimpleMPCDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  matrix_q_updated_.Clear();
  matrix_r_updated_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&lateral_error_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&steer_angle_) -
        reinterpret_cast<char*>(&lateral_error_)) + sizeof(steer_angle_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&steer_angle_feedforward_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ref_speed_) -
        reinterpret_cast<char*>(&steer_angle_feedforward_)) + sizeof(ref_speed_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&steer_angle_limited_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&speed_feedback_) -
        reinterpret_cast<char*>(&steer_angle_limited_)) + sizeof(speed_feedback_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&acceleration_cmd_closeloop_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lateral_acceleration_) -
        reinterpret_cast<char*>(&acceleration_cmd_closeloop_)) + sizeof(lateral_acceleration_));
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&lateral_jerk_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&heading_jerk_) -
        reinterpret_cast<char*>(&lateral_jerk_)) + sizeof(heading_jerk_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&heading_error_jerk_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_full_stop_) -
        reinterpret_cast<char*>(&heading_error_jerk_)) + sizeof(is_full_stop_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SimpleMPCDebug::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SimpleMPCDebug*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional double lateral_error = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_lateral_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double ref_heading = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_ref_heading(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_heading(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading_error = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_heading_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading_error_rate = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 41) goto handle_unusual;
        msg->set_heading_error_rate(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double lateral_error_rate = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 49) goto handle_unusual;
        msg->set_lateral_error_rate(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double curvature = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 57) goto handle_unusual;
        msg->set_curvature(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 65) goto handle_unusual;
        msg->set_steer_angle(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle_feedforward = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 73) goto handle_unusual;
        msg->set_steer_angle_feedforward(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle_lateral_contribution = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 81) goto handle_unusual;
        msg->set_steer_angle_lateral_contribution(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle_lateral_rate_contribution = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 89) goto handle_unusual;
        msg->set_steer_angle_lateral_rate_contribution(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle_heading_contribution = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 97) goto handle_unusual;
        msg->set_steer_angle_heading_contribution(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle_heading_rate_contribution = 13;
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 105) goto handle_unusual;
        msg->set_steer_angle_heading_rate_contribution(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle_feedback = 14;
      case 14: {
        if (static_cast<::google::protobuf::uint8>(tag) != 113) goto handle_unusual;
        msg->set_steer_angle_feedback(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steering_position = 15;
      case 15: {
        if (static_cast<::google::protobuf::uint8>(tag) != 121) goto handle_unusual;
        msg->set_steering_position(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double ref_speed = 16;
      case 16: {
        if (static_cast<::google::protobuf::uint8>(tag) != 129) goto handle_unusual;
        msg->set_ref_speed(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle_limited = 17;
      case 17: {
        if (static_cast<::google::protobuf::uint8>(tag) != 137) goto handle_unusual;
        msg->set_steer_angle_limited(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double station_reference = 18;
      case 18: {
        if (static_cast<::google::protobuf::uint8>(tag) != 145) goto handle_unusual;
        msg->set_station_reference(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double station_error = 19;
      case 19: {
        if (static_cast<::google::protobuf::uint8>(tag) != 153) goto handle_unusual;
        msg->set_station_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double speed_reference = 20;
      case 20: {
        if (static_cast<::google::protobuf::uint8>(tag) != 161) goto handle_unusual;
        msg->set_speed_reference(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double speed_error = 21;
      case 21: {
        if (static_cast<::google::protobuf::uint8>(tag) != 169) goto handle_unusual;
        msg->set_speed_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double acceleration_reference = 22;
      case 22: {
        if (static_cast<::google::protobuf::uint8>(tag) != 177) goto handle_unusual;
        msg->set_acceleration_reference(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional bool is_full_stop = 23;
      case 23: {
        if (static_cast<::google::protobuf::uint8>(tag) != 184) goto handle_unusual;
        msg->set_is_full_stop(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional double station_feedback = 24;
      case 24: {
        if (static_cast<::google::protobuf::uint8>(tag) != 193) goto handle_unusual;
        msg->set_station_feedback(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double speed_feedback = 25;
      case 25: {
        if (static_cast<::google::protobuf::uint8>(tag) != 201) goto handle_unusual;
        msg->set_speed_feedback(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double acceleration_cmd_closeloop = 26;
      case 26: {
        if (static_cast<::google::protobuf::uint8>(tag) != 209) goto handle_unusual;
        msg->set_acceleration_cmd_closeloop(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double acceleration_cmd = 27;
      case 27: {
        if (static_cast<::google::protobuf::uint8>(tag) != 217) goto handle_unusual;
        msg->set_acceleration_cmd(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double acceleration_lookup = 28;
      case 28: {
        if (static_cast<::google::protobuf::uint8>(tag) != 225) goto handle_unusual;
        msg->set_acceleration_lookup(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double speed_lookup = 29;
      case 29: {
        if (static_cast<::google::protobuf::uint8>(tag) != 233) goto handle_unusual;
        msg->set_speed_lookup(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double calibration_value = 30;
      case 30: {
        if (static_cast<::google::protobuf::uint8>(tag) != 241) goto handle_unusual;
        msg->set_calibration_value(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_unconstrained_control_diff = 31;
      case 31: {
        if (static_cast<::google::protobuf::uint8>(tag) != 249) goto handle_unusual;
        msg->set_steer_unconstrained_control_diff(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle_feedforward_compensation = 32;
      case 32: {
        if (static_cast<::google::protobuf::uint8>(tag) != 1) goto handle_unusual;
        msg->set_steer_angle_feedforward_compensation(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // repeated double matrix_q_updated = 33;
      case 33: {
        if (static_cast<::google::protobuf::uint8>(tag) == 9) {
          do {
            msg->add_matrix_q_updated(::google::protobuf::io::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 65535) == 649 && (ptr += 2));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedDoubleParser;
        object = msg->mutable_matrix_q_updated();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated double matrix_r_updated = 34;
      case 34: {
        if (static_cast<::google::protobuf::uint8>(tag) == 17) {
          do {
            msg->add_matrix_r_updated(::google::protobuf::io::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 65535) == 657 && (ptr += 2));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedDoubleParser;
        object = msg->mutable_matrix_r_updated();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // optional double lateral_acceleration = 35;
      case 35: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_lateral_acceleration(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double lateral_jerk = 36;
      case 36: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_lateral_jerk(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double ref_heading_rate = 37;
      case 37: {
        if (static_cast<::google::protobuf::uint8>(tag) != 41) goto handle_unusual;
        msg->set_ref_heading_rate(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading_rate = 38;
      case 38: {
        if (static_cast<::google::protobuf::uint8>(tag) != 49) goto handle_unusual;
        msg->set_heading_rate(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double ref_heading_acceleration = 39;
      case 39: {
        if (static_cast<::google::protobuf::uint8>(tag) != 57) goto handle_unusual;
        msg->set_ref_heading_acceleration(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading_acceleration = 40;
      case 40: {
        if (static_cast<::google::protobuf::uint8>(tag) != 65) goto handle_unusual;
        msg->set_heading_acceleration(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading_error_acceleration = 41;
      case 41: {
        if (static_cast<::google::protobuf::uint8>(tag) != 73) goto handle_unusual;
        msg->set_heading_error_acceleration(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double ref_heading_jerk = 42;
      case 42: {
        if (static_cast<::google::protobuf::uint8>(tag) != 81) goto handle_unusual;
        msg->set_ref_heading_jerk(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading_jerk = 43;
      case 43: {
        if (static_cast<::google::protobuf::uint8>(tag) != 89) goto handle_unusual;
        msg->set_heading_jerk(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading_error_jerk = 44;
      case 44: {
        if (static_cast<::google::protobuf::uint8>(tag) != 97) goto handle_unusual;
        msg->set_heading_error_jerk(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double acceleration_feedback = 45;
      case 45: {
        if (static_cast<::google::protobuf::uint8>(tag) != 105) goto handle_unusual;
        msg->set_acceleration_feedback(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double acceleration_error = 46;
      case 46: {
        if (static_cast<::google::protobuf::uint8>(tag) != 113) goto handle_unusual;
        msg->set_acceleration_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double jerk_reference = 47;
      case 47: {
        if (static_cast<::google::protobuf::uint8>(tag) != 121) goto handle_unusual;
        msg->set_jerk_reference(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double jerk_feedback = 48;
      case 48: {
        if (static_cast<::google::protobuf::uint8>(tag) != 129) goto handle_unusual;
        msg->set_jerk_feedback(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double jerk_error = 49;
      case 49: {
        if (static_cast<::google::protobuf::uint8>(tag) != 137) goto handle_unusual;
        msg->set_jerk_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SimpleMPCDebug::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:controller.SimpleMPCDebug)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double lateral_error = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_lateral_error(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lateral_error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double ref_heading = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_ref_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ref_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_error = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {
          HasBitSetters::set_has_heading_error(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_error_rate = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (41 & 0xFF)) {
          HasBitSetters::set_has_heading_error_rate(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_error_rate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double lateral_error_rate = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (49 & 0xFF)) {
          HasBitSetters::set_has_lateral_error_rate(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lateral_error_rate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double curvature = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (57 & 0xFF)) {
          HasBitSetters::set_has_curvature(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &curvature_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (65 & 0xFF)) {
          HasBitSetters::set_has_steer_angle(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_feedforward = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (73 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_feedforward(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_feedforward_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_lateral_contribution = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (81 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_lateral_contribution(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_lateral_contribution_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_lateral_rate_contribution = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (89 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_lateral_rate_contribution(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_lateral_rate_contribution_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_heading_contribution = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (97 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_heading_contribution(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_heading_contribution_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_heading_rate_contribution = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (105 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_heading_rate_contribution(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_heading_rate_contribution_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_feedback = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (113 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_feedback(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_feedback_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steering_position = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (121 & 0xFF)) {
          HasBitSetters::set_has_steering_position(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steering_position_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double ref_speed = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (129 & 0xFF)) {
          HasBitSetters::set_has_ref_speed(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ref_speed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_limited = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (137 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_limited(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_limited_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double station_reference = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (145 & 0xFF)) {
          HasBitSetters::set_has_station_reference(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &station_reference_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double station_error = 19;
      case 19: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (153 & 0xFF)) {
          HasBitSetters::set_has_station_error(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &station_error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double speed_reference = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (161 & 0xFF)) {
          HasBitSetters::set_has_speed_reference(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &speed_reference_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double speed_error = 21;
      case 21: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (169 & 0xFF)) {
          HasBitSetters::set_has_speed_error(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &speed_error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double acceleration_reference = 22;
      case 22: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (177 & 0xFF)) {
          HasBitSetters::set_has_acceleration_reference(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &acceleration_reference_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_full_stop = 23;
      case 23: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (184 & 0xFF)) {
          HasBitSetters::set_has_is_full_stop(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_full_stop_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double station_feedback = 24;
      case 24: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (193 & 0xFF)) {
          HasBitSetters::set_has_station_feedback(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &station_feedback_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double speed_feedback = 25;
      case 25: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (201 & 0xFF)) {
          HasBitSetters::set_has_speed_feedback(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &speed_feedback_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double acceleration_cmd_closeloop = 26;
      case 26: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (209 & 0xFF)) {
          HasBitSetters::set_has_acceleration_cmd_closeloop(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &acceleration_cmd_closeloop_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double acceleration_cmd = 27;
      case 27: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (217 & 0xFF)) {
          HasBitSetters::set_has_acceleration_cmd(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &acceleration_cmd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double acceleration_lookup = 28;
      case 28: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (225 & 0xFF)) {
          HasBitSetters::set_has_acceleration_lookup(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &acceleration_lookup_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double speed_lookup = 29;
      case 29: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (233 & 0xFF)) {
          HasBitSetters::set_has_speed_lookup(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &speed_lookup_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double calibration_value = 30;
      case 30: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (241 & 0xFF)) {
          HasBitSetters::set_has_calibration_value(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &calibration_value_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_unconstrained_control_diff = 31;
      case 31: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (249 & 0xFF)) {
          HasBitSetters::set_has_steer_unconstrained_control_diff(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_unconstrained_control_diff_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_feedforward_compensation = 32;
      case 32: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (257 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_feedforward_compensation(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_feedforward_compensation_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double matrix_q_updated = 33;
      case 33: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (265 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 2, 265u, input, this->mutable_matrix_q_updated())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (266 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_matrix_q_updated())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double matrix_r_updated = 34;
      case 34: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (273 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 2, 273u, input, this->mutable_matrix_r_updated())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (274 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_matrix_r_updated())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double lateral_acceleration = 35;
      case 35: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (281 & 0xFF)) {
          HasBitSetters::set_has_lateral_acceleration(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lateral_acceleration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double lateral_jerk = 36;
      case 36: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (289 & 0xFF)) {
          HasBitSetters::set_has_lateral_jerk(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &lateral_jerk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double ref_heading_rate = 37;
      case 37: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (297 & 0xFF)) {
          HasBitSetters::set_has_ref_heading_rate(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ref_heading_rate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_rate = 38;
      case 38: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (305 & 0xFF)) {
          HasBitSetters::set_has_heading_rate(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_rate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double ref_heading_acceleration = 39;
      case 39: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (313 & 0xFF)) {
          HasBitSetters::set_has_ref_heading_acceleration(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ref_heading_acceleration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_acceleration = 40;
      case 40: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (321 & 0xFF)) {
          HasBitSetters::set_has_heading_acceleration(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_acceleration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_error_acceleration = 41;
      case 41: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (329 & 0xFF)) {
          HasBitSetters::set_has_heading_error_acceleration(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_error_acceleration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double ref_heading_jerk = 42;
      case 42: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (337 & 0xFF)) {
          HasBitSetters::set_has_ref_heading_jerk(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ref_heading_jerk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_jerk = 43;
      case 43: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (345 & 0xFF)) {
          HasBitSetters::set_has_heading_jerk(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_jerk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_error_jerk = 44;
      case 44: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (353 & 0xFF)) {
          HasBitSetters::set_has_heading_error_jerk(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_error_jerk_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double acceleration_feedback = 45;
      case 45: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (361 & 0xFF)) {
          HasBitSetters::set_has_acceleration_feedback(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &acceleration_feedback_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double acceleration_error = 46;
      case 46: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (369 & 0xFF)) {
          HasBitSetters::set_has_acceleration_error(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &acceleration_error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double jerk_reference = 47;
      case 47: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (377 & 0xFF)) {
          HasBitSetters::set_has_jerk_reference(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &jerk_reference_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double jerk_feedback = 48;
      case 48: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (385 & 0xFF)) {
          HasBitSetters::set_has_jerk_feedback(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &jerk_feedback_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double jerk_error = 49;
      case 49: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (393 & 0xFF)) {
          HasBitSetters::set_has_jerk_error(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &jerk_error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:controller.SimpleMPCDebug)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:controller.SimpleMPCDebug)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SimpleMPCDebug::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:controller.SimpleMPCDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double lateral_error = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->lateral_error(), output);
  }

  // optional double ref_heading = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->ref_heading(), output);
  }

  // optional double heading = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->heading(), output);
  }

  // optional double heading_error = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->heading_error(), output);
  }

  // optional double heading_error_rate = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->heading_error_rate(), output);
  }

  // optional double lateral_error_rate = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->lateral_error_rate(), output);
  }

  // optional double curvature = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->curvature(), output);
  }

  // optional double steer_angle = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->steer_angle(), output);
  }

  // optional double steer_angle_feedforward = 9;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->steer_angle_feedforward(), output);
  }

  // optional double steer_angle_lateral_contribution = 10;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(10, this->steer_angle_lateral_contribution(), output);
  }

  // optional double steer_angle_lateral_rate_contribution = 11;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(11, this->steer_angle_lateral_rate_contribution(), output);
  }

  // optional double steer_angle_heading_contribution = 12;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(12, this->steer_angle_heading_contribution(), output);
  }

  // optional double steer_angle_heading_rate_contribution = 13;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(13, this->steer_angle_heading_rate_contribution(), output);
  }

  // optional double steer_angle_feedback = 14;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(14, this->steer_angle_feedback(), output);
  }

  // optional double steering_position = 15;
  if (cached_has_bits & 0x00004000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(15, this->steering_position(), output);
  }

  // optional double ref_speed = 16;
  if (cached_has_bits & 0x00008000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(16, this->ref_speed(), output);
  }

  // optional double steer_angle_limited = 17;
  if (cached_has_bits & 0x00010000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(17, this->steer_angle_limited(), output);
  }

  // optional double station_reference = 18;
  if (cached_has_bits & 0x00020000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(18, this->station_reference(), output);
  }

  // optional double station_error = 19;
  if (cached_has_bits & 0x00040000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(19, this->station_error(), output);
  }

  // optional double speed_reference = 20;
  if (cached_has_bits & 0x00080000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(20, this->speed_reference(), output);
  }

  // optional double speed_error = 21;
  if (cached_has_bits & 0x00100000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(21, this->speed_error(), output);
  }

  // optional double acceleration_reference = 22;
  if (cached_has_bits & 0x00200000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(22, this->acceleration_reference(), output);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool is_full_stop = 23;
  if (cached_has_bits & 0x00004000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(23, this->is_full_stop(), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional double station_feedback = 24;
  if (cached_has_bits & 0x00400000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(24, this->station_feedback(), output);
  }

  // optional double speed_feedback = 25;
  if (cached_has_bits & 0x00800000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(25, this->speed_feedback(), output);
  }

  // optional double acceleration_cmd_closeloop = 26;
  if (cached_has_bits & 0x01000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(26, this->acceleration_cmd_closeloop(), output);
  }

  // optional double acceleration_cmd = 27;
  if (cached_has_bits & 0x02000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(27, this->acceleration_cmd(), output);
  }

  // optional double acceleration_lookup = 28;
  if (cached_has_bits & 0x04000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(28, this->acceleration_lookup(), output);
  }

  // optional double speed_lookup = 29;
  if (cached_has_bits & 0x08000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(29, this->speed_lookup(), output);
  }

  // optional double calibration_value = 30;
  if (cached_has_bits & 0x10000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(30, this->calibration_value(), output);
  }

  // optional double steer_unconstrained_control_diff = 31;
  if (cached_has_bits & 0x20000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(31, this->steer_unconstrained_control_diff(), output);
  }

  // optional double steer_angle_feedforward_compensation = 32;
  if (cached_has_bits & 0x40000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(32, this->steer_angle_feedforward_compensation(), output);
  }

  // repeated double matrix_q_updated = 33;
  for (int i = 0, n = this->matrix_q_updated_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      33, this->matrix_q_updated(i), output);
  }

  // repeated double matrix_r_updated = 34;
  for (int i = 0, n = this->matrix_r_updated_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      34, this->matrix_r_updated(i), output);
  }

  // optional double lateral_acceleration = 35;
  if (cached_has_bits & 0x80000000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(35, this->lateral_acceleration(), output);
  }

  cached_has_bits = _has_bits_[1];
  // optional double lateral_jerk = 36;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(36, this->lateral_jerk(), output);
  }

  // optional double ref_heading_rate = 37;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(37, this->ref_heading_rate(), output);
  }

  // optional double heading_rate = 38;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(38, this->heading_rate(), output);
  }

  // optional double ref_heading_acceleration = 39;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(39, this->ref_heading_acceleration(), output);
  }

  // optional double heading_acceleration = 40;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(40, this->heading_acceleration(), output);
  }

  // optional double heading_error_acceleration = 41;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(41, this->heading_error_acceleration(), output);
  }

  // optional double ref_heading_jerk = 42;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(42, this->ref_heading_jerk(), output);
  }

  // optional double heading_jerk = 43;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(43, this->heading_jerk(), output);
  }

  // optional double heading_error_jerk = 44;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(44, this->heading_error_jerk(), output);
  }

  // optional double acceleration_feedback = 45;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(45, this->acceleration_feedback(), output);
  }

  // optional double acceleration_error = 46;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(46, this->acceleration_error(), output);
  }

  // optional double jerk_reference = 47;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(47, this->jerk_reference(), output);
  }

  // optional double jerk_feedback = 48;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(48, this->jerk_feedback(), output);
  }

  // optional double jerk_error = 49;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(49, this->jerk_error(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:controller.SimpleMPCDebug)
}

::google::protobuf::uint8* SimpleMPCDebug::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:controller.SimpleMPCDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double lateral_error = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->lateral_error(), target);
  }

  // optional double ref_heading = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->ref_heading(), target);
  }

  // optional double heading = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->heading(), target);
  }

  // optional double heading_error = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->heading_error(), target);
  }

  // optional double heading_error_rate = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->heading_error_rate(), target);
  }

  // optional double lateral_error_rate = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->lateral_error_rate(), target);
  }

  // optional double curvature = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->curvature(), target);
  }

  // optional double steer_angle = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->steer_angle(), target);
  }

  // optional double steer_angle_feedforward = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->steer_angle_feedforward(), target);
  }

  // optional double steer_angle_lateral_contribution = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(10, this->steer_angle_lateral_contribution(), target);
  }

  // optional double steer_angle_lateral_rate_contribution = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(11, this->steer_angle_lateral_rate_contribution(), target);
  }

  // optional double steer_angle_heading_contribution = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(12, this->steer_angle_heading_contribution(), target);
  }

  // optional double steer_angle_heading_rate_contribution = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(13, this->steer_angle_heading_rate_contribution(), target);
  }

  // optional double steer_angle_feedback = 14;
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(14, this->steer_angle_feedback(), target);
  }

  // optional double steering_position = 15;
  if (cached_has_bits & 0x00004000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(15, this->steering_position(), target);
  }

  // optional double ref_speed = 16;
  if (cached_has_bits & 0x00008000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(16, this->ref_speed(), target);
  }

  // optional double steer_angle_limited = 17;
  if (cached_has_bits & 0x00010000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(17, this->steer_angle_limited(), target);
  }

  // optional double station_reference = 18;
  if (cached_has_bits & 0x00020000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(18, this->station_reference(), target);
  }

  // optional double station_error = 19;
  if (cached_has_bits & 0x00040000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(19, this->station_error(), target);
  }

  // optional double speed_reference = 20;
  if (cached_has_bits & 0x00080000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(20, this->speed_reference(), target);
  }

  // optional double speed_error = 21;
  if (cached_has_bits & 0x00100000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(21, this->speed_error(), target);
  }

  // optional double acceleration_reference = 22;
  if (cached_has_bits & 0x00200000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(22, this->acceleration_reference(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool is_full_stop = 23;
  if (cached_has_bits & 0x00004000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(23, this->is_full_stop(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional double station_feedback = 24;
  if (cached_has_bits & 0x00400000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(24, this->station_feedback(), target);
  }

  // optional double speed_feedback = 25;
  if (cached_has_bits & 0x00800000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(25, this->speed_feedback(), target);
  }

  // optional double acceleration_cmd_closeloop = 26;
  if (cached_has_bits & 0x01000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(26, this->acceleration_cmd_closeloop(), target);
  }

  // optional double acceleration_cmd = 27;
  if (cached_has_bits & 0x02000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(27, this->acceleration_cmd(), target);
  }

  // optional double acceleration_lookup = 28;
  if (cached_has_bits & 0x04000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(28, this->acceleration_lookup(), target);
  }

  // optional double speed_lookup = 29;
  if (cached_has_bits & 0x08000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(29, this->speed_lookup(), target);
  }

  // optional double calibration_value = 30;
  if (cached_has_bits & 0x10000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(30, this->calibration_value(), target);
  }

  // optional double steer_unconstrained_control_diff = 31;
  if (cached_has_bits & 0x20000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(31, this->steer_unconstrained_control_diff(), target);
  }

  // optional double steer_angle_feedforward_compensation = 32;
  if (cached_has_bits & 0x40000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(32, this->steer_angle_feedforward_compensation(), target);
  }

  // repeated double matrix_q_updated = 33;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(33, this->matrix_q_updated_, target);

  // repeated double matrix_r_updated = 34;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(34, this->matrix_r_updated_, target);

  // optional double lateral_acceleration = 35;
  if (cached_has_bits & 0x80000000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(35, this->lateral_acceleration(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional double lateral_jerk = 36;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(36, this->lateral_jerk(), target);
  }

  // optional double ref_heading_rate = 37;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(37, this->ref_heading_rate(), target);
  }

  // optional double heading_rate = 38;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(38, this->heading_rate(), target);
  }

  // optional double ref_heading_acceleration = 39;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(39, this->ref_heading_acceleration(), target);
  }

  // optional double heading_acceleration = 40;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(40, this->heading_acceleration(), target);
  }

  // optional double heading_error_acceleration = 41;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(41, this->heading_error_acceleration(), target);
  }

  // optional double ref_heading_jerk = 42;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(42, this->ref_heading_jerk(), target);
  }

  // optional double heading_jerk = 43;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(43, this->heading_jerk(), target);
  }

  // optional double heading_error_jerk = 44;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(44, this->heading_error_jerk(), target);
  }

  // optional double acceleration_feedback = 45;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(45, this->acceleration_feedback(), target);
  }

  // optional double acceleration_error = 46;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(46, this->acceleration_error(), target);
  }

  // optional double jerk_reference = 47;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(47, this->jerk_reference(), target);
  }

  // optional double jerk_feedback = 48;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(48, this->jerk_feedback(), target);
  }

  // optional double jerk_error = 49;
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(49, this->jerk_error(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:controller.SimpleMPCDebug)
  return target;
}

size_t SimpleMPCDebug::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:controller.SimpleMPCDebug)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double matrix_q_updated = 33;
  {
    unsigned int count = static_cast<unsigned int>(this->matrix_q_updated_size());
    size_t data_size = 8UL * count;
    total_size += 2 *
                  ::google::protobuf::internal::FromIntSize(this->matrix_q_updated_size());
    total_size += data_size;
  }

  // repeated double matrix_r_updated = 34;
  {
    unsigned int count = static_cast<unsigned int>(this->matrix_r_updated_size());
    size_t data_size = 8UL * count;
    total_size += 2 *
                  ::google::protobuf::internal::FromIntSize(this->matrix_r_updated_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional double lateral_error = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double ref_heading = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double heading = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double heading_error = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double heading_error_rate = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double lateral_error_rate = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double curvature = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double steer_angle = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double steer_angle_feedforward = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double steer_angle_lateral_contribution = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional double steer_angle_lateral_rate_contribution = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

    // optional double steer_angle_heading_contribution = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

    // optional double steer_angle_heading_rate_contribution = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 8;
    }

    // optional double steer_angle_feedback = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 8;
    }

    // optional double steering_position = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 8;
    }

    // optional double ref_speed = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 8;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional double steer_angle_limited = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 8;
    }

    // optional double station_reference = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 8;
    }

    // optional double station_error = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 8;
    }

    // optional double speed_reference = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 8;
    }

    // optional double speed_error = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 8;
    }

    // optional double acceleration_reference = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 8;
    }

    // optional double station_feedback = 24;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 8;
    }

    // optional double speed_feedback = 25;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 8;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional double acceleration_cmd_closeloop = 26;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 8;
    }

    // optional double acceleration_cmd = 27;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 8;
    }

    // optional double acceleration_lookup = 28;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 8;
    }

    // optional double speed_lookup = 29;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 8;
    }

    // optional double calibration_value = 30;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 8;
    }

    // optional double steer_unconstrained_control_diff = 31;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 8;
    }

    // optional double steer_angle_feedforward_compensation = 32;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 8;
    }

    // optional double lateral_acceleration = 35;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 8;
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional double lateral_jerk = 36;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 8;
    }

    // optional double ref_heading_rate = 37;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 8;
    }

    // optional double heading_rate = 38;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 8;
    }

    // optional double ref_heading_acceleration = 39;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 8;
    }

    // optional double heading_acceleration = 40;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 8;
    }

    // optional double heading_error_acceleration = 41;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 8;
    }

    // optional double ref_heading_jerk = 42;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 8;
    }

    // optional double heading_jerk = 43;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + 8;
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional double heading_error_jerk = 44;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 8;
    }

    // optional double acceleration_feedback = 45;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 8;
    }

    // optional double acceleration_error = 46;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 8;
    }

    // optional double jerk_reference = 47;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 8;
    }

    // optional double jerk_feedback = 48;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 8;
    }

    // optional double jerk_error = 49;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 8;
    }

    // optional bool is_full_stop = 23;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SimpleMPCDebug::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:controller.SimpleMPCDebug)
  GOOGLE_DCHECK_NE(&from, this);
  const SimpleMPCDebug* source =
      ::google::protobuf::DynamicCastToGenerated<SimpleMPCDebug>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:controller.SimpleMPCDebug)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:controller.SimpleMPCDebug)
    MergeFrom(*source);
  }
}

void SimpleMPCDebug::MergeFrom(const SimpleMPCDebug& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:controller.SimpleMPCDebug)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  matrix_q_updated_.MergeFrom(from.matrix_q_updated_);
  matrix_r_updated_.MergeFrom(from.matrix_r_updated_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      lateral_error_ = from.lateral_error_;
    }
    if (cached_has_bits & 0x00000002u) {
      ref_heading_ = from.ref_heading_;
    }
    if (cached_has_bits & 0x00000004u) {
      heading_ = from.heading_;
    }
    if (cached_has_bits & 0x00000008u) {
      heading_error_ = from.heading_error_;
    }
    if (cached_has_bits & 0x00000010u) {
      heading_error_rate_ = from.heading_error_rate_;
    }
    if (cached_has_bits & 0x00000020u) {
      lateral_error_rate_ = from.lateral_error_rate_;
    }
    if (cached_has_bits & 0x00000040u) {
      curvature_ = from.curvature_;
    }
    if (cached_has_bits & 0x00000080u) {
      steer_angle_ = from.steer_angle_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      steer_angle_feedforward_ = from.steer_angle_feedforward_;
    }
    if (cached_has_bits & 0x00000200u) {
      steer_angle_lateral_contribution_ = from.steer_angle_lateral_contribution_;
    }
    if (cached_has_bits & 0x00000400u) {
      steer_angle_lateral_rate_contribution_ = from.steer_angle_lateral_rate_contribution_;
    }
    if (cached_has_bits & 0x00000800u) {
      steer_angle_heading_contribution_ = from.steer_angle_heading_contribution_;
    }
    if (cached_has_bits & 0x00001000u) {
      steer_angle_heading_rate_contribution_ = from.steer_angle_heading_rate_contribution_;
    }
    if (cached_has_bits & 0x00002000u) {
      steer_angle_feedback_ = from.steer_angle_feedback_;
    }
    if (cached_has_bits & 0x00004000u) {
      steering_position_ = from.steering_position_;
    }
    if (cached_has_bits & 0x00008000u) {
      ref_speed_ = from.ref_speed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      steer_angle_limited_ = from.steer_angle_limited_;
    }
    if (cached_has_bits & 0x00020000u) {
      station_reference_ = from.station_reference_;
    }
    if (cached_has_bits & 0x00040000u) {
      station_error_ = from.station_error_;
    }
    if (cached_has_bits & 0x00080000u) {
      speed_reference_ = from.speed_reference_;
    }
    if (cached_has_bits & 0x00100000u) {
      speed_error_ = from.speed_error_;
    }
    if (cached_has_bits & 0x00200000u) {
      acceleration_reference_ = from.acceleration_reference_;
    }
    if (cached_has_bits & 0x00400000u) {
      station_feedback_ = from.station_feedback_;
    }
    if (cached_has_bits & 0x00800000u) {
      speed_feedback_ = from.speed_feedback_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      acceleration_cmd_closeloop_ = from.acceleration_cmd_closeloop_;
    }
    if (cached_has_bits & 0x02000000u) {
      acceleration_cmd_ = from.acceleration_cmd_;
    }
    if (cached_has_bits & 0x04000000u) {
      acceleration_lookup_ = from.acceleration_lookup_;
    }
    if (cached_has_bits & 0x08000000u) {
      speed_lookup_ = from.speed_lookup_;
    }
    if (cached_has_bits & 0x10000000u) {
      calibration_value_ = from.calibration_value_;
    }
    if (cached_has_bits & 0x20000000u) {
      steer_unconstrained_control_diff_ = from.steer_unconstrained_control_diff_;
    }
    if (cached_has_bits & 0x40000000u) {
      steer_angle_feedforward_compensation_ = from.steer_angle_feedforward_compensation_;
    }
    if (cached_has_bits & 0x80000000u) {
      lateral_acceleration_ = from.lateral_acceleration_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      lateral_jerk_ = from.lateral_jerk_;
    }
    if (cached_has_bits & 0x00000002u) {
      ref_heading_rate_ = from.ref_heading_rate_;
    }
    if (cached_has_bits & 0x00000004u) {
      heading_rate_ = from.heading_rate_;
    }
    if (cached_has_bits & 0x00000008u) {
      ref_heading_acceleration_ = from.ref_heading_acceleration_;
    }
    if (cached_has_bits & 0x00000010u) {
      heading_acceleration_ = from.heading_acceleration_;
    }
    if (cached_has_bits & 0x00000020u) {
      heading_error_acceleration_ = from.heading_error_acceleration_;
    }
    if (cached_has_bits & 0x00000040u) {
      ref_heading_jerk_ = from.ref_heading_jerk_;
    }
    if (cached_has_bits & 0x00000080u) {
      heading_jerk_ = from.heading_jerk_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      heading_error_jerk_ = from.heading_error_jerk_;
    }
    if (cached_has_bits & 0x00000200u) {
      acceleration_feedback_ = from.acceleration_feedback_;
    }
    if (cached_has_bits & 0x00000400u) {
      acceleration_error_ = from.acceleration_error_;
    }
    if (cached_has_bits & 0x00000800u) {
      jerk_reference_ = from.jerk_reference_;
    }
    if (cached_has_bits & 0x00001000u) {
      jerk_feedback_ = from.jerk_feedback_;
    }
    if (cached_has_bits & 0x00002000u) {
      jerk_error_ = from.jerk_error_;
    }
    if (cached_has_bits & 0x00004000u) {
      is_full_stop_ = from.is_full_stop_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
}

void SimpleMPCDebug::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:controller.SimpleMPCDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SimpleMPCDebug::CopyFrom(const SimpleMPCDebug& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:controller.SimpleMPCDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimpleMPCDebug::IsInitialized() const {
  return true;
}

void SimpleMPCDebug::Swap(SimpleMPCDebug* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SimpleMPCDebug::InternalSwap(SimpleMPCDebug* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  matrix_q_updated_.InternalSwap(&other->matrix_q_updated_);
  matrix_r_updated_.InternalSwap(&other->matrix_r_updated_);
  swap(lateral_error_, other->lateral_error_);
  swap(ref_heading_, other->ref_heading_);
  swap(heading_, other->heading_);
  swap(heading_error_, other->heading_error_);
  swap(heading_error_rate_, other->heading_error_rate_);
  swap(lateral_error_rate_, other->lateral_error_rate_);
  swap(curvature_, other->curvature_);
  swap(steer_angle_, other->steer_angle_);
  swap(steer_angle_feedforward_, other->steer_angle_feedforward_);
  swap(steer_angle_lateral_contribution_, other->steer_angle_lateral_contribution_);
  swap(steer_angle_lateral_rate_contribution_, other->steer_angle_lateral_rate_contribution_);
  swap(steer_angle_heading_contribution_, other->steer_angle_heading_contribution_);
  swap(steer_angle_heading_rate_contribution_, other->steer_angle_heading_rate_contribution_);
  swap(steer_angle_feedback_, other->steer_angle_feedback_);
  swap(steering_position_, other->steering_position_);
  swap(ref_speed_, other->ref_speed_);
  swap(steer_angle_limited_, other->steer_angle_limited_);
  swap(station_reference_, other->station_reference_);
  swap(station_error_, other->station_error_);
  swap(speed_reference_, other->speed_reference_);
  swap(speed_error_, other->speed_error_);
  swap(acceleration_reference_, other->acceleration_reference_);
  swap(station_feedback_, other->station_feedback_);
  swap(speed_feedback_, other->speed_feedback_);
  swap(acceleration_cmd_closeloop_, other->acceleration_cmd_closeloop_);
  swap(acceleration_cmd_, other->acceleration_cmd_);
  swap(acceleration_lookup_, other->acceleration_lookup_);
  swap(speed_lookup_, other->speed_lookup_);
  swap(calibration_value_, other->calibration_value_);
  swap(steer_unconstrained_control_diff_, other->steer_unconstrained_control_diff_);
  swap(steer_angle_feedforward_compensation_, other->steer_angle_feedforward_compensation_);
  swap(lateral_acceleration_, other->lateral_acceleration_);
  swap(lateral_jerk_, other->lateral_jerk_);
  swap(ref_heading_rate_, other->ref_heading_rate_);
  swap(heading_rate_, other->heading_rate_);
  swap(ref_heading_acceleration_, other->ref_heading_acceleration_);
  swap(heading_acceleration_, other->heading_acceleration_);
  swap(heading_error_acceleration_, other->heading_error_acceleration_);
  swap(ref_heading_jerk_, other->ref_heading_jerk_);
  swap(heading_jerk_, other->heading_jerk_);
  swap(heading_error_jerk_, other->heading_error_jerk_);
  swap(acceleration_feedback_, other->acceleration_feedback_);
  swap(acceleration_error_, other->acceleration_error_);
  swap(jerk_reference_, other->jerk_reference_);
  swap(jerk_feedback_, other->jerk_feedback_);
  swap(jerk_error_, other->jerk_error_);
  swap(is_full_stop_, other->is_full_stop_);
}

::google::protobuf::Metadata SimpleMPCDebug::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_control_5fcmd_2eproto);
  return ::file_level_metadata_control_5fcmd_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SimplePIDLatLonDebug::InitAsDefaultInstance() {
  ::controller::_SimplePIDLatLonDebug_default_instance_._instance.get_mutable()->target_point_ = const_cast< ::points::TrajectoryPoint*>(
      ::points::TrajectoryPoint::internal_default_instance());
}
class SimplePIDLatLonDebug::HasBitSetters {
 public:
  static void set_has_look_ahead_station(SimplePIDLatLonDebug* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_station_error(SimplePIDLatLonDebug* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_current_speed(SimplePIDLatLonDebug* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_current_heading(SimplePIDLatLonDebug* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_heading_error(SimplePIDLatLonDebug* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_current_steer_wheel_angle(SimplePIDLatLonDebug* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_speed_cmd(SimplePIDLatLonDebug* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_steer_angle_cmd(SimplePIDLatLonDebug* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static const ::points::TrajectoryPoint& target_point(const SimplePIDLatLonDebug* msg);
  static void set_has_target_point(SimplePIDLatLonDebug* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::points::TrajectoryPoint&
SimplePIDLatLonDebug::HasBitSetters::target_point(const SimplePIDLatLonDebug* msg) {
  return *msg->target_point_;
}
void SimplePIDLatLonDebug::clear_target_point() {
  if (target_point_ != nullptr) target_point_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SimplePIDLatLonDebug::kLookAheadStationFieldNumber;
const int SimplePIDLatLonDebug::kStationErrorFieldNumber;
const int SimplePIDLatLonDebug::kCurrentSpeedFieldNumber;
const int SimplePIDLatLonDebug::kCurrentHeadingFieldNumber;
const int SimplePIDLatLonDebug::kHeadingErrorFieldNumber;
const int SimplePIDLatLonDebug::kCurrentSteerWheelAngleFieldNumber;
const int SimplePIDLatLonDebug::kSpeedCmdFieldNumber;
const int SimplePIDLatLonDebug::kSteerAngleCmdFieldNumber;
const int SimplePIDLatLonDebug::kTargetPointFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SimplePIDLatLonDebug::SimplePIDLatLonDebug()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:controller.SimplePIDLatLonDebug)
}
SimplePIDLatLonDebug::SimplePIDLatLonDebug(const SimplePIDLatLonDebug& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_target_point()) {
    target_point_ = new ::points::TrajectoryPoint(*from.target_point_);
  } else {
    target_point_ = nullptr;
  }
  ::memcpy(&look_ahead_station_, &from.look_ahead_station_,
    static_cast<size_t>(reinterpret_cast<char*>(&steer_angle_cmd_) -
    reinterpret_cast<char*>(&look_ahead_station_)) + sizeof(steer_angle_cmd_));
  // @@protoc_insertion_point(copy_constructor:controller.SimplePIDLatLonDebug)
}

void SimplePIDLatLonDebug::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_SimplePIDLatLonDebug_control_5fcmd_2eproto.base);
  ::memset(&target_point_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&steer_angle_cmd_) -
      reinterpret_cast<char*>(&target_point_)) + sizeof(steer_angle_cmd_));
}

SimplePIDLatLonDebug::~SimplePIDLatLonDebug() {
  // @@protoc_insertion_point(destructor:controller.SimplePIDLatLonDebug)
  SharedDtor();
}

void SimplePIDLatLonDebug::SharedDtor() {
  if (this != internal_default_instance()) delete target_point_;
}

void SimplePIDLatLonDebug::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SimplePIDLatLonDebug& SimplePIDLatLonDebug::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SimplePIDLatLonDebug_control_5fcmd_2eproto.base);
  return *internal_default_instance();
}


void SimplePIDLatLonDebug::Clear() {
// @@protoc_insertion_point(message_clear_start:controller.SimplePIDLatLonDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(target_point_ != nullptr);
    target_point_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&look_ahead_station_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&speed_cmd_) -
        reinterpret_cast<char*>(&look_ahead_station_)) + sizeof(speed_cmd_));
  }
  steer_angle_cmd_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SimplePIDLatLonDebug::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SimplePIDLatLonDebug*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional double look_ahead_station = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_look_ahead_station(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double station_error = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_station_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double current_speed = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_current_speed(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double current_heading = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_current_heading(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double heading_error = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 41) goto handle_unusual;
        msg->set_heading_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double current_steer_wheel_angle = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 49) goto handle_unusual;
        msg->set_current_steer_wheel_angle(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double speed_cmd = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 57) goto handle_unusual;
        msg->set_speed_cmd(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double steer_angle_cmd = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 65) goto handle_unusual;
        msg->set_steer_angle_cmd(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional .points.TrajectoryPoint target_point = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 74) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::points::TrajectoryPoint::_InternalParse;
        object = msg->mutable_target_point();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SimplePIDLatLonDebug::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:controller.SimplePIDLatLonDebug)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double look_ahead_station = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_look_ahead_station(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &look_ahead_station_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double station_error = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_station_error(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &station_error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double current_speed = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_current_speed(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &current_speed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double current_heading = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {
          HasBitSetters::set_has_current_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &current_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_error = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (41 & 0xFF)) {
          HasBitSetters::set_has_heading_error(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double current_steer_wheel_angle = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (49 & 0xFF)) {
          HasBitSetters::set_has_current_steer_wheel_angle(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &current_steer_wheel_angle_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double speed_cmd = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (57 & 0xFF)) {
          HasBitSetters::set_has_speed_cmd(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &speed_cmd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double steer_angle_cmd = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (65 & 0xFF)) {
          HasBitSetters::set_has_steer_angle_cmd(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_angle_cmd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .points.TrajectoryPoint target_point = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (74 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_target_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:controller.SimplePIDLatLonDebug)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:controller.SimplePIDLatLonDebug)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SimplePIDLatLonDebug::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:controller.SimplePIDLatLonDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double look_ahead_station = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->look_ahead_station(), output);
  }

  // optional double station_error = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->station_error(), output);
  }

  // optional double current_speed = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->current_speed(), output);
  }

  // optional double current_heading = 4;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->current_heading(), output);
  }

  // optional double heading_error = 5;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->heading_error(), output);
  }

  // optional double current_steer_wheel_angle = 6;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->current_steer_wheel_angle(), output);
  }

  // optional double speed_cmd = 7;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->speed_cmd(), output);
  }

  // optional double steer_angle_cmd = 8;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->steer_angle_cmd(), output);
  }

  // optional .points.TrajectoryPoint target_point = 9;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, HasBitSetters::target_point(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:controller.SimplePIDLatLonDebug)
}

::google::protobuf::uint8* SimplePIDLatLonDebug::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:controller.SimplePIDLatLonDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double look_ahead_station = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->look_ahead_station(), target);
  }

  // optional double station_error = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->station_error(), target);
  }

  // optional double current_speed = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->current_speed(), target);
  }

  // optional double current_heading = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->current_heading(), target);
  }

  // optional double heading_error = 5;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->heading_error(), target);
  }

  // optional double current_steer_wheel_angle = 6;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->current_steer_wheel_angle(), target);
  }

  // optional double speed_cmd = 7;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->speed_cmd(), target);
  }

  // optional double steer_angle_cmd = 8;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->steer_angle_cmd(), target);
  }

  // optional .points.TrajectoryPoint target_point = 9;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, HasBitSetters::target_point(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:controller.SimplePIDLatLonDebug)
  return target;
}

size_t SimplePIDLatLonDebug::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:controller.SimplePIDLatLonDebug)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .points.TrajectoryPoint target_point = 9;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *target_point_);
    }

    // optional double look_ahead_station = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double station_error = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double current_speed = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double current_heading = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double heading_error = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double current_steer_wheel_angle = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double speed_cmd = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  // optional double steer_angle_cmd = 8;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SimplePIDLatLonDebug::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:controller.SimplePIDLatLonDebug)
  GOOGLE_DCHECK_NE(&from, this);
  const SimplePIDLatLonDebug* source =
      ::google::protobuf::DynamicCastToGenerated<SimplePIDLatLonDebug>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:controller.SimplePIDLatLonDebug)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:controller.SimplePIDLatLonDebug)
    MergeFrom(*source);
  }
}

void SimplePIDLatLonDebug::MergeFrom(const SimplePIDLatLonDebug& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:controller.SimplePIDLatLonDebug)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_target_point()->::points::TrajectoryPoint::MergeFrom(from.target_point());
    }
    if (cached_has_bits & 0x00000002u) {
      look_ahead_station_ = from.look_ahead_station_;
    }
    if (cached_has_bits & 0x00000004u) {
      station_error_ = from.station_error_;
    }
    if (cached_has_bits & 0x00000008u) {
      current_speed_ = from.current_speed_;
    }
    if (cached_has_bits & 0x00000010u) {
      current_heading_ = from.current_heading_;
    }
    if (cached_has_bits & 0x00000020u) {
      heading_error_ = from.heading_error_;
    }
    if (cached_has_bits & 0x00000040u) {
      current_steer_wheel_angle_ = from.current_steer_wheel_angle_;
    }
    if (cached_has_bits & 0x00000080u) {
      speed_cmd_ = from.speed_cmd_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_steer_angle_cmd(from.steer_angle_cmd());
  }
}

void SimplePIDLatLonDebug::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:controller.SimplePIDLatLonDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SimplePIDLatLonDebug::CopyFrom(const SimplePIDLatLonDebug& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:controller.SimplePIDLatLonDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimplePIDLatLonDebug::IsInitialized() const {
  return true;
}

void SimplePIDLatLonDebug::Swap(SimplePIDLatLonDebug* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SimplePIDLatLonDebug::InternalSwap(SimplePIDLatLonDebug* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(target_point_, other->target_point_);
  swap(look_ahead_station_, other->look_ahead_station_);
  swap(station_error_, other->station_error_);
  swap(current_speed_, other->current_speed_);
  swap(current_heading_, other->current_heading_);
  swap(heading_error_, other->heading_error_);
  swap(current_steer_wheel_angle_, other->current_steer_wheel_angle_);
  swap(speed_cmd_, other->speed_cmd_);
  swap(steer_angle_cmd_, other->steer_angle_cmd_);
}

::google::protobuf::Metadata SimplePIDLatLonDebug::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_control_5fcmd_2eproto);
  return ::file_level_metadata_control_5fcmd_2eproto[kIndexInFileMessages];
}


// ===================================================================

void MracDebug::InitAsDefaultInstance() {
  ::controller::_MracDebug_default_instance_._instance.get_mutable()->mrac_adaptive_gain_ = const_cast< ::controller::MracAdaptiveGain*>(
      ::controller::MracAdaptiveGain::internal_default_instance());
}
class MracDebug::HasBitSetters {
 public:
  static void set_has_mrac_model_order(MracDebug* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::controller::MracAdaptiveGain& mrac_adaptive_gain(const MracDebug* msg);
  static void set_has_mrac_adaptive_gain(MracDebug* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_mrac_reference_saturation_status(MracDebug* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_mrac_control_saturation_status(MracDebug* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

const ::controller::MracAdaptiveGain&
MracDebug::HasBitSetters::mrac_adaptive_gain(const MracDebug* msg) {
  return *msg->mrac_adaptive_gain_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MracDebug::kMracModelOrderFieldNumber;
const int MracDebug::kMracReferenceStateFieldNumber;
const int MracDebug::kMracStateErrorFieldNumber;
const int MracDebug::kMracAdaptiveGainFieldNumber;
const int MracDebug::kMracReferenceSaturationStatusFieldNumber;
const int MracDebug::kMracControlSaturationStatusFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MracDebug::MracDebug()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:controller.MracDebug)
}
MracDebug::MracDebug(const MracDebug& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      mrac_reference_state_(from.mrac_reference_state_),
      mrac_state_error_(from.mrac_state_error_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_mrac_adaptive_gain()) {
    mrac_adaptive_gain_ = new ::controller::MracAdaptiveGain(*from.mrac_adaptive_gain_);
  } else {
    mrac_adaptive_gain_ = nullptr;
  }
  ::memcpy(&mrac_model_order_, &from.mrac_model_order_,
    static_cast<size_t>(reinterpret_cast<char*>(&mrac_control_saturation_status_) -
    reinterpret_cast<char*>(&mrac_model_order_)) + sizeof(mrac_control_saturation_status_));
  // @@protoc_insertion_point(copy_constructor:controller.MracDebug)
}

void MracDebug::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_MracDebug_control_5fcmd_2eproto.base);
  ::memset(&mrac_adaptive_gain_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mrac_control_saturation_status_) -
      reinterpret_cast<char*>(&mrac_adaptive_gain_)) + sizeof(mrac_control_saturation_status_));
}

MracDebug::~MracDebug() {
  // @@protoc_insertion_point(destructor:controller.MracDebug)
  SharedDtor();
}

void MracDebug::SharedDtor() {
  if (this != internal_default_instance()) delete mrac_adaptive_gain_;
}

void MracDebug::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MracDebug& MracDebug::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_MracDebug_control_5fcmd_2eproto.base);
  return *internal_default_instance();
}


void MracDebug::Clear() {
// @@protoc_insertion_point(message_clear_start:controller.MracDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mrac_reference_state_.Clear();
  mrac_state_error_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(mrac_adaptive_gain_ != nullptr);
    mrac_adaptive_gain_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&mrac_model_order_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mrac_control_saturation_status_) -
        reinterpret_cast<char*>(&mrac_model_order_)) + sizeof(mrac_control_saturation_status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MracDebug::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<MracDebug*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional int32 mrac_model_order = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_mrac_model_order(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated double mrac_reference_state = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) == 17) {
          do {
            msg->add_mrac_reference_state(::google::protobuf::io::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 17 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedDoubleParser;
        object = msg->mutable_mrac_reference_state();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated double mrac_state_error = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) == 25) {
          do {
            msg->add_mrac_state_error(::google::protobuf::io::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 25 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedDoubleParser;
        object = msg->mutable_mrac_state_error();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // optional .controller.MracAdaptiveGain mrac_adaptive_gain = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::controller::MracAdaptiveGain::_InternalParse;
        object = msg->mutable_mrac_adaptive_gain();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional int32 mrac_reference_saturation_status = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_mrac_reference_saturation_status(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 mrac_control_saturation_status = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        msg->set_mrac_control_saturation_status(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MracDebug::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:controller.MracDebug)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 mrac_model_order = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_mrac_model_order(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mrac_model_order_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double mrac_reference_state = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 17u, input, this->mutable_mrac_reference_state())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_mrac_reference_state())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double mrac_state_error = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 25u, input, this->mutable_mrac_state_error())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_mrac_state_error())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .controller.MracAdaptiveGain mrac_adaptive_gain = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_mrac_adaptive_gain()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 mrac_reference_saturation_status = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_mrac_reference_saturation_status(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mrac_reference_saturation_status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 mrac_control_saturation_status = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_mrac_control_saturation_status(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mrac_control_saturation_status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:controller.MracDebug)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:controller.MracDebug)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MracDebug::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:controller.MracDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 mrac_model_order = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->mrac_model_order(), output);
  }

  // repeated double mrac_reference_state = 2;
  for (int i = 0, n = this->mrac_reference_state_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      2, this->mrac_reference_state(i), output);
  }

  // repeated double mrac_state_error = 3;
  for (int i = 0, n = this->mrac_state_error_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      3, this->mrac_state_error(i), output);
  }

  // optional .controller.MracAdaptiveGain mrac_adaptive_gain = 4;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::mrac_adaptive_gain(this), output);
  }

  // optional int32 mrac_reference_saturation_status = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->mrac_reference_saturation_status(), output);
  }

  // optional int32 mrac_control_saturation_status = 6;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->mrac_control_saturation_status(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:controller.MracDebug)
}

::google::protobuf::uint8* MracDebug::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:controller.MracDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 mrac_model_order = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->mrac_model_order(), target);
  }

  // repeated double mrac_reference_state = 2;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(2, this->mrac_reference_state_, target);

  // repeated double mrac_state_error = 3;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(3, this->mrac_state_error_, target);

  // optional .controller.MracAdaptiveGain mrac_adaptive_gain = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::mrac_adaptive_gain(this), target);
  }

  // optional int32 mrac_reference_saturation_status = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->mrac_reference_saturation_status(), target);
  }

  // optional int32 mrac_control_saturation_status = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->mrac_control_saturation_status(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:controller.MracDebug)
  return target;
}

size_t MracDebug::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:controller.MracDebug)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double mrac_reference_state = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->mrac_reference_state_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->mrac_reference_state_size());
    total_size += data_size;
  }

  // repeated double mrac_state_error = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->mrac_state_error_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->mrac_state_error_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .controller.MracAdaptiveGain mrac_adaptive_gain = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *mrac_adaptive_gain_);
    }

    // optional int32 mrac_model_order = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mrac_model_order());
    }

    // optional int32 mrac_reference_saturation_status = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mrac_reference_saturation_status());
    }

    // optional int32 mrac_control_saturation_status = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mrac_control_saturation_status());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MracDebug::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:controller.MracDebug)
  GOOGLE_DCHECK_NE(&from, this);
  const MracDebug* source =
      ::google::protobuf::DynamicCastToGenerated<MracDebug>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:controller.MracDebug)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:controller.MracDebug)
    MergeFrom(*source);
  }
}

void MracDebug::MergeFrom(const MracDebug& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:controller.MracDebug)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  mrac_reference_state_.MergeFrom(from.mrac_reference_state_);
  mrac_state_error_.MergeFrom(from.mrac_state_error_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_mrac_adaptive_gain()->::controller::MracAdaptiveGain::MergeFrom(from.mrac_adaptive_gain());
    }
    if (cached_has_bits & 0x00000002u) {
      mrac_model_order_ = from.mrac_model_order_;
    }
    if (cached_has_bits & 0x00000004u) {
      mrac_reference_saturation_status_ = from.mrac_reference_saturation_status_;
    }
    if (cached_has_bits & 0x00000008u) {
      mrac_control_saturation_status_ = from.mrac_control_saturation_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MracDebug::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:controller.MracDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MracDebug::CopyFrom(const MracDebug& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:controller.MracDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MracDebug::IsInitialized() const {
  return true;
}

void MracDebug::Swap(MracDebug* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MracDebug::InternalSwap(MracDebug* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  mrac_reference_state_.InternalSwap(&other->mrac_reference_state_);
  mrac_state_error_.InternalSwap(&other->mrac_state_error_);
  swap(mrac_adaptive_gain_, other->mrac_adaptive_gain_);
  swap(mrac_model_order_, other->mrac_model_order_);
  swap(mrac_reference_saturation_status_, other->mrac_reference_saturation_status_);
  swap(mrac_control_saturation_status_, other->mrac_control_saturation_status_);
}

::google::protobuf::Metadata MracDebug::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_control_5fcmd_2eproto);
  return ::file_level_metadata_control_5fcmd_2eproto[kIndexInFileMessages];
}


// ===================================================================

void MracAdaptiveGain::InitAsDefaultInstance() {
}
class MracAdaptiveGain::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MracAdaptiveGain::kStateAdaptiveGainFieldNumber;
const int MracAdaptiveGain::kInputAdaptiveGainFieldNumber;
const int MracAdaptiveGain::kNonlinearAdaptiveGainFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MracAdaptiveGain::MracAdaptiveGain()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:controller.MracAdaptiveGain)
}
MracAdaptiveGain::MracAdaptiveGain(const MracAdaptiveGain& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      state_adaptive_gain_(from.state_adaptive_gain_),
      input_adaptive_gain_(from.input_adaptive_gain_),
      nonlinear_adaptive_gain_(from.nonlinear_adaptive_gain_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:controller.MracAdaptiveGain)
}

void MracAdaptiveGain::SharedCtor() {
}

MracAdaptiveGain::~MracAdaptiveGain() {
  // @@protoc_insertion_point(destructor:controller.MracAdaptiveGain)
  SharedDtor();
}

void MracAdaptiveGain::SharedDtor() {
}

void MracAdaptiveGain::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MracAdaptiveGain& MracAdaptiveGain::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_MracAdaptiveGain_control_5fcmd_2eproto.base);
  return *internal_default_instance();
}


void MracAdaptiveGain::Clear() {
// @@protoc_insertion_point(message_clear_start:controller.MracAdaptiveGain)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  state_adaptive_gain_.Clear();
  input_adaptive_gain_.Clear();
  nonlinear_adaptive_gain_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MracAdaptiveGain::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<MracAdaptiveGain*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated double state_adaptive_gain = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 9) {
          do {
            msg->add_state_adaptive_gain(::google::protobuf::io::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 9 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedDoubleParser;
        object = msg->mutable_state_adaptive_gain();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated double input_adaptive_gain = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) == 17) {
          do {
            msg->add_input_adaptive_gain(::google::protobuf::io::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 17 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedDoubleParser;
        object = msg->mutable_input_adaptive_gain();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // repeated double nonlinear_adaptive_gain = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) == 25) {
          do {
            msg->add_nonlinear_adaptive_gain(::google::protobuf::io::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 25 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedDoubleParser;
        object = msg->mutable_nonlinear_adaptive_gain();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MracAdaptiveGain::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:controller.MracAdaptiveGain)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double state_adaptive_gain = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 9u, input, this->mutable_state_adaptive_gain())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_state_adaptive_gain())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double input_adaptive_gain = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 17u, input, this->mutable_input_adaptive_gain())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_input_adaptive_gain())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double nonlinear_adaptive_gain = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 25u, input, this->mutable_nonlinear_adaptive_gain())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_nonlinear_adaptive_gain())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:controller.MracAdaptiveGain)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:controller.MracAdaptiveGain)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MracAdaptiveGain::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:controller.MracAdaptiveGain)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double state_adaptive_gain = 1;
  for (int i = 0, n = this->state_adaptive_gain_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      1, this->state_adaptive_gain(i), output);
  }

  // repeated double input_adaptive_gain = 2;
  for (int i = 0, n = this->input_adaptive_gain_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      2, this->input_adaptive_gain(i), output);
  }

  // repeated double nonlinear_adaptive_gain = 3;
  for (int i = 0, n = this->nonlinear_adaptive_gain_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      3, this->nonlinear_adaptive_gain(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:controller.MracAdaptiveGain)
}

::google::protobuf::uint8* MracAdaptiveGain::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:controller.MracAdaptiveGain)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double state_adaptive_gain = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(1, this->state_adaptive_gain_, target);

  // repeated double input_adaptive_gain = 2;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(2, this->input_adaptive_gain_, target);

  // repeated double nonlinear_adaptive_gain = 3;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(3, this->nonlinear_adaptive_gain_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:controller.MracAdaptiveGain)
  return target;
}

size_t MracAdaptiveGain::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:controller.MracAdaptiveGain)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double state_adaptive_gain = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->state_adaptive_gain_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->state_adaptive_gain_size());
    total_size += data_size;
  }

  // repeated double input_adaptive_gain = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->input_adaptive_gain_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->input_adaptive_gain_size());
    total_size += data_size;
  }

  // repeated double nonlinear_adaptive_gain = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->nonlinear_adaptive_gain_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->nonlinear_adaptive_gain_size());
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MracAdaptiveGain::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:controller.MracAdaptiveGain)
  GOOGLE_DCHECK_NE(&from, this);
  const MracAdaptiveGain* source =
      ::google::protobuf::DynamicCastToGenerated<MracAdaptiveGain>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:controller.MracAdaptiveGain)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:controller.MracAdaptiveGain)
    MergeFrom(*source);
  }
}

void MracAdaptiveGain::MergeFrom(const MracAdaptiveGain& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:controller.MracAdaptiveGain)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  state_adaptive_gain_.MergeFrom(from.state_adaptive_gain_);
  input_adaptive_gain_.MergeFrom(from.input_adaptive_gain_);
  nonlinear_adaptive_gain_.MergeFrom(from.nonlinear_adaptive_gain_);
}

void MracAdaptiveGain::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:controller.MracAdaptiveGain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MracAdaptiveGain::CopyFrom(const MracAdaptiveGain& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:controller.MracAdaptiveGain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MracAdaptiveGain::IsInitialized() const {
  return true;
}

void MracAdaptiveGain::Swap(MracAdaptiveGain* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MracAdaptiveGain::InternalSwap(MracAdaptiveGain* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  state_adaptive_gain_.InternalSwap(&other->state_adaptive_gain_);
  input_adaptive_gain_.InternalSwap(&other->input_adaptive_gain_);
  nonlinear_adaptive_gain_.InternalSwap(&other->nonlinear_adaptive_gain_);
}

::google::protobuf::Metadata MracAdaptiveGain::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_control_5fcmd_2eproto);
  return ::file_level_metadata_control_5fcmd_2eproto[kIndexInFileMessages];
}


// ===================================================================

void InputDebug::InitAsDefaultInstance() {
  ::controller::_InputDebug_default_instance_._instance.get_mutable()->localization_header_ = const_cast< ::controller::Header*>(
      ::controller::Header::internal_default_instance());
  ::controller::_InputDebug_default_instance_._instance.get_mutable()->canbus_header_ = const_cast< ::controller::Header*>(
      ::controller::Header::internal_default_instance());
  ::controller::_InputDebug_default_instance_._instance.get_mutable()->trajectory_header_ = const_cast< ::controller::Header*>(
      ::controller::Header::internal_default_instance());
  ::controller::_InputDebug_default_instance_._instance.get_mutable()->latest_replan_trajectory_header_ = const_cast< ::controller::Header*>(
      ::controller::Header::internal_default_instance());
}
class InputDebug::HasBitSetters {
 public:
  static const ::controller::Header& localization_header(const InputDebug* msg);
  static void set_has_localization_header(InputDebug* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::controller::Header& canbus_header(const InputDebug* msg);
  static void set_has_canbus_header(InputDebug* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::controller::Header& trajectory_header(const InputDebug* msg);
  static void set_has_trajectory_header(InputDebug* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::controller::Header& latest_replan_trajectory_header(const InputDebug* msg);
  static void set_has_latest_replan_trajectory_header(InputDebug* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

const ::controller::Header&
InputDebug::HasBitSetters::localization_header(const InputDebug* msg) {
  return *msg->localization_header_;
}
const ::controller::Header&
InputDebug::HasBitSetters::canbus_header(const InputDebug* msg) {
  return *msg->canbus_header_;
}
const ::controller::Header&
InputDebug::HasBitSetters::trajectory_header(const InputDebug* msg) {
  return *msg->trajectory_header_;
}
const ::controller::Header&
InputDebug::HasBitSetters::latest_replan_trajectory_header(const InputDebug* msg) {
  return *msg->latest_replan_trajectory_header_;
}
void InputDebug::clear_localization_header() {
  if (localization_header_ != nullptr) localization_header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void InputDebug::clear_canbus_header() {
  if (canbus_header_ != nullptr) canbus_header_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void InputDebug::clear_trajectory_header() {
  if (trajectory_header_ != nullptr) trajectory_header_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void InputDebug::clear_latest_replan_trajectory_header() {
  if (latest_replan_trajectory_header_ != nullptr) latest_replan_trajectory_header_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InputDebug::kLocalizationHeaderFieldNumber;
const int InputDebug::kCanbusHeaderFieldNumber;
const int InputDebug::kTrajectoryHeaderFieldNumber;
const int InputDebug::kLatestReplanTrajectoryHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InputDebug::InputDebug()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:controller.InputDebug)
}
InputDebug::InputDebug(const InputDebug& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_localization_header()) {
    localization_header_ = new ::controller::Header(*from.localization_header_);
  } else {
    localization_header_ = nullptr;
  }
  if (from.has_canbus_header()) {
    canbus_header_ = new ::controller::Header(*from.canbus_header_);
  } else {
    canbus_header_ = nullptr;
  }
  if (from.has_trajectory_header()) {
    trajectory_header_ = new ::controller::Header(*from.trajectory_header_);
  } else {
    trajectory_header_ = nullptr;
  }
  if (from.has_latest_replan_trajectory_header()) {
    latest_replan_trajectory_header_ = new ::controller::Header(*from.latest_replan_trajectory_header_);
  } else {
    latest_replan_trajectory_header_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:controller.InputDebug)
}

void InputDebug::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_InputDebug_control_5fcmd_2eproto.base);
  ::memset(&localization_header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&latest_replan_trajectory_header_) -
      reinterpret_cast<char*>(&localization_header_)) + sizeof(latest_replan_trajectory_header_));
}

InputDebug::~InputDebug() {
  // @@protoc_insertion_point(destructor:controller.InputDebug)
  SharedDtor();
}

void InputDebug::SharedDtor() {
  if (this != internal_default_instance()) delete localization_header_;
  if (this != internal_default_instance()) delete canbus_header_;
  if (this != internal_default_instance()) delete trajectory_header_;
  if (this != internal_default_instance()) delete latest_replan_trajectory_header_;
}

void InputDebug::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const InputDebug& InputDebug::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_InputDebug_control_5fcmd_2eproto.base);
  return *internal_default_instance();
}


void InputDebug::Clear() {
// @@protoc_insertion_point(message_clear_start:controller.InputDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(localization_header_ != nullptr);
      localization_header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(canbus_header_ != nullptr);
      canbus_header_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(trajectory_header_ != nullptr);
      trajectory_header_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(latest_replan_trajectory_header_ != nullptr);
      latest_replan_trajectory_header_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* InputDebug::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<InputDebug*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .controller.Header localization_header = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::controller::Header::_InternalParse;
        object = msg->mutable_localization_header();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .controller.Header canbus_header = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::controller::Header::_InternalParse;
        object = msg->mutable_canbus_header();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .controller.Header trajectory_header = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::controller::Header::_InternalParse;
        object = msg->mutable_trajectory_header();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .controller.Header latest_replan_trajectory_header = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::controller::Header::_InternalParse;
        object = msg->mutable_latest_replan_trajectory_header();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool InputDebug::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:controller.InputDebug)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .controller.Header localization_header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_localization_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .controller.Header canbus_header = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_canbus_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .controller.Header trajectory_header = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_trajectory_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .controller.Header latest_replan_trajectory_header = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_latest_replan_trajectory_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:controller.InputDebug)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:controller.InputDebug)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void InputDebug::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:controller.InputDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .controller.Header localization_header = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::localization_header(this), output);
  }

  // optional .controller.Header canbus_header = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::canbus_header(this), output);
  }

  // optional .controller.Header trajectory_header = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::trajectory_header(this), output);
  }

  // optional .controller.Header latest_replan_trajectory_header = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::latest_replan_trajectory_header(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:controller.InputDebug)
}

::google::protobuf::uint8* InputDebug::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:controller.InputDebug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .controller.Header localization_header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::localization_header(this), target);
  }

  // optional .controller.Header canbus_header = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::canbus_header(this), target);
  }

  // optional .controller.Header trajectory_header = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::trajectory_header(this), target);
  }

  // optional .controller.Header latest_replan_trajectory_header = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::latest_replan_trajectory_header(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:controller.InputDebug)
  return target;
}

size_t InputDebug::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:controller.InputDebug)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .controller.Header localization_header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *localization_header_);
    }

    // optional .controller.Header canbus_header = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *canbus_header_);
    }

    // optional .controller.Header trajectory_header = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *trajectory_header_);
    }

    // optional .controller.Header latest_replan_trajectory_header = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *latest_replan_trajectory_header_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InputDebug::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:controller.InputDebug)
  GOOGLE_DCHECK_NE(&from, this);
  const InputDebug* source =
      ::google::protobuf::DynamicCastToGenerated<InputDebug>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:controller.InputDebug)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:controller.InputDebug)
    MergeFrom(*source);
  }
}

void InputDebug::MergeFrom(const InputDebug& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:controller.InputDebug)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_localization_header()->::controller::Header::MergeFrom(from.localization_header());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_canbus_header()->::controller::Header::MergeFrom(from.canbus_header());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_trajectory_header()->::controller::Header::MergeFrom(from.trajectory_header());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_latest_replan_trajectory_header()->::controller::Header::MergeFrom(from.latest_replan_trajectory_header());
    }
  }
}

void InputDebug::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:controller.InputDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InputDebug::CopyFrom(const InputDebug& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:controller.InputDebug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InputDebug::IsInitialized() const {
  return true;
}

void InputDebug::Swap(InputDebug* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InputDebug::InternalSwap(InputDebug* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(localization_header_, other->localization_header_);
  swap(canbus_header_, other->canbus_header_);
  swap(trajectory_header_, other->trajectory_header_);
  swap(latest_replan_trajectory_header_, other->latest_replan_trajectory_header_);
}

::google::protobuf::Metadata InputDebug::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_control_5fcmd_2eproto);
  return ::file_level_metadata_control_5fcmd_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Debug::InitAsDefaultInstance() {
  ::controller::_Debug_default_instance_._instance.get_mutable()->simple_lon_debug_ = const_cast< ::controller::SimpleLongitudinalDebug*>(
      ::controller::SimpleLongitudinalDebug::internal_default_instance());
  ::controller::_Debug_default_instance_._instance.get_mutable()->simple_lat_debug_ = const_cast< ::controller::SimpleLateralDebug*>(
      ::controller::SimpleLateralDebug::internal_default_instance());
  ::controller::_Debug_default_instance_._instance.get_mutable()->input_debug_ = const_cast< ::controller::InputDebug*>(
      ::controller::InputDebug::internal_default_instance());
  ::controller::_Debug_default_instance_._instance.get_mutable()->simple_mpc_debug_ = const_cast< ::controller::SimpleMPCDebug*>(
      ::controller::SimpleMPCDebug::internal_default_instance());
  ::controller::_Debug_default_instance_._instance.get_mutable()->simple_pid_lat_lon_debug_ = const_cast< ::controller::SimplePIDLatLonDebug*>(
      ::controller::SimplePIDLatLonDebug::internal_default_instance());
}
class Debug::HasBitSetters {
 public:
  static const ::controller::SimpleLongitudinalDebug& simple_lon_debug(const Debug* msg);
  static void set_has_simple_lon_debug(Debug* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::controller::SimpleLateralDebug& simple_lat_debug(const Debug* msg);
  static void set_has_simple_lat_debug(Debug* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::controller::InputDebug& input_debug(const Debug* msg);
  static void set_has_input_debug(Debug* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::controller::SimpleMPCDebug& simple_mpc_debug(const Debug* msg);
  static void set_has_simple_mpc_debug(Debug* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static const ::controller::SimplePIDLatLonDebug& simple_pid_lat_lon_debug(const Debug* msg);
  static void set_has_simple_pid_lat_lon_debug(Debug* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

const ::controller::SimpleLongitudinalDebug&
Debug::HasBitSetters::simple_lon_debug(const Debug* msg) {
  return *msg->simple_lon_debug_;
}
const ::controller::SimpleLateralDebug&
Debug::HasBitSetters::simple_lat_debug(const Debug* msg) {
  return *msg->simple_lat_debug_;
}
const ::controller::InputDebug&
Debug::HasBitSetters::input_debug(const Debug* msg) {
  return *msg->input_debug_;
}
const ::controller::SimpleMPCDebug&
Debug::HasBitSetters::simple_mpc_debug(const Debug* msg) {
  return *msg->simple_mpc_debug_;
}
const ::controller::SimplePIDLatLonDebug&
Debug::HasBitSetters::simple_pid_lat_lon_debug(const Debug* msg) {
  return *msg->simple_pid_lat_lon_debug_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Debug::kSimpleLonDebugFieldNumber;
const int Debug::kSimpleLatDebugFieldNumber;
const int Debug::kInputDebugFieldNumber;
const int Debug::kSimpleMpcDebugFieldNumber;
const int Debug::kSimplePidLatLonDebugFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Debug::Debug()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:controller.Debug)
}
Debug::Debug(const Debug& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_simple_lon_debug()) {
    simple_lon_debug_ = new ::controller::SimpleLongitudinalDebug(*from.simple_lon_debug_);
  } else {
    simple_lon_debug_ = nullptr;
  }
  if (from.has_simple_lat_debug()) {
    simple_lat_debug_ = new ::controller::SimpleLateralDebug(*from.simple_lat_debug_);
  } else {
    simple_lat_debug_ = nullptr;
  }
  if (from.has_input_debug()) {
    input_debug_ = new ::controller::InputDebug(*from.input_debug_);
  } else {
    input_debug_ = nullptr;
  }
  if (from.has_simple_mpc_debug()) {
    simple_mpc_debug_ = new ::controller::SimpleMPCDebug(*from.simple_mpc_debug_);
  } else {
    simple_mpc_debug_ = nullptr;
  }
  if (from.has_simple_pid_lat_lon_debug()) {
    simple_pid_lat_lon_debug_ = new ::controller::SimplePIDLatLonDebug(*from.simple_pid_lat_lon_debug_);
  } else {
    simple_pid_lat_lon_debug_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:controller.Debug)
}

void Debug::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Debug_control_5fcmd_2eproto.base);
  ::memset(&simple_lon_debug_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&simple_pid_lat_lon_debug_) -
      reinterpret_cast<char*>(&simple_lon_debug_)) + sizeof(simple_pid_lat_lon_debug_));
}

Debug::~Debug() {
  // @@protoc_insertion_point(destructor:controller.Debug)
  SharedDtor();
}

void Debug::SharedDtor() {
  if (this != internal_default_instance()) delete simple_lon_debug_;
  if (this != internal_default_instance()) delete simple_lat_debug_;
  if (this != internal_default_instance()) delete input_debug_;
  if (this != internal_default_instance()) delete simple_mpc_debug_;
  if (this != internal_default_instance()) delete simple_pid_lat_lon_debug_;
}

void Debug::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Debug& Debug::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Debug_control_5fcmd_2eproto.base);
  return *internal_default_instance();
}


void Debug::Clear() {
// @@protoc_insertion_point(message_clear_start:controller.Debug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(simple_lon_debug_ != nullptr);
      simple_lon_debug_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(simple_lat_debug_ != nullptr);
      simple_lat_debug_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(input_debug_ != nullptr);
      input_debug_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(simple_mpc_debug_ != nullptr);
      simple_mpc_debug_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(simple_pid_lat_lon_debug_ != nullptr);
      simple_pid_lat_lon_debug_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Debug::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Debug*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .controller.SimpleLongitudinalDebug simple_lon_debug = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::controller::SimpleLongitudinalDebug::_InternalParse;
        object = msg->mutable_simple_lon_debug();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .controller.SimpleLateralDebug simple_lat_debug = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::controller::SimpleLateralDebug::_InternalParse;
        object = msg->mutable_simple_lat_debug();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .controller.InputDebug input_debug = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::controller::InputDebug::_InternalParse;
        object = msg->mutable_input_debug();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .controller.SimpleMPCDebug simple_mpc_debug = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::controller::SimpleMPCDebug::_InternalParse;
        object = msg->mutable_simple_mpc_debug();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .controller.SimplePIDLatLonDebug simple_pid_lat_lon_debug = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::controller::SimplePIDLatLonDebug::_InternalParse;
        object = msg->mutable_simple_pid_lat_lon_debug();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Debug::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:controller.Debug)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .controller.SimpleLongitudinalDebug simple_lon_debug = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_simple_lon_debug()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .controller.SimpleLateralDebug simple_lat_debug = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_simple_lat_debug()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .controller.InputDebug input_debug = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_input_debug()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .controller.SimpleMPCDebug simple_mpc_debug = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_simple_mpc_debug()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .controller.SimplePIDLatLonDebug simple_pid_lat_lon_debug = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_simple_pid_lat_lon_debug()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:controller.Debug)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:controller.Debug)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Debug::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:controller.Debug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .controller.SimpleLongitudinalDebug simple_lon_debug = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::simple_lon_debug(this), output);
  }

  // optional .controller.SimpleLateralDebug simple_lat_debug = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::simple_lat_debug(this), output);
  }

  // optional .controller.InputDebug input_debug = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::input_debug(this), output);
  }

  // optional .controller.SimpleMPCDebug simple_mpc_debug = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::simple_mpc_debug(this), output);
  }

  // optional .controller.SimplePIDLatLonDebug simple_pid_lat_lon_debug = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, HasBitSetters::simple_pid_lat_lon_debug(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:controller.Debug)
}

::google::protobuf::uint8* Debug::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:controller.Debug)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .controller.SimpleLongitudinalDebug simple_lon_debug = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::simple_lon_debug(this), target);
  }

  // optional .controller.SimpleLateralDebug simple_lat_debug = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::simple_lat_debug(this), target);
  }

  // optional .controller.InputDebug input_debug = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::input_debug(this), target);
  }

  // optional .controller.SimpleMPCDebug simple_mpc_debug = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::simple_mpc_debug(this), target);
  }

  // optional .controller.SimplePIDLatLonDebug simple_pid_lat_lon_debug = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, HasBitSetters::simple_pid_lat_lon_debug(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:controller.Debug)
  return target;
}

size_t Debug::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:controller.Debug)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .controller.SimpleLongitudinalDebug simple_lon_debug = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *simple_lon_debug_);
    }

    // optional .controller.SimpleLateralDebug simple_lat_debug = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *simple_lat_debug_);
    }

    // optional .controller.InputDebug input_debug = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *input_debug_);
    }

    // optional .controller.SimpleMPCDebug simple_mpc_debug = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *simple_mpc_debug_);
    }

    // optional .controller.SimplePIDLatLonDebug simple_pid_lat_lon_debug = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *simple_pid_lat_lon_debug_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Debug::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:controller.Debug)
  GOOGLE_DCHECK_NE(&from, this);
  const Debug* source =
      ::google::protobuf::DynamicCastToGenerated<Debug>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:controller.Debug)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:controller.Debug)
    MergeFrom(*source);
  }
}

void Debug::MergeFrom(const Debug& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:controller.Debug)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_simple_lon_debug()->::controller::SimpleLongitudinalDebug::MergeFrom(from.simple_lon_debug());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_simple_lat_debug()->::controller::SimpleLateralDebug::MergeFrom(from.simple_lat_debug());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_input_debug()->::controller::InputDebug::MergeFrom(from.input_debug());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_simple_mpc_debug()->::controller::SimpleMPCDebug::MergeFrom(from.simple_mpc_debug());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_simple_pid_lat_lon_debug()->::controller::SimplePIDLatLonDebug::MergeFrom(from.simple_pid_lat_lon_debug());
    }
  }
}

void Debug::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:controller.Debug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Debug::CopyFrom(const Debug& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:controller.Debug)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Debug::IsInitialized() const {
  return true;
}

void Debug::Swap(Debug* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Debug::InternalSwap(Debug* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(simple_lon_debug_, other->simple_lon_debug_);
  swap(simple_lat_debug_, other->simple_lat_debug_);
  swap(input_debug_, other->input_debug_);
  swap(simple_mpc_debug_, other->simple_mpc_debug_);
  swap(simple_pid_lat_lon_debug_, other->simple_pid_lat_lon_debug_);
}

::google::protobuf::Metadata Debug::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_control_5fcmd_2eproto);
  return ::file_level_metadata_control_5fcmd_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace controller
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::controller::LatencyStats* Arena::CreateMaybeMessage< ::controller::LatencyStats >(Arena* arena) {
  return Arena::CreateInternal< ::controller::LatencyStats >(arena);
}
template<> PROTOBUF_NOINLINE ::controller::ControlCommand* Arena::CreateMaybeMessage< ::controller::ControlCommand >(Arena* arena) {
  return Arena::CreateInternal< ::controller::ControlCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::controller::SimpleLongitudinalDebug* Arena::CreateMaybeMessage< ::controller::SimpleLongitudinalDebug >(Arena* arena) {
  return Arena::CreateInternal< ::controller::SimpleLongitudinalDebug >(arena);
}
template<> PROTOBUF_NOINLINE ::controller::SimpleLateralDebug* Arena::CreateMaybeMessage< ::controller::SimpleLateralDebug >(Arena* arena) {
  return Arena::CreateInternal< ::controller::SimpleLateralDebug >(arena);
}
template<> PROTOBUF_NOINLINE ::controller::SimpleMPCDebug* Arena::CreateMaybeMessage< ::controller::SimpleMPCDebug >(Arena* arena) {
  return Arena::CreateInternal< ::controller::SimpleMPCDebug >(arena);
}
template<> PROTOBUF_NOINLINE ::controller::SimplePIDLatLonDebug* Arena::CreateMaybeMessage< ::controller::SimplePIDLatLonDebug >(Arena* arena) {
  return Arena::CreateInternal< ::controller::SimplePIDLatLonDebug >(arena);
}
template<> PROTOBUF_NOINLINE ::controller::MracDebug* Arena::CreateMaybeMessage< ::controller::MracDebug >(Arena* arena) {
  return Arena::CreateInternal< ::controller::MracDebug >(arena);
}
template<> PROTOBUF_NOINLINE ::controller::MracAdaptiveGain* Arena::CreateMaybeMessage< ::controller::MracAdaptiveGain >(Arena* arena) {
  return Arena::CreateInternal< ::controller::MracAdaptiveGain >(arena);
}
template<> PROTOBUF_NOINLINE ::controller::InputDebug* Arena::CreateMaybeMessage< ::controller::InputDebug >(Arena* arena) {
  return Arena::CreateInternal< ::controller::InputDebug >(arena);
}
template<> PROTOBUF_NOINLINE ::controller::Debug* Arena::CreateMaybeMessage< ::controller::Debug >(Arena* arena) {
  return Arena::CreateInternal< ::controller::Debug >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
