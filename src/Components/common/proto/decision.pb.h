// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: decision.proto

#ifndef PROTOBUF_INCLUDED_decision_2eproto
#define PROTOBUF_INCLUDED_decision_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "geometry.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_decision_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_decision_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_decision_2eproto();
namespace decision {
class ObjectAvoid;
class ObjectAvoidDefaultTypeInternal;
extern ObjectAvoidDefaultTypeInternal _ObjectAvoid_default_instance_;
class ObjectDecisionType;
class ObjectDecisionTypeDefaultTypeInternal;
extern ObjectDecisionTypeDefaultTypeInternal _ObjectDecisionType_default_instance_;
class ObjectDynamic;
class ObjectDynamicDefaultTypeInternal;
extern ObjectDynamicDefaultTypeInternal _ObjectDynamic_default_instance_;
class ObjectFollow;
class ObjectFollowDefaultTypeInternal;
extern ObjectFollowDefaultTypeInternal _ObjectFollow_default_instance_;
class ObjectIgnore;
class ObjectIgnoreDefaultTypeInternal;
extern ObjectIgnoreDefaultTypeInternal _ObjectIgnore_default_instance_;
class ObjectMotionType;
class ObjectMotionTypeDefaultTypeInternal;
extern ObjectMotionTypeDefaultTypeInternal _ObjectMotionType_default_instance_;
class ObjectNudge;
class ObjectNudgeDefaultTypeInternal;
extern ObjectNudgeDefaultTypeInternal _ObjectNudge_default_instance_;
class ObjectOvertake;
class ObjectOvertakeDefaultTypeInternal;
extern ObjectOvertakeDefaultTypeInternal _ObjectOvertake_default_instance_;
class ObjectSidePass;
class ObjectSidePassDefaultTypeInternal;
extern ObjectSidePassDefaultTypeInternal _ObjectSidePass_default_instance_;
class ObjectStatic;
class ObjectStaticDefaultTypeInternal;
extern ObjectStaticDefaultTypeInternal _ObjectStatic_default_instance_;
class ObjectStatus;
class ObjectStatusDefaultTypeInternal;
extern ObjectStatusDefaultTypeInternal _ObjectStatus_default_instance_;
class ObjectStop;
class ObjectStopDefaultTypeInternal;
extern ObjectStopDefaultTypeInternal _ObjectStop_default_instance_;
class ObjectYield;
class ObjectYieldDefaultTypeInternal;
extern ObjectYieldDefaultTypeInternal _ObjectYield_default_instance_;
class TargetLane;
class TargetLaneDefaultTypeInternal;
extern TargetLaneDefaultTypeInternal _TargetLane_default_instance_;
}  // namespace decision
namespace google {
namespace protobuf {
template<> ::decision::ObjectAvoid* Arena::CreateMaybeMessage<::decision::ObjectAvoid>(Arena*);
template<> ::decision::ObjectDecisionType* Arena::CreateMaybeMessage<::decision::ObjectDecisionType>(Arena*);
template<> ::decision::ObjectDynamic* Arena::CreateMaybeMessage<::decision::ObjectDynamic>(Arena*);
template<> ::decision::ObjectFollow* Arena::CreateMaybeMessage<::decision::ObjectFollow>(Arena*);
template<> ::decision::ObjectIgnore* Arena::CreateMaybeMessage<::decision::ObjectIgnore>(Arena*);
template<> ::decision::ObjectMotionType* Arena::CreateMaybeMessage<::decision::ObjectMotionType>(Arena*);
template<> ::decision::ObjectNudge* Arena::CreateMaybeMessage<::decision::ObjectNudge>(Arena*);
template<> ::decision::ObjectOvertake* Arena::CreateMaybeMessage<::decision::ObjectOvertake>(Arena*);
template<> ::decision::ObjectSidePass* Arena::CreateMaybeMessage<::decision::ObjectSidePass>(Arena*);
template<> ::decision::ObjectStatic* Arena::CreateMaybeMessage<::decision::ObjectStatic>(Arena*);
template<> ::decision::ObjectStatus* Arena::CreateMaybeMessage<::decision::ObjectStatus>(Arena*);
template<> ::decision::ObjectStop* Arena::CreateMaybeMessage<::decision::ObjectStop>(Arena*);
template<> ::decision::ObjectYield* Arena::CreateMaybeMessage<::decision::ObjectYield>(Arena*);
template<> ::decision::TargetLane* Arena::CreateMaybeMessage<::decision::TargetLane>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace decision {

enum ObjectNudge_Type {
  ObjectNudge_Type_LEFT_NUDGE = 1,
  ObjectNudge_Type_RIGHT_NUDGE = 2,
  ObjectNudge_Type_DYNAMIC_LEFT_NUDGE = 3,
  ObjectNudge_Type_DYNAMIC_RIGHT_NUDGE = 4
};
bool ObjectNudge_Type_IsValid(int value);
const ObjectNudge_Type ObjectNudge_Type_Type_MIN = ObjectNudge_Type_LEFT_NUDGE;
const ObjectNudge_Type ObjectNudge_Type_Type_MAX = ObjectNudge_Type_DYNAMIC_RIGHT_NUDGE;
const int ObjectNudge_Type_Type_ARRAYSIZE = ObjectNudge_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjectNudge_Type_descriptor();
inline const ::std::string& ObjectNudge_Type_Name(ObjectNudge_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectNudge_Type_descriptor(), value);
}
inline bool ObjectNudge_Type_Parse(
    const ::std::string& name, ObjectNudge_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectNudge_Type>(
    ObjectNudge_Type_descriptor(), name, value);
}
enum ObjectSidePass_Type {
  ObjectSidePass_Type_LEFT = 1,
  ObjectSidePass_Type_RIGHT = 2
};
bool ObjectSidePass_Type_IsValid(int value);
const ObjectSidePass_Type ObjectSidePass_Type_Type_MIN = ObjectSidePass_Type_LEFT;
const ObjectSidePass_Type ObjectSidePass_Type_Type_MAX = ObjectSidePass_Type_RIGHT;
const int ObjectSidePass_Type_Type_ARRAYSIZE = ObjectSidePass_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjectSidePass_Type_descriptor();
inline const ::std::string& ObjectSidePass_Type_Name(ObjectSidePass_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectSidePass_Type_descriptor(), value);
}
inline bool ObjectSidePass_Type_Parse(
    const ::std::string& name, ObjectSidePass_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectSidePass_Type>(
    ObjectSidePass_Type_descriptor(), name, value);
}
enum StopReasonCode {
  STOP_REASON_HEAD_VEHICLE = 1,
  STOP_REASON_DESTINATION = 2,
  STOP_REASON_PEDESTRIAN = 3,
  STOP_REASON_OBSTACLE = 4,
  STOP_REASON_PREPARKING = 5,
  STOP_REASON_SIGNAL = 100,
  STOP_REASON_STOP_SIGN = 101,
  STOP_REASON_YIELD_SIGN = 102,
  STOP_REASON_CLEAR_ZONE = 103,
  STOP_REASON_CROSSWALK = 104,
  STOP_REASON_CREEPER = 105,
  STOP_REASON_REFERENCE_END = 106,
  STOP_REASON_YELLOW_SIGNAL = 107,
  STOP_REASON_PULL_OVER = 108,
  STOP_REASON_SIDEPASS_SAFETY = 109,
  STOP_REASON_PRE_OPEN_SPACE_STOP = 200,
  STOP_REASON_LANE_CHANGE_URGENCY = 201,
  STOP_REASON_EMERGENCY = 202
};
bool StopReasonCode_IsValid(int value);
const StopReasonCode StopReasonCode_MIN = STOP_REASON_HEAD_VEHICLE;
const StopReasonCode StopReasonCode_MAX = STOP_REASON_EMERGENCY;
const int StopReasonCode_ARRAYSIZE = StopReasonCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* StopReasonCode_descriptor();
inline const ::std::string& StopReasonCode_Name(StopReasonCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    StopReasonCode_descriptor(), value);
}
inline bool StopReasonCode_Parse(
    const ::std::string& name, StopReasonCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StopReasonCode>(
    StopReasonCode_descriptor(), name, value);
}
// ===================================================================

class TargetLane :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:decision.TargetLane) */ {
 public:
  TargetLane();
  virtual ~TargetLane();

  TargetLane(const TargetLane& from);

  inline TargetLane& operator=(const TargetLane& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TargetLane(TargetLane&& from) noexcept
    : TargetLane() {
    *this = ::std::move(from);
  }

  inline TargetLane& operator=(TargetLane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TargetLane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TargetLane* internal_default_instance() {
    return reinterpret_cast<const TargetLane*>(
               &_TargetLane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(TargetLane* other);
  friend void swap(TargetLane& a, TargetLane& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TargetLane* New() const final {
    return CreateMaybeMessage<TargetLane>(nullptr);
  }

  TargetLane* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TargetLane>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TargetLane& from);
  void MergeFrom(const TargetLane& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetLane* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional double start_s = 2;
  bool has_start_s() const;
  void clear_start_s();
  static const int kStartSFieldNumber = 2;
  double start_s() const;
  void set_start_s(double value);

  // optional double end_s = 3;
  bool has_end_s() const;
  void clear_end_s();
  static const int kEndSFieldNumber = 3;
  double end_s() const;
  void set_end_s(double value);

  // optional double speed_limit = 4;
  bool has_speed_limit() const;
  void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 4;
  double speed_limit() const;
  void set_speed_limit(double value);

  // @@protoc_insertion_point(class_scope:decision.TargetLane)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  double start_s_;
  double end_s_;
  double speed_limit_;
  friend struct ::TableStruct_decision_2eproto;
};
// -------------------------------------------------------------------

class ObjectIgnore :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:decision.ObjectIgnore) */ {
 public:
  ObjectIgnore();
  virtual ~ObjectIgnore();

  ObjectIgnore(const ObjectIgnore& from);

  inline ObjectIgnore& operator=(const ObjectIgnore& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectIgnore(ObjectIgnore&& from) noexcept
    : ObjectIgnore() {
    *this = ::std::move(from);
  }

  inline ObjectIgnore& operator=(ObjectIgnore&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ObjectIgnore& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectIgnore* internal_default_instance() {
    return reinterpret_cast<const ObjectIgnore*>(
               &_ObjectIgnore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ObjectIgnore* other);
  friend void swap(ObjectIgnore& a, ObjectIgnore& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectIgnore* New() const final {
    return CreateMaybeMessage<ObjectIgnore>(nullptr);
  }

  ObjectIgnore* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectIgnore>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectIgnore& from);
  void MergeFrom(const ObjectIgnore& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectIgnore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:decision.ObjectIgnore)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_decision_2eproto;
};
// -------------------------------------------------------------------

class ObjectStop :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:decision.ObjectStop) */ {
 public:
  ObjectStop();
  virtual ~ObjectStop();

  ObjectStop(const ObjectStop& from);

  inline ObjectStop& operator=(const ObjectStop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectStop(ObjectStop&& from) noexcept
    : ObjectStop() {
    *this = ::std::move(from);
  }

  inline ObjectStop& operator=(ObjectStop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ObjectStop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectStop* internal_default_instance() {
    return reinterpret_cast<const ObjectStop*>(
               &_ObjectStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ObjectStop* other);
  friend void swap(ObjectStop& a, ObjectStop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectStop* New() const final {
    return CreateMaybeMessage<ObjectStop>(nullptr);
  }

  ObjectStop* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectStop>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectStop& from);
  void MergeFrom(const ObjectStop& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectStop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string wait_for_obstacle = 5;
  int wait_for_obstacle_size() const;
  void clear_wait_for_obstacle();
  static const int kWaitForObstacleFieldNumber = 5;
  const ::std::string& wait_for_obstacle(int index) const;
  ::std::string* mutable_wait_for_obstacle(int index);
  void set_wait_for_obstacle(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_wait_for_obstacle(int index, ::std::string&& value);
  #endif
  void set_wait_for_obstacle(int index, const char* value);
  void set_wait_for_obstacle(int index, const char* value, size_t size);
  ::std::string* add_wait_for_obstacle();
  void add_wait_for_obstacle(const ::std::string& value);
  #if LANG_CXX11
  void add_wait_for_obstacle(::std::string&& value);
  #endif
  void add_wait_for_obstacle(const char* value);
  void add_wait_for_obstacle(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& wait_for_obstacle() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_wait_for_obstacle();

  // optional .geometry.PointENU stop_point = 3;
  bool has_stop_point() const;
  void clear_stop_point();
  static const int kStopPointFieldNumber = 3;
  const ::geometry::PointENU& stop_point() const;
  ::geometry::PointENU* release_stop_point();
  ::geometry::PointENU* mutable_stop_point();
  void set_allocated_stop_point(::geometry::PointENU* stop_point);

  // optional double distance_s = 2;
  bool has_distance_s() const;
  void clear_distance_s();
  static const int kDistanceSFieldNumber = 2;
  double distance_s() const;
  void set_distance_s(double value);

  // optional double stop_heading = 4;
  bool has_stop_heading() const;
  void clear_stop_heading();
  static const int kStopHeadingFieldNumber = 4;
  double stop_heading() const;
  void set_stop_heading(double value);

  // optional .decision.StopReasonCode reason_code = 1;
  bool has_reason_code() const;
  void clear_reason_code();
  static const int kReasonCodeFieldNumber = 1;
  ::decision::StopReasonCode reason_code() const;
  void set_reason_code(::decision::StopReasonCode value);

  // @@protoc_insertion_point(class_scope:decision.ObjectStop)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> wait_for_obstacle_;
  ::geometry::PointENU* stop_point_;
  double distance_s_;
  double stop_heading_;
  int reason_code_;
  friend struct ::TableStruct_decision_2eproto;
};
// -------------------------------------------------------------------

class ObjectNudge :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:decision.ObjectNudge) */ {
 public:
  ObjectNudge();
  virtual ~ObjectNudge();

  ObjectNudge(const ObjectNudge& from);

  inline ObjectNudge& operator=(const ObjectNudge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectNudge(ObjectNudge&& from) noexcept
    : ObjectNudge() {
    *this = ::std::move(from);
  }

  inline ObjectNudge& operator=(ObjectNudge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ObjectNudge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectNudge* internal_default_instance() {
    return reinterpret_cast<const ObjectNudge*>(
               &_ObjectNudge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ObjectNudge* other);
  friend void swap(ObjectNudge& a, ObjectNudge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectNudge* New() const final {
    return CreateMaybeMessage<ObjectNudge>(nullptr);
  }

  ObjectNudge* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectNudge>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectNudge& from);
  void MergeFrom(const ObjectNudge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectNudge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ObjectNudge_Type Type;
  static const Type LEFT_NUDGE =
    ObjectNudge_Type_LEFT_NUDGE;
  static const Type RIGHT_NUDGE =
    ObjectNudge_Type_RIGHT_NUDGE;
  static const Type DYNAMIC_LEFT_NUDGE =
    ObjectNudge_Type_DYNAMIC_LEFT_NUDGE;
  static const Type DYNAMIC_RIGHT_NUDGE =
    ObjectNudge_Type_DYNAMIC_RIGHT_NUDGE;
  static inline bool Type_IsValid(int value) {
    return ObjectNudge_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ObjectNudge_Type_Type_MIN;
  static const Type Type_MAX =
    ObjectNudge_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ObjectNudge_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ObjectNudge_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ObjectNudge_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ObjectNudge_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double distance_l = 2;
  bool has_distance_l() const;
  void clear_distance_l();
  static const int kDistanceLFieldNumber = 2;
  double distance_l() const;
  void set_distance_l(double value);

  // optional .decision.ObjectNudge.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::decision::ObjectNudge_Type type() const;
  void set_type(::decision::ObjectNudge_Type value);

  // @@protoc_insertion_point(class_scope:decision.ObjectNudge)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double distance_l_;
  int type_;
  friend struct ::TableStruct_decision_2eproto;
};
// -------------------------------------------------------------------

class ObjectYield :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:decision.ObjectYield) */ {
 public:
  ObjectYield();
  virtual ~ObjectYield();

  ObjectYield(const ObjectYield& from);

  inline ObjectYield& operator=(const ObjectYield& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectYield(ObjectYield&& from) noexcept
    : ObjectYield() {
    *this = ::std::move(from);
  }

  inline ObjectYield& operator=(ObjectYield&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ObjectYield& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectYield* internal_default_instance() {
    return reinterpret_cast<const ObjectYield*>(
               &_ObjectYield_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ObjectYield* other);
  friend void swap(ObjectYield& a, ObjectYield& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectYield* New() const final {
    return CreateMaybeMessage<ObjectYield>(nullptr);
  }

  ObjectYield* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectYield>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectYield& from);
  void MergeFrom(const ObjectYield& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectYield* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .geometry.PointENU fence_point = 2;
  bool has_fence_point() const;
  void clear_fence_point();
  static const int kFencePointFieldNumber = 2;
  const ::geometry::PointENU& fence_point() const;
  ::geometry::PointENU* release_fence_point();
  ::geometry::PointENU* mutable_fence_point();
  void set_allocated_fence_point(::geometry::PointENU* fence_point);

  // optional double distance_s = 1;
  bool has_distance_s() const;
  void clear_distance_s();
  static const int kDistanceSFieldNumber = 1;
  double distance_s() const;
  void set_distance_s(double value);

  // optional double fence_heading = 3;
  bool has_fence_heading() const;
  void clear_fence_heading();
  static const int kFenceHeadingFieldNumber = 3;
  double fence_heading() const;
  void set_fence_heading(double value);

  // optional double time_buffer = 4;
  bool has_time_buffer() const;
  void clear_time_buffer();
  static const int kTimeBufferFieldNumber = 4;
  double time_buffer() const;
  void set_time_buffer(double value);

  // @@protoc_insertion_point(class_scope:decision.ObjectYield)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::geometry::PointENU* fence_point_;
  double distance_s_;
  double fence_heading_;
  double time_buffer_;
  friend struct ::TableStruct_decision_2eproto;
};
// -------------------------------------------------------------------

class ObjectFollow :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:decision.ObjectFollow) */ {
 public:
  ObjectFollow();
  virtual ~ObjectFollow();

  ObjectFollow(const ObjectFollow& from);

  inline ObjectFollow& operator=(const ObjectFollow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectFollow(ObjectFollow&& from) noexcept
    : ObjectFollow() {
    *this = ::std::move(from);
  }

  inline ObjectFollow& operator=(ObjectFollow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ObjectFollow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectFollow* internal_default_instance() {
    return reinterpret_cast<const ObjectFollow*>(
               &_ObjectFollow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ObjectFollow* other);
  friend void swap(ObjectFollow& a, ObjectFollow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectFollow* New() const final {
    return CreateMaybeMessage<ObjectFollow>(nullptr);
  }

  ObjectFollow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectFollow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectFollow& from);
  void MergeFrom(const ObjectFollow& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectFollow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .geometry.PointENU fence_point = 2;
  bool has_fence_point() const;
  void clear_fence_point();
  static const int kFencePointFieldNumber = 2;
  const ::geometry::PointENU& fence_point() const;
  ::geometry::PointENU* release_fence_point();
  ::geometry::PointENU* mutable_fence_point();
  void set_allocated_fence_point(::geometry::PointENU* fence_point);

  // optional double distance_s = 1;
  bool has_distance_s() const;
  void clear_distance_s();
  static const int kDistanceSFieldNumber = 1;
  double distance_s() const;
  void set_distance_s(double value);

  // optional double fence_heading = 3;
  bool has_fence_heading() const;
  void clear_fence_heading();
  static const int kFenceHeadingFieldNumber = 3;
  double fence_heading() const;
  void set_fence_heading(double value);

  // @@protoc_insertion_point(class_scope:decision.ObjectFollow)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::geometry::PointENU* fence_point_;
  double distance_s_;
  double fence_heading_;
  friend struct ::TableStruct_decision_2eproto;
};
// -------------------------------------------------------------------

class ObjectOvertake :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:decision.ObjectOvertake) */ {
 public:
  ObjectOvertake();
  virtual ~ObjectOvertake();

  ObjectOvertake(const ObjectOvertake& from);

  inline ObjectOvertake& operator=(const ObjectOvertake& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectOvertake(ObjectOvertake&& from) noexcept
    : ObjectOvertake() {
    *this = ::std::move(from);
  }

  inline ObjectOvertake& operator=(ObjectOvertake&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ObjectOvertake& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectOvertake* internal_default_instance() {
    return reinterpret_cast<const ObjectOvertake*>(
               &_ObjectOvertake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ObjectOvertake* other);
  friend void swap(ObjectOvertake& a, ObjectOvertake& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectOvertake* New() const final {
    return CreateMaybeMessage<ObjectOvertake>(nullptr);
  }

  ObjectOvertake* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectOvertake>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectOvertake& from);
  void MergeFrom(const ObjectOvertake& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectOvertake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .geometry.PointENU fence_point = 2;
  bool has_fence_point() const;
  void clear_fence_point();
  static const int kFencePointFieldNumber = 2;
  const ::geometry::PointENU& fence_point() const;
  ::geometry::PointENU* release_fence_point();
  ::geometry::PointENU* mutable_fence_point();
  void set_allocated_fence_point(::geometry::PointENU* fence_point);

  // optional double distance_s = 1;
  bool has_distance_s() const;
  void clear_distance_s();
  static const int kDistanceSFieldNumber = 1;
  double distance_s() const;
  void set_distance_s(double value);

  // optional double fence_heading = 3;
  bool has_fence_heading() const;
  void clear_fence_heading();
  static const int kFenceHeadingFieldNumber = 3;
  double fence_heading() const;
  void set_fence_heading(double value);

  // optional double time_buffer = 4;
  bool has_time_buffer() const;
  void clear_time_buffer();
  static const int kTimeBufferFieldNumber = 4;
  double time_buffer() const;
  void set_time_buffer(double value);

  // @@protoc_insertion_point(class_scope:decision.ObjectOvertake)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::geometry::PointENU* fence_point_;
  double distance_s_;
  double fence_heading_;
  double time_buffer_;
  friend struct ::TableStruct_decision_2eproto;
};
// -------------------------------------------------------------------

class ObjectSidePass :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:decision.ObjectSidePass) */ {
 public:
  ObjectSidePass();
  virtual ~ObjectSidePass();

  ObjectSidePass(const ObjectSidePass& from);

  inline ObjectSidePass& operator=(const ObjectSidePass& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectSidePass(ObjectSidePass&& from) noexcept
    : ObjectSidePass() {
    *this = ::std::move(from);
  }

  inline ObjectSidePass& operator=(ObjectSidePass&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ObjectSidePass& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectSidePass* internal_default_instance() {
    return reinterpret_cast<const ObjectSidePass*>(
               &_ObjectSidePass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ObjectSidePass* other);
  friend void swap(ObjectSidePass& a, ObjectSidePass& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectSidePass* New() const final {
    return CreateMaybeMessage<ObjectSidePass>(nullptr);
  }

  ObjectSidePass* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectSidePass>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectSidePass& from);
  void MergeFrom(const ObjectSidePass& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectSidePass* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ObjectSidePass_Type Type;
  static const Type LEFT =
    ObjectSidePass_Type_LEFT;
  static const Type RIGHT =
    ObjectSidePass_Type_RIGHT;
  static inline bool Type_IsValid(int value) {
    return ObjectSidePass_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ObjectSidePass_Type_Type_MIN;
  static const Type Type_MAX =
    ObjectSidePass_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ObjectSidePass_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ObjectSidePass_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ObjectSidePass_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ObjectSidePass_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .decision.ObjectSidePass.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::decision::ObjectSidePass_Type type() const;
  void set_type(::decision::ObjectSidePass_Type value);

  // @@protoc_insertion_point(class_scope:decision.ObjectSidePass)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int type_;
  friend struct ::TableStruct_decision_2eproto;
};
// -------------------------------------------------------------------

class ObjectAvoid :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:decision.ObjectAvoid) */ {
 public:
  ObjectAvoid();
  virtual ~ObjectAvoid();

  ObjectAvoid(const ObjectAvoid& from);

  inline ObjectAvoid& operator=(const ObjectAvoid& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectAvoid(ObjectAvoid&& from) noexcept
    : ObjectAvoid() {
    *this = ::std::move(from);
  }

  inline ObjectAvoid& operator=(ObjectAvoid&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ObjectAvoid& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectAvoid* internal_default_instance() {
    return reinterpret_cast<const ObjectAvoid*>(
               &_ObjectAvoid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ObjectAvoid* other);
  friend void swap(ObjectAvoid& a, ObjectAvoid& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectAvoid* New() const final {
    return CreateMaybeMessage<ObjectAvoid>(nullptr);
  }

  ObjectAvoid* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectAvoid>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectAvoid& from);
  void MergeFrom(const ObjectAvoid& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectAvoid* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:decision.ObjectAvoid)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_decision_2eproto;
};
// -------------------------------------------------------------------

class ObjectStatus :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:decision.ObjectStatus) */ {
 public:
  ObjectStatus();
  virtual ~ObjectStatus();

  ObjectStatus(const ObjectStatus& from);

  inline ObjectStatus& operator=(const ObjectStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectStatus(ObjectStatus&& from) noexcept
    : ObjectStatus() {
    *this = ::std::move(from);
  }

  inline ObjectStatus& operator=(ObjectStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ObjectStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectStatus* internal_default_instance() {
    return reinterpret_cast<const ObjectStatus*>(
               &_ObjectStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ObjectStatus* other);
  friend void swap(ObjectStatus& a, ObjectStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectStatus* New() const final {
    return CreateMaybeMessage<ObjectStatus>(nullptr);
  }

  ObjectStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectStatus& from);
  void MergeFrom(const ObjectStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .decision.ObjectMotionType motion_type = 1;
  bool has_motion_type() const;
  void clear_motion_type();
  static const int kMotionTypeFieldNumber = 1;
  const ::decision::ObjectMotionType& motion_type() const;
  ::decision::ObjectMotionType* release_motion_type();
  ::decision::ObjectMotionType* mutable_motion_type();
  void set_allocated_motion_type(::decision::ObjectMotionType* motion_type);

  // optional .decision.ObjectDecisionType decision_type = 2;
  bool has_decision_type() const;
  void clear_decision_type();
  static const int kDecisionTypeFieldNumber = 2;
  const ::decision::ObjectDecisionType& decision_type() const;
  ::decision::ObjectDecisionType* release_decision_type();
  ::decision::ObjectDecisionType* mutable_decision_type();
  void set_allocated_decision_type(::decision::ObjectDecisionType* decision_type);

  // @@protoc_insertion_point(class_scope:decision.ObjectStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::decision::ObjectMotionType* motion_type_;
  ::decision::ObjectDecisionType* decision_type_;
  friend struct ::TableStruct_decision_2eproto;
};
// -------------------------------------------------------------------

class ObjectStatic :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:decision.ObjectStatic) */ {
 public:
  ObjectStatic();
  virtual ~ObjectStatic();

  ObjectStatic(const ObjectStatic& from);

  inline ObjectStatic& operator=(const ObjectStatic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectStatic(ObjectStatic&& from) noexcept
    : ObjectStatic() {
    *this = ::std::move(from);
  }

  inline ObjectStatic& operator=(ObjectStatic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ObjectStatic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectStatic* internal_default_instance() {
    return reinterpret_cast<const ObjectStatic*>(
               &_ObjectStatic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ObjectStatic* other);
  friend void swap(ObjectStatic& a, ObjectStatic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectStatic* New() const final {
    return CreateMaybeMessage<ObjectStatic>(nullptr);
  }

  ObjectStatic* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectStatic>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectStatic& from);
  void MergeFrom(const ObjectStatic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectStatic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:decision.ObjectStatic)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_decision_2eproto;
};
// -------------------------------------------------------------------

class ObjectDynamic :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:decision.ObjectDynamic) */ {
 public:
  ObjectDynamic();
  virtual ~ObjectDynamic();

  ObjectDynamic(const ObjectDynamic& from);

  inline ObjectDynamic& operator=(const ObjectDynamic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectDynamic(ObjectDynamic&& from) noexcept
    : ObjectDynamic() {
    *this = ::std::move(from);
  }

  inline ObjectDynamic& operator=(ObjectDynamic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ObjectDynamic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectDynamic* internal_default_instance() {
    return reinterpret_cast<const ObjectDynamic*>(
               &_ObjectDynamic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ObjectDynamic* other);
  friend void swap(ObjectDynamic& a, ObjectDynamic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectDynamic* New() const final {
    return CreateMaybeMessage<ObjectDynamic>(nullptr);
  }

  ObjectDynamic* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectDynamic>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectDynamic& from);
  void MergeFrom(const ObjectDynamic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectDynamic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:decision.ObjectDynamic)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_decision_2eproto;
};
// -------------------------------------------------------------------

class ObjectMotionType :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:decision.ObjectMotionType) */ {
 public:
  ObjectMotionType();
  virtual ~ObjectMotionType();

  ObjectMotionType(const ObjectMotionType& from);

  inline ObjectMotionType& operator=(const ObjectMotionType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectMotionType(ObjectMotionType&& from) noexcept
    : ObjectMotionType() {
    *this = ::std::move(from);
  }

  inline ObjectMotionType& operator=(ObjectMotionType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ObjectMotionType& default_instance();

  enum MotionTagCase {
    kStatic = 1,
    kDynamic = 2,
    MOTION_TAG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectMotionType* internal_default_instance() {
    return reinterpret_cast<const ObjectMotionType*>(
               &_ObjectMotionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ObjectMotionType* other);
  friend void swap(ObjectMotionType& a, ObjectMotionType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectMotionType* New() const final {
    return CreateMaybeMessage<ObjectMotionType>(nullptr);
  }

  ObjectMotionType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectMotionType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectMotionType& from);
  void MergeFrom(const ObjectMotionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectMotionType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .decision.ObjectStatic static = 1;
  bool has_static_() const;
  void clear_static_();
  static const int kStaticFieldNumber = 1;
  const ::decision::ObjectStatic& static_() const;
  ::decision::ObjectStatic* release_static_();
  ::decision::ObjectStatic* mutable_static_();
  void set_allocated_static_(::decision::ObjectStatic* static_);

  // optional .decision.ObjectDynamic dynamic = 2;
  bool has_dynamic() const;
  void clear_dynamic();
  static const int kDynamicFieldNumber = 2;
  const ::decision::ObjectDynamic& dynamic() const;
  ::decision::ObjectDynamic* release_dynamic();
  ::decision::ObjectDynamic* mutable_dynamic();
  void set_allocated_dynamic(::decision::ObjectDynamic* dynamic);

  void clear_motion_tag();
  MotionTagCase motion_tag_case() const;
  // @@protoc_insertion_point(class_scope:decision.ObjectMotionType)
 private:
  class HasBitSetters;
  void set_has_static_();
  void set_has_dynamic();

  inline bool has_motion_tag() const;
  inline void clear_has_motion_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union MotionTagUnion {
    MotionTagUnion() {}
    ::decision::ObjectStatic* static__;
    ::decision::ObjectDynamic* dynamic_;
  } motion_tag_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_decision_2eproto;
};
// -------------------------------------------------------------------

class ObjectDecisionType :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:decision.ObjectDecisionType) */ {
 public:
  ObjectDecisionType();
  virtual ~ObjectDecisionType();

  ObjectDecisionType(const ObjectDecisionType& from);

  inline ObjectDecisionType& operator=(const ObjectDecisionType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectDecisionType(ObjectDecisionType&& from) noexcept
    : ObjectDecisionType() {
    *this = ::std::move(from);
  }

  inline ObjectDecisionType& operator=(ObjectDecisionType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ObjectDecisionType& default_instance();

  enum ObjectTagCase {
    kIgnore = 1,
    kStop = 2,
    kFollow = 3,
    kYield = 4,
    kOvertake = 5,
    kNudge = 6,
    kAvoid = 7,
    kSidePass = 8,
    OBJECT_TAG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectDecisionType* internal_default_instance() {
    return reinterpret_cast<const ObjectDecisionType*>(
               &_ObjectDecisionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ObjectDecisionType* other);
  friend void swap(ObjectDecisionType& a, ObjectDecisionType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectDecisionType* New() const final {
    return CreateMaybeMessage<ObjectDecisionType>(nullptr);
  }

  ObjectDecisionType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectDecisionType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectDecisionType& from);
  void MergeFrom(const ObjectDecisionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectDecisionType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .decision.ObjectIgnore ignore = 1;
  bool has_ignore() const;
  void clear_ignore();
  static const int kIgnoreFieldNumber = 1;
  const ::decision::ObjectIgnore& ignore() const;
  ::decision::ObjectIgnore* release_ignore();
  ::decision::ObjectIgnore* mutable_ignore();
  void set_allocated_ignore(::decision::ObjectIgnore* ignore);

  // optional .decision.ObjectStop stop = 2;
  bool has_stop() const;
  void clear_stop();
  static const int kStopFieldNumber = 2;
  const ::decision::ObjectStop& stop() const;
  ::decision::ObjectStop* release_stop();
  ::decision::ObjectStop* mutable_stop();
  void set_allocated_stop(::decision::ObjectStop* stop);

  // optional .decision.ObjectFollow follow = 3;
  bool has_follow() const;
  void clear_follow();
  static const int kFollowFieldNumber = 3;
  const ::decision::ObjectFollow& follow() const;
  ::decision::ObjectFollow* release_follow();
  ::decision::ObjectFollow* mutable_follow();
  void set_allocated_follow(::decision::ObjectFollow* follow);

  // optional .decision.ObjectYield yield = 4;
  bool has_yield() const;
  void clear_yield();
  static const int kYieldFieldNumber = 4;
  const ::decision::ObjectYield& yield() const;
  ::decision::ObjectYield* release_yield();
  ::decision::ObjectYield* mutable_yield();
  void set_allocated_yield(::decision::ObjectYield* yield);

  // optional .decision.ObjectOvertake overtake = 5;
  bool has_overtake() const;
  void clear_overtake();
  static const int kOvertakeFieldNumber = 5;
  const ::decision::ObjectOvertake& overtake() const;
  ::decision::ObjectOvertake* release_overtake();
  ::decision::ObjectOvertake* mutable_overtake();
  void set_allocated_overtake(::decision::ObjectOvertake* overtake);

  // optional .decision.ObjectNudge nudge = 6;
  bool has_nudge() const;
  void clear_nudge();
  static const int kNudgeFieldNumber = 6;
  const ::decision::ObjectNudge& nudge() const;
  ::decision::ObjectNudge* release_nudge();
  ::decision::ObjectNudge* mutable_nudge();
  void set_allocated_nudge(::decision::ObjectNudge* nudge);

  // optional .decision.ObjectAvoid avoid = 7;
  bool has_avoid() const;
  void clear_avoid();
  static const int kAvoidFieldNumber = 7;
  const ::decision::ObjectAvoid& avoid() const;
  ::decision::ObjectAvoid* release_avoid();
  ::decision::ObjectAvoid* mutable_avoid();
  void set_allocated_avoid(::decision::ObjectAvoid* avoid);

  // optional .decision.ObjectSidePass side_pass = 8;
  bool has_side_pass() const;
  void clear_side_pass();
  static const int kSidePassFieldNumber = 8;
  const ::decision::ObjectSidePass& side_pass() const;
  ::decision::ObjectSidePass* release_side_pass();
  ::decision::ObjectSidePass* mutable_side_pass();
  void set_allocated_side_pass(::decision::ObjectSidePass* side_pass);

  void clear_object_tag();
  ObjectTagCase object_tag_case() const;
  // @@protoc_insertion_point(class_scope:decision.ObjectDecisionType)
 private:
  class HasBitSetters;
  void set_has_ignore();
  void set_has_stop();
  void set_has_follow();
  void set_has_yield();
  void set_has_overtake();
  void set_has_nudge();
  void set_has_avoid();
  void set_has_side_pass();

  inline bool has_object_tag() const;
  inline void clear_has_object_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union ObjectTagUnion {
    ObjectTagUnion() {}
    ::decision::ObjectIgnore* ignore_;
    ::decision::ObjectStop* stop_;
    ::decision::ObjectFollow* follow_;
    ::decision::ObjectYield* yield_;
    ::decision::ObjectOvertake* overtake_;
    ::decision::ObjectNudge* nudge_;
    ::decision::ObjectAvoid* avoid_;
    ::decision::ObjectSidePass* side_pass_;
  } object_tag_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_decision_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TargetLane

// optional string id = 1;
inline bool TargetLane::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetLane::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TargetLane::id() const {
  // @@protoc_insertion_point(field_get:decision.TargetLane.id)
  return id_.GetNoArena();
}
inline void TargetLane::set_id(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:decision.TargetLane.id)
}
#if LANG_CXX11
inline void TargetLane::set_id(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:decision.TargetLane.id)
}
#endif
inline void TargetLane::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:decision.TargetLane.id)
}
inline void TargetLane::set_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:decision.TargetLane.id)
}
inline ::std::string* TargetLane::mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:decision.TargetLane.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TargetLane::release_id() {
  // @@protoc_insertion_point(field_release:decision.TargetLane.id)
  if (!has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TargetLane::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:decision.TargetLane.id)
}

// optional double start_s = 2;
inline bool TargetLane::has_start_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetLane::clear_start_s() {
  start_s_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double TargetLane::start_s() const {
  // @@protoc_insertion_point(field_get:decision.TargetLane.start_s)
  return start_s_;
}
inline void TargetLane::set_start_s(double value) {
  _has_bits_[0] |= 0x00000002u;
  start_s_ = value;
  // @@protoc_insertion_point(field_set:decision.TargetLane.start_s)
}

// optional double end_s = 3;
inline bool TargetLane::has_end_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TargetLane::clear_end_s() {
  end_s_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double TargetLane::end_s() const {
  // @@protoc_insertion_point(field_get:decision.TargetLane.end_s)
  return end_s_;
}
inline void TargetLane::set_end_s(double value) {
  _has_bits_[0] |= 0x00000004u;
  end_s_ = value;
  // @@protoc_insertion_point(field_set:decision.TargetLane.end_s)
}

// optional double speed_limit = 4;
inline bool TargetLane::has_speed_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TargetLane::clear_speed_limit() {
  speed_limit_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double TargetLane::speed_limit() const {
  // @@protoc_insertion_point(field_get:decision.TargetLane.speed_limit)
  return speed_limit_;
}
inline void TargetLane::set_speed_limit(double value) {
  _has_bits_[0] |= 0x00000008u;
  speed_limit_ = value;
  // @@protoc_insertion_point(field_set:decision.TargetLane.speed_limit)
}

// -------------------------------------------------------------------

// ObjectIgnore

// -------------------------------------------------------------------

// ObjectStop

// optional .decision.StopReasonCode reason_code = 1;
inline bool ObjectStop::has_reason_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObjectStop::clear_reason_code() {
  reason_code_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::decision::StopReasonCode ObjectStop::reason_code() const {
  // @@protoc_insertion_point(field_get:decision.ObjectStop.reason_code)
  return static_cast< ::decision::StopReasonCode >(reason_code_);
}
inline void ObjectStop::set_reason_code(::decision::StopReasonCode value) {
  assert(::decision::StopReasonCode_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  reason_code_ = value;
  // @@protoc_insertion_point(field_set:decision.ObjectStop.reason_code)
}

// optional double distance_s = 2;
inline bool ObjectStop::has_distance_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectStop::clear_distance_s() {
  distance_s_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ObjectStop::distance_s() const {
  // @@protoc_insertion_point(field_get:decision.ObjectStop.distance_s)
  return distance_s_;
}
inline void ObjectStop::set_distance_s(double value) {
  _has_bits_[0] |= 0x00000002u;
  distance_s_ = value;
  // @@protoc_insertion_point(field_set:decision.ObjectStop.distance_s)
}

// optional .geometry.PointENU stop_point = 3;
inline bool ObjectStop::has_stop_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::geometry::PointENU& ObjectStop::stop_point() const {
  const ::geometry::PointENU* p = stop_point_;
  // @@protoc_insertion_point(field_get:decision.ObjectStop.stop_point)
  return p != nullptr ? *p : *reinterpret_cast<const ::geometry::PointENU*>(
      &::geometry::_PointENU_default_instance_);
}
inline ::geometry::PointENU* ObjectStop::release_stop_point() {
  // @@protoc_insertion_point(field_release:decision.ObjectStop.stop_point)
  _has_bits_[0] &= ~0x00000001u;
  ::geometry::PointENU* temp = stop_point_;
  stop_point_ = nullptr;
  return temp;
}
inline ::geometry::PointENU* ObjectStop::mutable_stop_point() {
  _has_bits_[0] |= 0x00000001u;
  if (stop_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry::PointENU>(GetArenaNoVirtual());
    stop_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:decision.ObjectStop.stop_point)
  return stop_point_;
}
inline void ObjectStop::set_allocated_stop_point(::geometry::PointENU* stop_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(stop_point_);
  }
  if (stop_point) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stop_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stop_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  stop_point_ = stop_point;
  // @@protoc_insertion_point(field_set_allocated:decision.ObjectStop.stop_point)
}

// optional double stop_heading = 4;
inline bool ObjectStop::has_stop_heading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObjectStop::clear_stop_heading() {
  stop_heading_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ObjectStop::stop_heading() const {
  // @@protoc_insertion_point(field_get:decision.ObjectStop.stop_heading)
  return stop_heading_;
}
inline void ObjectStop::set_stop_heading(double value) {
  _has_bits_[0] |= 0x00000004u;
  stop_heading_ = value;
  // @@protoc_insertion_point(field_set:decision.ObjectStop.stop_heading)
}

// repeated string wait_for_obstacle = 5;
inline int ObjectStop::wait_for_obstacle_size() const {
  return wait_for_obstacle_.size();
}
inline void ObjectStop::clear_wait_for_obstacle() {
  wait_for_obstacle_.Clear();
}
inline const ::std::string& ObjectStop::wait_for_obstacle(int index) const {
  // @@protoc_insertion_point(field_get:decision.ObjectStop.wait_for_obstacle)
  return wait_for_obstacle_.Get(index);
}
inline ::std::string* ObjectStop::mutable_wait_for_obstacle(int index) {
  // @@protoc_insertion_point(field_mutable:decision.ObjectStop.wait_for_obstacle)
  return wait_for_obstacle_.Mutable(index);
}
inline void ObjectStop::set_wait_for_obstacle(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:decision.ObjectStop.wait_for_obstacle)
  wait_for_obstacle_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ObjectStop::set_wait_for_obstacle(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:decision.ObjectStop.wait_for_obstacle)
  wait_for_obstacle_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ObjectStop::set_wait_for_obstacle(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  wait_for_obstacle_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:decision.ObjectStop.wait_for_obstacle)
}
inline void ObjectStop::set_wait_for_obstacle(int index, const char* value, size_t size) {
  wait_for_obstacle_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:decision.ObjectStop.wait_for_obstacle)
}
inline ::std::string* ObjectStop::add_wait_for_obstacle() {
  // @@protoc_insertion_point(field_add_mutable:decision.ObjectStop.wait_for_obstacle)
  return wait_for_obstacle_.Add();
}
inline void ObjectStop::add_wait_for_obstacle(const ::std::string& value) {
  wait_for_obstacle_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:decision.ObjectStop.wait_for_obstacle)
}
#if LANG_CXX11
inline void ObjectStop::add_wait_for_obstacle(::std::string&& value) {
  wait_for_obstacle_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:decision.ObjectStop.wait_for_obstacle)
}
#endif
inline void ObjectStop::add_wait_for_obstacle(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  wait_for_obstacle_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:decision.ObjectStop.wait_for_obstacle)
}
inline void ObjectStop::add_wait_for_obstacle(const char* value, size_t size) {
  wait_for_obstacle_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:decision.ObjectStop.wait_for_obstacle)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ObjectStop::wait_for_obstacle() const {
  // @@protoc_insertion_point(field_list:decision.ObjectStop.wait_for_obstacle)
  return wait_for_obstacle_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
ObjectStop::mutable_wait_for_obstacle() {
  // @@protoc_insertion_point(field_mutable_list:decision.ObjectStop.wait_for_obstacle)
  return &wait_for_obstacle_;
}

// -------------------------------------------------------------------

// ObjectNudge

// optional .decision.ObjectNudge.Type type = 1;
inline bool ObjectNudge::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectNudge::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::decision::ObjectNudge_Type ObjectNudge::type() const {
  // @@protoc_insertion_point(field_get:decision.ObjectNudge.type)
  return static_cast< ::decision::ObjectNudge_Type >(type_);
}
inline void ObjectNudge::set_type(::decision::ObjectNudge_Type value) {
  assert(::decision::ObjectNudge_Type_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
  // @@protoc_insertion_point(field_set:decision.ObjectNudge.type)
}

// optional double distance_l = 2;
inline bool ObjectNudge::has_distance_l() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectNudge::clear_distance_l() {
  distance_l_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ObjectNudge::distance_l() const {
  // @@protoc_insertion_point(field_get:decision.ObjectNudge.distance_l)
  return distance_l_;
}
inline void ObjectNudge::set_distance_l(double value) {
  _has_bits_[0] |= 0x00000001u;
  distance_l_ = value;
  // @@protoc_insertion_point(field_set:decision.ObjectNudge.distance_l)
}

// -------------------------------------------------------------------

// ObjectYield

// optional double distance_s = 1;
inline bool ObjectYield::has_distance_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectYield::clear_distance_s() {
  distance_s_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ObjectYield::distance_s() const {
  // @@protoc_insertion_point(field_get:decision.ObjectYield.distance_s)
  return distance_s_;
}
inline void ObjectYield::set_distance_s(double value) {
  _has_bits_[0] |= 0x00000002u;
  distance_s_ = value;
  // @@protoc_insertion_point(field_set:decision.ObjectYield.distance_s)
}

// optional .geometry.PointENU fence_point = 2;
inline bool ObjectYield::has_fence_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::geometry::PointENU& ObjectYield::fence_point() const {
  const ::geometry::PointENU* p = fence_point_;
  // @@protoc_insertion_point(field_get:decision.ObjectYield.fence_point)
  return p != nullptr ? *p : *reinterpret_cast<const ::geometry::PointENU*>(
      &::geometry::_PointENU_default_instance_);
}
inline ::geometry::PointENU* ObjectYield::release_fence_point() {
  // @@protoc_insertion_point(field_release:decision.ObjectYield.fence_point)
  _has_bits_[0] &= ~0x00000001u;
  ::geometry::PointENU* temp = fence_point_;
  fence_point_ = nullptr;
  return temp;
}
inline ::geometry::PointENU* ObjectYield::mutable_fence_point() {
  _has_bits_[0] |= 0x00000001u;
  if (fence_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry::PointENU>(GetArenaNoVirtual());
    fence_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:decision.ObjectYield.fence_point)
  return fence_point_;
}
inline void ObjectYield::set_allocated_fence_point(::geometry::PointENU* fence_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(fence_point_);
  }
  if (fence_point) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fence_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fence_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fence_point_ = fence_point;
  // @@protoc_insertion_point(field_set_allocated:decision.ObjectYield.fence_point)
}

// optional double fence_heading = 3;
inline bool ObjectYield::has_fence_heading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObjectYield::clear_fence_heading() {
  fence_heading_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ObjectYield::fence_heading() const {
  // @@protoc_insertion_point(field_get:decision.ObjectYield.fence_heading)
  return fence_heading_;
}
inline void ObjectYield::set_fence_heading(double value) {
  _has_bits_[0] |= 0x00000004u;
  fence_heading_ = value;
  // @@protoc_insertion_point(field_set:decision.ObjectYield.fence_heading)
}

// optional double time_buffer = 4;
inline bool ObjectYield::has_time_buffer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObjectYield::clear_time_buffer() {
  time_buffer_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ObjectYield::time_buffer() const {
  // @@protoc_insertion_point(field_get:decision.ObjectYield.time_buffer)
  return time_buffer_;
}
inline void ObjectYield::set_time_buffer(double value) {
  _has_bits_[0] |= 0x00000008u;
  time_buffer_ = value;
  // @@protoc_insertion_point(field_set:decision.ObjectYield.time_buffer)
}

// -------------------------------------------------------------------

// ObjectFollow

// optional double distance_s = 1;
inline bool ObjectFollow::has_distance_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectFollow::clear_distance_s() {
  distance_s_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ObjectFollow::distance_s() const {
  // @@protoc_insertion_point(field_get:decision.ObjectFollow.distance_s)
  return distance_s_;
}
inline void ObjectFollow::set_distance_s(double value) {
  _has_bits_[0] |= 0x00000002u;
  distance_s_ = value;
  // @@protoc_insertion_point(field_set:decision.ObjectFollow.distance_s)
}

// optional .geometry.PointENU fence_point = 2;
inline bool ObjectFollow::has_fence_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::geometry::PointENU& ObjectFollow::fence_point() const {
  const ::geometry::PointENU* p = fence_point_;
  // @@protoc_insertion_point(field_get:decision.ObjectFollow.fence_point)
  return p != nullptr ? *p : *reinterpret_cast<const ::geometry::PointENU*>(
      &::geometry::_PointENU_default_instance_);
}
inline ::geometry::PointENU* ObjectFollow::release_fence_point() {
  // @@protoc_insertion_point(field_release:decision.ObjectFollow.fence_point)
  _has_bits_[0] &= ~0x00000001u;
  ::geometry::PointENU* temp = fence_point_;
  fence_point_ = nullptr;
  return temp;
}
inline ::geometry::PointENU* ObjectFollow::mutable_fence_point() {
  _has_bits_[0] |= 0x00000001u;
  if (fence_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry::PointENU>(GetArenaNoVirtual());
    fence_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:decision.ObjectFollow.fence_point)
  return fence_point_;
}
inline void ObjectFollow::set_allocated_fence_point(::geometry::PointENU* fence_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(fence_point_);
  }
  if (fence_point) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fence_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fence_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fence_point_ = fence_point;
  // @@protoc_insertion_point(field_set_allocated:decision.ObjectFollow.fence_point)
}

// optional double fence_heading = 3;
inline bool ObjectFollow::has_fence_heading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObjectFollow::clear_fence_heading() {
  fence_heading_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ObjectFollow::fence_heading() const {
  // @@protoc_insertion_point(field_get:decision.ObjectFollow.fence_heading)
  return fence_heading_;
}
inline void ObjectFollow::set_fence_heading(double value) {
  _has_bits_[0] |= 0x00000004u;
  fence_heading_ = value;
  // @@protoc_insertion_point(field_set:decision.ObjectFollow.fence_heading)
}

// -------------------------------------------------------------------

// ObjectOvertake

// optional double distance_s = 1;
inline bool ObjectOvertake::has_distance_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectOvertake::clear_distance_s() {
  distance_s_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ObjectOvertake::distance_s() const {
  // @@protoc_insertion_point(field_get:decision.ObjectOvertake.distance_s)
  return distance_s_;
}
inline void ObjectOvertake::set_distance_s(double value) {
  _has_bits_[0] |= 0x00000002u;
  distance_s_ = value;
  // @@protoc_insertion_point(field_set:decision.ObjectOvertake.distance_s)
}

// optional .geometry.PointENU fence_point = 2;
inline bool ObjectOvertake::has_fence_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::geometry::PointENU& ObjectOvertake::fence_point() const {
  const ::geometry::PointENU* p = fence_point_;
  // @@protoc_insertion_point(field_get:decision.ObjectOvertake.fence_point)
  return p != nullptr ? *p : *reinterpret_cast<const ::geometry::PointENU*>(
      &::geometry::_PointENU_default_instance_);
}
inline ::geometry::PointENU* ObjectOvertake::release_fence_point() {
  // @@protoc_insertion_point(field_release:decision.ObjectOvertake.fence_point)
  _has_bits_[0] &= ~0x00000001u;
  ::geometry::PointENU* temp = fence_point_;
  fence_point_ = nullptr;
  return temp;
}
inline ::geometry::PointENU* ObjectOvertake::mutable_fence_point() {
  _has_bits_[0] |= 0x00000001u;
  if (fence_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::geometry::PointENU>(GetArenaNoVirtual());
    fence_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:decision.ObjectOvertake.fence_point)
  return fence_point_;
}
inline void ObjectOvertake::set_allocated_fence_point(::geometry::PointENU* fence_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(fence_point_);
  }
  if (fence_point) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fence_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fence_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fence_point_ = fence_point;
  // @@protoc_insertion_point(field_set_allocated:decision.ObjectOvertake.fence_point)
}

// optional double fence_heading = 3;
inline bool ObjectOvertake::has_fence_heading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObjectOvertake::clear_fence_heading() {
  fence_heading_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ObjectOvertake::fence_heading() const {
  // @@protoc_insertion_point(field_get:decision.ObjectOvertake.fence_heading)
  return fence_heading_;
}
inline void ObjectOvertake::set_fence_heading(double value) {
  _has_bits_[0] |= 0x00000004u;
  fence_heading_ = value;
  // @@protoc_insertion_point(field_set:decision.ObjectOvertake.fence_heading)
}

// optional double time_buffer = 4;
inline bool ObjectOvertake::has_time_buffer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObjectOvertake::clear_time_buffer() {
  time_buffer_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ObjectOvertake::time_buffer() const {
  // @@protoc_insertion_point(field_get:decision.ObjectOvertake.time_buffer)
  return time_buffer_;
}
inline void ObjectOvertake::set_time_buffer(double value) {
  _has_bits_[0] |= 0x00000008u;
  time_buffer_ = value;
  // @@protoc_insertion_point(field_set:decision.ObjectOvertake.time_buffer)
}

// -------------------------------------------------------------------

// ObjectSidePass

// optional .decision.ObjectSidePass.Type type = 1;
inline bool ObjectSidePass::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectSidePass::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::decision::ObjectSidePass_Type ObjectSidePass::type() const {
  // @@protoc_insertion_point(field_get:decision.ObjectSidePass.type)
  return static_cast< ::decision::ObjectSidePass_Type >(type_);
}
inline void ObjectSidePass::set_type(::decision::ObjectSidePass_Type value) {
  assert(::decision::ObjectSidePass_Type_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
  // @@protoc_insertion_point(field_set:decision.ObjectSidePass.type)
}

// -------------------------------------------------------------------

// ObjectAvoid

// -------------------------------------------------------------------

// ObjectStatus

// optional .decision.ObjectMotionType motion_type = 1;
inline bool ObjectStatus::has_motion_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectStatus::clear_motion_type() {
  if (motion_type_ != nullptr) motion_type_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::decision::ObjectMotionType& ObjectStatus::motion_type() const {
  const ::decision::ObjectMotionType* p = motion_type_;
  // @@protoc_insertion_point(field_get:decision.ObjectStatus.motion_type)
  return p != nullptr ? *p : *reinterpret_cast<const ::decision::ObjectMotionType*>(
      &::decision::_ObjectMotionType_default_instance_);
}
inline ::decision::ObjectMotionType* ObjectStatus::release_motion_type() {
  // @@protoc_insertion_point(field_release:decision.ObjectStatus.motion_type)
  _has_bits_[0] &= ~0x00000001u;
  ::decision::ObjectMotionType* temp = motion_type_;
  motion_type_ = nullptr;
  return temp;
}
inline ::decision::ObjectMotionType* ObjectStatus::mutable_motion_type() {
  _has_bits_[0] |= 0x00000001u;
  if (motion_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::decision::ObjectMotionType>(GetArenaNoVirtual());
    motion_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:decision.ObjectStatus.motion_type)
  return motion_type_;
}
inline void ObjectStatus::set_allocated_motion_type(::decision::ObjectMotionType* motion_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete motion_type_;
  }
  if (motion_type) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      motion_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, motion_type, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  motion_type_ = motion_type;
  // @@protoc_insertion_point(field_set_allocated:decision.ObjectStatus.motion_type)
}

// optional .decision.ObjectDecisionType decision_type = 2;
inline bool ObjectStatus::has_decision_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectStatus::clear_decision_type() {
  if (decision_type_ != nullptr) decision_type_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::decision::ObjectDecisionType& ObjectStatus::decision_type() const {
  const ::decision::ObjectDecisionType* p = decision_type_;
  // @@protoc_insertion_point(field_get:decision.ObjectStatus.decision_type)
  return p != nullptr ? *p : *reinterpret_cast<const ::decision::ObjectDecisionType*>(
      &::decision::_ObjectDecisionType_default_instance_);
}
inline ::decision::ObjectDecisionType* ObjectStatus::release_decision_type() {
  // @@protoc_insertion_point(field_release:decision.ObjectStatus.decision_type)
  _has_bits_[0] &= ~0x00000002u;
  ::decision::ObjectDecisionType* temp = decision_type_;
  decision_type_ = nullptr;
  return temp;
}
inline ::decision::ObjectDecisionType* ObjectStatus::mutable_decision_type() {
  _has_bits_[0] |= 0x00000002u;
  if (decision_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::decision::ObjectDecisionType>(GetArenaNoVirtual());
    decision_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:decision.ObjectStatus.decision_type)
  return decision_type_;
}
inline void ObjectStatus::set_allocated_decision_type(::decision::ObjectDecisionType* decision_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete decision_type_;
  }
  if (decision_type) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      decision_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, decision_type, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  decision_type_ = decision_type;
  // @@protoc_insertion_point(field_set_allocated:decision.ObjectStatus.decision_type)
}

// -------------------------------------------------------------------

// ObjectStatic

// -------------------------------------------------------------------

// ObjectDynamic

// -------------------------------------------------------------------

// ObjectMotionType

// optional .decision.ObjectStatic static = 1;
inline bool ObjectMotionType::has_static_() const {
  return motion_tag_case() == kStatic;
}
inline void ObjectMotionType::set_has_static_() {
  _oneof_case_[0] = kStatic;
}
inline void ObjectMotionType::clear_static_() {
  if (has_static_()) {
    delete motion_tag_.static__;
    clear_has_motion_tag();
  }
}
inline ::decision::ObjectStatic* ObjectMotionType::release_static_() {
  // @@protoc_insertion_point(field_release:decision.ObjectMotionType.static)
  if (has_static_()) {
    clear_has_motion_tag();
      ::decision::ObjectStatic* temp = motion_tag_.static__;
    motion_tag_.static__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::decision::ObjectStatic& ObjectMotionType::static_() const {
  // @@protoc_insertion_point(field_get:decision.ObjectMotionType.static)
  return has_static_()
      ? *motion_tag_.static__
      : *reinterpret_cast< ::decision::ObjectStatic*>(&::decision::_ObjectStatic_default_instance_);
}
inline ::decision::ObjectStatic* ObjectMotionType::mutable_static_() {
  if (!has_static_()) {
    clear_motion_tag();
    set_has_static_();
    motion_tag_.static__ = CreateMaybeMessage< ::decision::ObjectStatic >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:decision.ObjectMotionType.static)
  return motion_tag_.static__;
}

// optional .decision.ObjectDynamic dynamic = 2;
inline bool ObjectMotionType::has_dynamic() const {
  return motion_tag_case() == kDynamic;
}
inline void ObjectMotionType::set_has_dynamic() {
  _oneof_case_[0] = kDynamic;
}
inline void ObjectMotionType::clear_dynamic() {
  if (has_dynamic()) {
    delete motion_tag_.dynamic_;
    clear_has_motion_tag();
  }
}
inline ::decision::ObjectDynamic* ObjectMotionType::release_dynamic() {
  // @@protoc_insertion_point(field_release:decision.ObjectMotionType.dynamic)
  if (has_dynamic()) {
    clear_has_motion_tag();
      ::decision::ObjectDynamic* temp = motion_tag_.dynamic_;
    motion_tag_.dynamic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::decision::ObjectDynamic& ObjectMotionType::dynamic() const {
  // @@protoc_insertion_point(field_get:decision.ObjectMotionType.dynamic)
  return has_dynamic()
      ? *motion_tag_.dynamic_
      : *reinterpret_cast< ::decision::ObjectDynamic*>(&::decision::_ObjectDynamic_default_instance_);
}
inline ::decision::ObjectDynamic* ObjectMotionType::mutable_dynamic() {
  if (!has_dynamic()) {
    clear_motion_tag();
    set_has_dynamic();
    motion_tag_.dynamic_ = CreateMaybeMessage< ::decision::ObjectDynamic >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:decision.ObjectMotionType.dynamic)
  return motion_tag_.dynamic_;
}

inline bool ObjectMotionType::has_motion_tag() const {
  return motion_tag_case() != MOTION_TAG_NOT_SET;
}
inline void ObjectMotionType::clear_has_motion_tag() {
  _oneof_case_[0] = MOTION_TAG_NOT_SET;
}
inline ObjectMotionType::MotionTagCase ObjectMotionType::motion_tag_case() const {
  return ObjectMotionType::MotionTagCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ObjectDecisionType

// optional .decision.ObjectIgnore ignore = 1;
inline bool ObjectDecisionType::has_ignore() const {
  return object_tag_case() == kIgnore;
}
inline void ObjectDecisionType::set_has_ignore() {
  _oneof_case_[0] = kIgnore;
}
inline void ObjectDecisionType::clear_ignore() {
  if (has_ignore()) {
    delete object_tag_.ignore_;
    clear_has_object_tag();
  }
}
inline ::decision::ObjectIgnore* ObjectDecisionType::release_ignore() {
  // @@protoc_insertion_point(field_release:decision.ObjectDecisionType.ignore)
  if (has_ignore()) {
    clear_has_object_tag();
      ::decision::ObjectIgnore* temp = object_tag_.ignore_;
    object_tag_.ignore_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::decision::ObjectIgnore& ObjectDecisionType::ignore() const {
  // @@protoc_insertion_point(field_get:decision.ObjectDecisionType.ignore)
  return has_ignore()
      ? *object_tag_.ignore_
      : *reinterpret_cast< ::decision::ObjectIgnore*>(&::decision::_ObjectIgnore_default_instance_);
}
inline ::decision::ObjectIgnore* ObjectDecisionType::mutable_ignore() {
  if (!has_ignore()) {
    clear_object_tag();
    set_has_ignore();
    object_tag_.ignore_ = CreateMaybeMessage< ::decision::ObjectIgnore >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:decision.ObjectDecisionType.ignore)
  return object_tag_.ignore_;
}

// optional .decision.ObjectStop stop = 2;
inline bool ObjectDecisionType::has_stop() const {
  return object_tag_case() == kStop;
}
inline void ObjectDecisionType::set_has_stop() {
  _oneof_case_[0] = kStop;
}
inline void ObjectDecisionType::clear_stop() {
  if (has_stop()) {
    delete object_tag_.stop_;
    clear_has_object_tag();
  }
}
inline ::decision::ObjectStop* ObjectDecisionType::release_stop() {
  // @@protoc_insertion_point(field_release:decision.ObjectDecisionType.stop)
  if (has_stop()) {
    clear_has_object_tag();
      ::decision::ObjectStop* temp = object_tag_.stop_;
    object_tag_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::decision::ObjectStop& ObjectDecisionType::stop() const {
  // @@protoc_insertion_point(field_get:decision.ObjectDecisionType.stop)
  return has_stop()
      ? *object_tag_.stop_
      : *reinterpret_cast< ::decision::ObjectStop*>(&::decision::_ObjectStop_default_instance_);
}
inline ::decision::ObjectStop* ObjectDecisionType::mutable_stop() {
  if (!has_stop()) {
    clear_object_tag();
    set_has_stop();
    object_tag_.stop_ = CreateMaybeMessage< ::decision::ObjectStop >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:decision.ObjectDecisionType.stop)
  return object_tag_.stop_;
}

// optional .decision.ObjectFollow follow = 3;
inline bool ObjectDecisionType::has_follow() const {
  return object_tag_case() == kFollow;
}
inline void ObjectDecisionType::set_has_follow() {
  _oneof_case_[0] = kFollow;
}
inline void ObjectDecisionType::clear_follow() {
  if (has_follow()) {
    delete object_tag_.follow_;
    clear_has_object_tag();
  }
}
inline ::decision::ObjectFollow* ObjectDecisionType::release_follow() {
  // @@protoc_insertion_point(field_release:decision.ObjectDecisionType.follow)
  if (has_follow()) {
    clear_has_object_tag();
      ::decision::ObjectFollow* temp = object_tag_.follow_;
    object_tag_.follow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::decision::ObjectFollow& ObjectDecisionType::follow() const {
  // @@protoc_insertion_point(field_get:decision.ObjectDecisionType.follow)
  return has_follow()
      ? *object_tag_.follow_
      : *reinterpret_cast< ::decision::ObjectFollow*>(&::decision::_ObjectFollow_default_instance_);
}
inline ::decision::ObjectFollow* ObjectDecisionType::mutable_follow() {
  if (!has_follow()) {
    clear_object_tag();
    set_has_follow();
    object_tag_.follow_ = CreateMaybeMessage< ::decision::ObjectFollow >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:decision.ObjectDecisionType.follow)
  return object_tag_.follow_;
}

// optional .decision.ObjectYield yield = 4;
inline bool ObjectDecisionType::has_yield() const {
  return object_tag_case() == kYield;
}
inline void ObjectDecisionType::set_has_yield() {
  _oneof_case_[0] = kYield;
}
inline void ObjectDecisionType::clear_yield() {
  if (has_yield()) {
    delete object_tag_.yield_;
    clear_has_object_tag();
  }
}
inline ::decision::ObjectYield* ObjectDecisionType::release_yield() {
  // @@protoc_insertion_point(field_release:decision.ObjectDecisionType.yield)
  if (has_yield()) {
    clear_has_object_tag();
      ::decision::ObjectYield* temp = object_tag_.yield_;
    object_tag_.yield_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::decision::ObjectYield& ObjectDecisionType::yield() const {
  // @@protoc_insertion_point(field_get:decision.ObjectDecisionType.yield)
  return has_yield()
      ? *object_tag_.yield_
      : *reinterpret_cast< ::decision::ObjectYield*>(&::decision::_ObjectYield_default_instance_);
}
inline ::decision::ObjectYield* ObjectDecisionType::mutable_yield() {
  if (!has_yield()) {
    clear_object_tag();
    set_has_yield();
    object_tag_.yield_ = CreateMaybeMessage< ::decision::ObjectYield >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:decision.ObjectDecisionType.yield)
  return object_tag_.yield_;
}

// optional .decision.ObjectOvertake overtake = 5;
inline bool ObjectDecisionType::has_overtake() const {
  return object_tag_case() == kOvertake;
}
inline void ObjectDecisionType::set_has_overtake() {
  _oneof_case_[0] = kOvertake;
}
inline void ObjectDecisionType::clear_overtake() {
  if (has_overtake()) {
    delete object_tag_.overtake_;
    clear_has_object_tag();
  }
}
inline ::decision::ObjectOvertake* ObjectDecisionType::release_overtake() {
  // @@protoc_insertion_point(field_release:decision.ObjectDecisionType.overtake)
  if (has_overtake()) {
    clear_has_object_tag();
      ::decision::ObjectOvertake* temp = object_tag_.overtake_;
    object_tag_.overtake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::decision::ObjectOvertake& ObjectDecisionType::overtake() const {
  // @@protoc_insertion_point(field_get:decision.ObjectDecisionType.overtake)
  return has_overtake()
      ? *object_tag_.overtake_
      : *reinterpret_cast< ::decision::ObjectOvertake*>(&::decision::_ObjectOvertake_default_instance_);
}
inline ::decision::ObjectOvertake* ObjectDecisionType::mutable_overtake() {
  if (!has_overtake()) {
    clear_object_tag();
    set_has_overtake();
    object_tag_.overtake_ = CreateMaybeMessage< ::decision::ObjectOvertake >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:decision.ObjectDecisionType.overtake)
  return object_tag_.overtake_;
}

// optional .decision.ObjectNudge nudge = 6;
inline bool ObjectDecisionType::has_nudge() const {
  return object_tag_case() == kNudge;
}
inline void ObjectDecisionType::set_has_nudge() {
  _oneof_case_[0] = kNudge;
}
inline void ObjectDecisionType::clear_nudge() {
  if (has_nudge()) {
    delete object_tag_.nudge_;
    clear_has_object_tag();
  }
}
inline ::decision::ObjectNudge* ObjectDecisionType::release_nudge() {
  // @@protoc_insertion_point(field_release:decision.ObjectDecisionType.nudge)
  if (has_nudge()) {
    clear_has_object_tag();
      ::decision::ObjectNudge* temp = object_tag_.nudge_;
    object_tag_.nudge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::decision::ObjectNudge& ObjectDecisionType::nudge() const {
  // @@protoc_insertion_point(field_get:decision.ObjectDecisionType.nudge)
  return has_nudge()
      ? *object_tag_.nudge_
      : *reinterpret_cast< ::decision::ObjectNudge*>(&::decision::_ObjectNudge_default_instance_);
}
inline ::decision::ObjectNudge* ObjectDecisionType::mutable_nudge() {
  if (!has_nudge()) {
    clear_object_tag();
    set_has_nudge();
    object_tag_.nudge_ = CreateMaybeMessage< ::decision::ObjectNudge >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:decision.ObjectDecisionType.nudge)
  return object_tag_.nudge_;
}

// optional .decision.ObjectAvoid avoid = 7;
inline bool ObjectDecisionType::has_avoid() const {
  return object_tag_case() == kAvoid;
}
inline void ObjectDecisionType::set_has_avoid() {
  _oneof_case_[0] = kAvoid;
}
inline void ObjectDecisionType::clear_avoid() {
  if (has_avoid()) {
    delete object_tag_.avoid_;
    clear_has_object_tag();
  }
}
inline ::decision::ObjectAvoid* ObjectDecisionType::release_avoid() {
  // @@protoc_insertion_point(field_release:decision.ObjectDecisionType.avoid)
  if (has_avoid()) {
    clear_has_object_tag();
      ::decision::ObjectAvoid* temp = object_tag_.avoid_;
    object_tag_.avoid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::decision::ObjectAvoid& ObjectDecisionType::avoid() const {
  // @@protoc_insertion_point(field_get:decision.ObjectDecisionType.avoid)
  return has_avoid()
      ? *object_tag_.avoid_
      : *reinterpret_cast< ::decision::ObjectAvoid*>(&::decision::_ObjectAvoid_default_instance_);
}
inline ::decision::ObjectAvoid* ObjectDecisionType::mutable_avoid() {
  if (!has_avoid()) {
    clear_object_tag();
    set_has_avoid();
    object_tag_.avoid_ = CreateMaybeMessage< ::decision::ObjectAvoid >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:decision.ObjectDecisionType.avoid)
  return object_tag_.avoid_;
}

// optional .decision.ObjectSidePass side_pass = 8;
inline bool ObjectDecisionType::has_side_pass() const {
  return object_tag_case() == kSidePass;
}
inline void ObjectDecisionType::set_has_side_pass() {
  _oneof_case_[0] = kSidePass;
}
inline void ObjectDecisionType::clear_side_pass() {
  if (has_side_pass()) {
    delete object_tag_.side_pass_;
    clear_has_object_tag();
  }
}
inline ::decision::ObjectSidePass* ObjectDecisionType::release_side_pass() {
  // @@protoc_insertion_point(field_release:decision.ObjectDecisionType.side_pass)
  if (has_side_pass()) {
    clear_has_object_tag();
      ::decision::ObjectSidePass* temp = object_tag_.side_pass_;
    object_tag_.side_pass_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::decision::ObjectSidePass& ObjectDecisionType::side_pass() const {
  // @@protoc_insertion_point(field_get:decision.ObjectDecisionType.side_pass)
  return has_side_pass()
      ? *object_tag_.side_pass_
      : *reinterpret_cast< ::decision::ObjectSidePass*>(&::decision::_ObjectSidePass_default_instance_);
}
inline ::decision::ObjectSidePass* ObjectDecisionType::mutable_side_pass() {
  if (!has_side_pass()) {
    clear_object_tag();
    set_has_side_pass();
    object_tag_.side_pass_ = CreateMaybeMessage< ::decision::ObjectSidePass >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:decision.ObjectDecisionType.side_pass)
  return object_tag_.side_pass_;
}

inline bool ObjectDecisionType::has_object_tag() const {
  return object_tag_case() != OBJECT_TAG_NOT_SET;
}
inline void ObjectDecisionType::clear_has_object_tag() {
  _oneof_case_[0] = OBJECT_TAG_NOT_SET;
}
inline ObjectDecisionType::ObjectTagCase ObjectDecisionType::object_tag_case() const {
  return ObjectDecisionType::ObjectTagCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace decision

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::decision::ObjectNudge_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::decision::ObjectNudge_Type>() {
  return ::decision::ObjectNudge_Type_descriptor();
}
template <> struct is_proto_enum< ::decision::ObjectSidePass_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::decision::ObjectSidePass_Type>() {
  return ::decision::ObjectSidePass_Type_descriptor();
}
template <> struct is_proto_enum< ::decision::StopReasonCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::decision::StopReasonCode>() {
  return ::decision::StopReasonCode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_decision_2eproto
