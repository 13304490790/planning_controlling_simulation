// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: decision.proto

#include "decision.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_decision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ObjectAvoid_decision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_decision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ObjectDynamic_decision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_decision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ObjectIgnore_decision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_decision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ObjectNudge_decision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_decision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ObjectSidePass_decision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_decision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ObjectStatic_decision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_decision_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_ObjectFollow_decision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_decision_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_ObjectOvertake_decision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_decision_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_ObjectStop_decision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_decision_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_ObjectYield_decision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_decision_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_ObjectMotionType_decision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_decision_2eproto ::google::protobuf::internal::SCCInfo<8> scc_info_ObjectDecisionType_decision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_geometry_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_PointENU_geometry_2eproto;
namespace decision {
class TargetLaneDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TargetLane> _instance;
} _TargetLane_default_instance_;
class ObjectIgnoreDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ObjectIgnore> _instance;
} _ObjectIgnore_default_instance_;
class ObjectStopDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ObjectStop> _instance;
} _ObjectStop_default_instance_;
class ObjectNudgeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ObjectNudge> _instance;
} _ObjectNudge_default_instance_;
class ObjectYieldDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ObjectYield> _instance;
} _ObjectYield_default_instance_;
class ObjectFollowDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ObjectFollow> _instance;
} _ObjectFollow_default_instance_;
class ObjectOvertakeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ObjectOvertake> _instance;
} _ObjectOvertake_default_instance_;
class ObjectSidePassDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ObjectSidePass> _instance;
} _ObjectSidePass_default_instance_;
class ObjectAvoidDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ObjectAvoid> _instance;
} _ObjectAvoid_default_instance_;
class ObjectStatusDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ObjectStatus> _instance;
} _ObjectStatus_default_instance_;
class ObjectStaticDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ObjectStatic> _instance;
} _ObjectStatic_default_instance_;
class ObjectDynamicDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ObjectDynamic> _instance;
} _ObjectDynamic_default_instance_;
class ObjectMotionTypeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ObjectMotionType> _instance;
  const ::decision::ObjectStatic* static__;
  const ::decision::ObjectDynamic* dynamic_;
} _ObjectMotionType_default_instance_;
class ObjectDecisionTypeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ObjectDecisionType> _instance;
  const ::decision::ObjectIgnore* ignore_;
  const ::decision::ObjectStop* stop_;
  const ::decision::ObjectFollow* follow_;
  const ::decision::ObjectYield* yield_;
  const ::decision::ObjectOvertake* overtake_;
  const ::decision::ObjectNudge* nudge_;
  const ::decision::ObjectAvoid* avoid_;
  const ::decision::ObjectSidePass* side_pass_;
} _ObjectDecisionType_default_instance_;
}  // namespace decision
static void InitDefaultsTargetLane_decision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::decision::_TargetLane_default_instance_;
    new (ptr) ::decision::TargetLane();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::decision::TargetLane::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_TargetLane_decision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsTargetLane_decision_2eproto}, {}};

static void InitDefaultsObjectIgnore_decision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::decision::_ObjectIgnore_default_instance_;
    new (ptr) ::decision::ObjectIgnore();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::decision::ObjectIgnore::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ObjectIgnore_decision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsObjectIgnore_decision_2eproto}, {}};

static void InitDefaultsObjectStop_decision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::decision::_ObjectStop_default_instance_;
    new (ptr) ::decision::ObjectStop();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::decision::ObjectStop::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_ObjectStop_decision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsObjectStop_decision_2eproto}, {
      &scc_info_PointENU_geometry_2eproto.base,}};

static void InitDefaultsObjectNudge_decision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::decision::_ObjectNudge_default_instance_;
    new (ptr) ::decision::ObjectNudge();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::decision::ObjectNudge::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ObjectNudge_decision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsObjectNudge_decision_2eproto}, {}};

static void InitDefaultsObjectYield_decision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::decision::_ObjectYield_default_instance_;
    new (ptr) ::decision::ObjectYield();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::decision::ObjectYield::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_ObjectYield_decision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsObjectYield_decision_2eproto}, {
      &scc_info_PointENU_geometry_2eproto.base,}};

static void InitDefaultsObjectFollow_decision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::decision::_ObjectFollow_default_instance_;
    new (ptr) ::decision::ObjectFollow();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::decision::ObjectFollow::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_ObjectFollow_decision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsObjectFollow_decision_2eproto}, {
      &scc_info_PointENU_geometry_2eproto.base,}};

static void InitDefaultsObjectOvertake_decision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::decision::_ObjectOvertake_default_instance_;
    new (ptr) ::decision::ObjectOvertake();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::decision::ObjectOvertake::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_ObjectOvertake_decision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsObjectOvertake_decision_2eproto}, {
      &scc_info_PointENU_geometry_2eproto.base,}};

static void InitDefaultsObjectSidePass_decision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::decision::_ObjectSidePass_default_instance_;
    new (ptr) ::decision::ObjectSidePass();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::decision::ObjectSidePass::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ObjectSidePass_decision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsObjectSidePass_decision_2eproto}, {}};

static void InitDefaultsObjectAvoid_decision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::decision::_ObjectAvoid_default_instance_;
    new (ptr) ::decision::ObjectAvoid();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::decision::ObjectAvoid::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ObjectAvoid_decision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsObjectAvoid_decision_2eproto}, {}};

static void InitDefaultsObjectStatus_decision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::decision::_ObjectStatus_default_instance_;
    new (ptr) ::decision::ObjectStatus();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::decision::ObjectStatus::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_ObjectStatus_decision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsObjectStatus_decision_2eproto}, {
      &scc_info_ObjectMotionType_decision_2eproto.base,
      &scc_info_ObjectDecisionType_decision_2eproto.base,}};

static void InitDefaultsObjectStatic_decision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::decision::_ObjectStatic_default_instance_;
    new (ptr) ::decision::ObjectStatic();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::decision::ObjectStatic::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ObjectStatic_decision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsObjectStatic_decision_2eproto}, {}};

static void InitDefaultsObjectDynamic_decision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::decision::_ObjectDynamic_default_instance_;
    new (ptr) ::decision::ObjectDynamic();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::decision::ObjectDynamic::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ObjectDynamic_decision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsObjectDynamic_decision_2eproto}, {}};

static void InitDefaultsObjectMotionType_decision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::decision::_ObjectMotionType_default_instance_;
    new (ptr) ::decision::ObjectMotionType();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::decision::ObjectMotionType::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_ObjectMotionType_decision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsObjectMotionType_decision_2eproto}, {
      &scc_info_ObjectStatic_decision_2eproto.base,
      &scc_info_ObjectDynamic_decision_2eproto.base,}};

static void InitDefaultsObjectDecisionType_decision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::decision::_ObjectDecisionType_default_instance_;
    new (ptr) ::decision::ObjectDecisionType();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::decision::ObjectDecisionType::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<8> scc_info_ObjectDecisionType_decision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 8, InitDefaultsObjectDecisionType_decision_2eproto}, {
      &scc_info_ObjectIgnore_decision_2eproto.base,
      &scc_info_ObjectStop_decision_2eproto.base,
      &scc_info_ObjectFollow_decision_2eproto.base,
      &scc_info_ObjectYield_decision_2eproto.base,
      &scc_info_ObjectOvertake_decision_2eproto.base,
      &scc_info_ObjectNudge_decision_2eproto.base,
      &scc_info_ObjectAvoid_decision_2eproto.base,
      &scc_info_ObjectSidePass_decision_2eproto.base,}};

void InitDefaults_decision_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_TargetLane_decision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ObjectIgnore_decision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ObjectStop_decision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ObjectNudge_decision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ObjectYield_decision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ObjectFollow_decision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ObjectOvertake_decision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ObjectSidePass_decision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ObjectAvoid_decision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ObjectStatus_decision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ObjectStatic_decision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ObjectDynamic_decision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ObjectMotionType_decision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ObjectDecisionType_decision_2eproto.base);
}

::google::protobuf::Metadata file_level_metadata_decision_2eproto[14];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors_decision_2eproto[3];
constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_decision_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_decision_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::decision::TargetLane, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::decision::TargetLane, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::decision::TargetLane, id_),
  PROTOBUF_FIELD_OFFSET(::decision::TargetLane, start_s_),
  PROTOBUF_FIELD_OFFSET(::decision::TargetLane, end_s_),
  PROTOBUF_FIELD_OFFSET(::decision::TargetLane, speed_limit_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::decision::ObjectIgnore, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectIgnore, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::decision::ObjectStop, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectStop, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::decision::ObjectStop, reason_code_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectStop, distance_s_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectStop, stop_point_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectStop, stop_heading_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectStop, wait_for_obstacle_),
  3,
  1,
  0,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::decision::ObjectNudge, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectNudge, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::decision::ObjectNudge, type_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectNudge, distance_l_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::decision::ObjectYield, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectYield, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::decision::ObjectYield, distance_s_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectYield, fence_point_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectYield, fence_heading_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectYield, time_buffer_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::decision::ObjectFollow, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectFollow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::decision::ObjectFollow, distance_s_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectFollow, fence_point_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectFollow, fence_heading_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::decision::ObjectOvertake, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectOvertake, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::decision::ObjectOvertake, distance_s_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectOvertake, fence_point_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectOvertake, fence_heading_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectOvertake, time_buffer_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::decision::ObjectSidePass, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectSidePass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::decision::ObjectSidePass, type_),
  0,
  PROTOBUF_FIELD_OFFSET(::decision::ObjectAvoid, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectAvoid, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::decision::ObjectStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::decision::ObjectStatus, motion_type_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectStatus, decision_type_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::decision::ObjectStatic, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectStatic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::decision::ObjectDynamic, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectDynamic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::decision::ObjectMotionType, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectMotionType, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::decision::ObjectMotionType, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  offsetof(::decision::ObjectMotionTypeDefaultTypeInternal, static__),
  offsetof(::decision::ObjectMotionTypeDefaultTypeInternal, dynamic_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectMotionType, motion_tag_),
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::decision::ObjectDecisionType, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectDecisionType, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::decision::ObjectDecisionType, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  offsetof(::decision::ObjectDecisionTypeDefaultTypeInternal, ignore_),
  offsetof(::decision::ObjectDecisionTypeDefaultTypeInternal, stop_),
  offsetof(::decision::ObjectDecisionTypeDefaultTypeInternal, follow_),
  offsetof(::decision::ObjectDecisionTypeDefaultTypeInternal, yield_),
  offsetof(::decision::ObjectDecisionTypeDefaultTypeInternal, overtake_),
  offsetof(::decision::ObjectDecisionTypeDefaultTypeInternal, nudge_),
  offsetof(::decision::ObjectDecisionTypeDefaultTypeInternal, avoid_),
  offsetof(::decision::ObjectDecisionTypeDefaultTypeInternal, side_pass_),
  PROTOBUF_FIELD_OFFSET(::decision::ObjectDecisionType, object_tag_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, sizeof(::decision::TargetLane)},
  { 13, 18, sizeof(::decision::ObjectIgnore)},
  { 18, 28, sizeof(::decision::ObjectStop)},
  { 33, 40, sizeof(::decision::ObjectNudge)},
  { 42, 51, sizeof(::decision::ObjectYield)},
  { 55, 63, sizeof(::decision::ObjectFollow)},
  { 66, 75, sizeof(::decision::ObjectOvertake)},
  { 79, 85, sizeof(::decision::ObjectSidePass)},
  { 86, 91, sizeof(::decision::ObjectAvoid)},
  { 91, 98, sizeof(::decision::ObjectStatus)},
  { 100, 105, sizeof(::decision::ObjectStatic)},
  { 105, 110, sizeof(::decision::ObjectDynamic)},
  { 110, 118, sizeof(::decision::ObjectMotionType)},
  { 120, 134, sizeof(::decision::ObjectDecisionType)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::decision::_TargetLane_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::decision::_ObjectIgnore_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::decision::_ObjectStop_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::decision::_ObjectNudge_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::decision::_ObjectYield_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::decision::_ObjectFollow_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::decision::_ObjectOvertake_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::decision::_ObjectSidePass_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::decision::_ObjectAvoid_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::decision::_ObjectStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::decision::_ObjectStatic_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::decision::_ObjectDynamic_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::decision::_ObjectMotionType_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::decision::_ObjectDecisionType_default_instance_),
};

::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_decision_2eproto = {
  {}, AddDescriptors_decision_2eproto, "decision.proto", schemas,
  file_default_instances, TableStruct_decision_2eproto::offsets,
  file_level_metadata_decision_2eproto, 14, file_level_enum_descriptors_decision_2eproto, file_level_service_descriptors_decision_2eproto,
};

const char descriptor_table_protodef_decision_2eproto[] =
  "\n\016decision.proto\022\010decision\032\016geometry.pro"
  "to\"M\n\nTargetLane\022\n\n\002id\030\001 \001(\t\022\017\n\007start_s\030"
  "\002 \001(\001\022\r\n\005end_s\030\003 \001(\001\022\023\n\013speed_limit\030\004 \001("
  "\001\"\016\n\014ObjectIgnore\"\250\001\n\nObjectStop\022-\n\013reas"
  "on_code\030\001 \001(\0162\030.decision.StopReasonCode\022"
  "\022\n\ndistance_s\030\002 \001(\001\022&\n\nstop_point\030\003 \001(\0132"
  "\022.geometry.PointENU\022\024\n\014stop_heading\030\004 \001("
  "\001\022\031\n\021wait_for_obstacle\030\005 \003(\t\"\245\001\n\013ObjectN"
  "udge\022(\n\004type\030\001 \001(\0162\032.decision.ObjectNudg"
  "e.Type\022\022\n\ndistance_l\030\002 \001(\001\"X\n\004Type\022\016\n\nLE"
  "FT_NUDGE\020\001\022\017\n\013RIGHT_NUDGE\020\002\022\026\n\022DYNAMIC_L"
  "EFT_NUDGE\020\003\022\027\n\023DYNAMIC_RIGHT_NUDGE\020\004\"v\n\013"
  "ObjectYield\022\022\n\ndistance_s\030\001 \001(\001\022\'\n\013fence"
  "_point\030\002 \001(\0132\022.geometry.PointENU\022\025\n\rfenc"
  "e_heading\030\003 \001(\001\022\023\n\013time_buffer\030\004 \001(\001\"b\n\014"
  "ObjectFollow\022\022\n\ndistance_s\030\001 \001(\001\022\'\n\013fenc"
  "e_point\030\002 \001(\0132\022.geometry.PointENU\022\025\n\rfen"
  "ce_heading\030\003 \001(\001\"y\n\016ObjectOvertake\022\022\n\ndi"
  "stance_s\030\001 \001(\001\022\'\n\013fence_point\030\002 \001(\0132\022.ge"
  "ometry.PointENU\022\025\n\rfence_heading\030\003 \001(\001\022\023"
  "\n\013time_buffer\030\004 \001(\001\"Z\n\016ObjectSidePass\022+\n"
  "\004type\030\001 \001(\0162\035.decision.ObjectSidePass.Ty"
  "pe\"\033\n\004Type\022\010\n\004LEFT\020\001\022\t\n\005RIGHT\020\002\"\r\n\013Objec"
  "tAvoid\"t\n\014ObjectStatus\022/\n\013motion_type\030\001 "
  "\001(\0132\032.decision.ObjectMotionType\0223\n\rdecis"
  "ion_type\030\002 \001(\0132\034.decision.ObjectDecision"
  "Type\"\016\n\014ObjectStatic\"\017\n\rObjectDynamic\"v\n"
  "\020ObjectMotionType\022(\n\006static\030\001 \001(\0132\026.deci"
  "sion.ObjectStaticH\000\022*\n\007dynamic\030\002 \001(\0132\027.d"
  "ecision.ObjectDynamicH\000B\014\n\nmotion_tag\"\361\002"
  "\n\022ObjectDecisionType\022(\n\006ignore\030\001 \001(\0132\026.d"
  "ecision.ObjectIgnoreH\000\022$\n\004stop\030\002 \001(\0132\024.d"
  "ecision.ObjectStopH\000\022(\n\006follow\030\003 \001(\0132\026.d"
  "ecision.ObjectFollowH\000\022&\n\005yield\030\004 \001(\0132\025."
  "decision.ObjectYieldH\000\022,\n\010overtake\030\005 \001(\013"
  "2\030.decision.ObjectOvertakeH\000\022&\n\005nudge\030\006 "
  "\001(\0132\025.decision.ObjectNudgeH\000\022&\n\005avoid\030\007 "
  "\001(\0132\025.decision.ObjectAvoidH\000\022-\n\tside_pas"
  "s\030\010 \001(\0132\030.decision.ObjectSidePassH\000B\014\n\no"
  "bject_tag*\236\004\n\016StopReasonCode\022\034\n\030STOP_REA"
  "SON_HEAD_VEHICLE\020\001\022\033\n\027STOP_REASON_DESTIN"
  "ATION\020\002\022\032\n\026STOP_REASON_PEDESTRIAN\020\003\022\030\n\024S"
  "TOP_REASON_OBSTACLE\020\004\022\032\n\026STOP_REASON_PRE"
  "PARKING\020\005\022\026\n\022STOP_REASON_SIGNAL\020d\022\031\n\025STO"
  "P_REASON_STOP_SIGN\020e\022\032\n\026STOP_REASON_YIEL"
  "D_SIGN\020f\022\032\n\026STOP_REASON_CLEAR_ZONE\020g\022\031\n\025"
  "STOP_REASON_CROSSWALK\020h\022\027\n\023STOP_REASON_C"
  "REEPER\020i\022\035\n\031STOP_REASON_REFERENCE_END\020j\022"
  "\035\n\031STOP_REASON_YELLOW_SIGNAL\020k\022\031\n\025STOP_R"
  "EASON_PULL_OVER\020l\022\037\n\033STOP_REASON_SIDEPAS"
  "S_SAFETY\020m\022$\n\037STOP_REASON_PRE_OPEN_SPACE"
  "_STOP\020\310\001\022$\n\037STOP_REASON_LANE_CHANGE_URGE"
  "NCY\020\311\001\022\032\n\025STOP_REASON_EMERGENCY\020\312\001"
  ;
::google::protobuf::internal::DescriptorTable descriptor_table_decision_2eproto = {
  false, InitDefaults_decision_2eproto, 
  descriptor_table_protodef_decision_2eproto,
  "decision.proto", &assign_descriptors_table_decision_2eproto, 2114,
};

void AddDescriptors_decision_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
    ::AddDescriptors_geometry_2eproto,
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_decision_2eproto, deps, 1);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_decision_2eproto = []() { AddDescriptors_decision_2eproto(); return true; }();
namespace decision {
const ::google::protobuf::EnumDescriptor* ObjectNudge_Type_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_decision_2eproto);
  return file_level_enum_descriptors_decision_2eproto[0];
}
bool ObjectNudge_Type_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ObjectNudge_Type ObjectNudge::LEFT_NUDGE;
const ObjectNudge_Type ObjectNudge::RIGHT_NUDGE;
const ObjectNudge_Type ObjectNudge::DYNAMIC_LEFT_NUDGE;
const ObjectNudge_Type ObjectNudge::DYNAMIC_RIGHT_NUDGE;
const ObjectNudge_Type ObjectNudge::Type_MIN;
const ObjectNudge_Type ObjectNudge::Type_MAX;
const int ObjectNudge::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* ObjectSidePass_Type_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_decision_2eproto);
  return file_level_enum_descriptors_decision_2eproto[1];
}
bool ObjectSidePass_Type_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ObjectSidePass_Type ObjectSidePass::LEFT;
const ObjectSidePass_Type ObjectSidePass::RIGHT;
const ObjectSidePass_Type ObjectSidePass::Type_MIN;
const ObjectSidePass_Type ObjectSidePass::Type_MAX;
const int ObjectSidePass::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* StopReasonCode_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_decision_2eproto);
  return file_level_enum_descriptors_decision_2eproto[2];
}
bool StopReasonCode_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 200:
    case 201:
    case 202:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void TargetLane::InitAsDefaultInstance() {
}
class TargetLane::HasBitSetters {
 public:
  static void set_has_id(TargetLane* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_start_s(TargetLane* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_end_s(TargetLane* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_speed_limit(TargetLane* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TargetLane::kIdFieldNumber;
const int TargetLane::kStartSFieldNumber;
const int TargetLane::kEndSFieldNumber;
const int TargetLane::kSpeedLimitFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TargetLane::TargetLane()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:decision.TargetLane)
}
TargetLane::TargetLane(const TargetLane& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_id()) {
    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
  ::memcpy(&start_s_, &from.start_s_,
    static_cast<size_t>(reinterpret_cast<char*>(&speed_limit_) -
    reinterpret_cast<char*>(&start_s_)) + sizeof(speed_limit_));
  // @@protoc_insertion_point(copy_constructor:decision.TargetLane)
}

void TargetLane::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_TargetLane_decision_2eproto.base);
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&start_s_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&speed_limit_) -
      reinterpret_cast<char*>(&start_s_)) + sizeof(speed_limit_));
}

TargetLane::~TargetLane() {
  // @@protoc_insertion_point(destructor:decision.TargetLane)
  SharedDtor();
}

void TargetLane::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TargetLane::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TargetLane& TargetLane::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_TargetLane_decision_2eproto.base);
  return *internal_default_instance();
}


void TargetLane::Clear() {
// @@protoc_insertion_point(message_clear_start:decision.TargetLane)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    id_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&start_s_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&speed_limit_) -
        reinterpret_cast<char*>(&start_s_)) + sizeof(speed_limit_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TargetLane::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<TargetLane*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("decision.TargetLane.id");
        object = msg->mutable_id();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional double start_s = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_start_s(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double end_s = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_end_s(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double speed_limit = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_speed_limit(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TargetLane::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:decision.TargetLane)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), static_cast<int>(this->id().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "decision.TargetLane.id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double start_s = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_start_s(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &start_s_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double end_s = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_end_s(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &end_s_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double speed_limit = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {
          HasBitSetters::set_has_speed_limit(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &speed_limit_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:decision.TargetLane)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:decision.TargetLane)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TargetLane::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:decision.TargetLane)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), static_cast<int>(this->id().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "decision.TargetLane.id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  // optional double start_s = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->start_s(), output);
  }

  // optional double end_s = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->end_s(), output);
  }

  // optional double speed_limit = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->speed_limit(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:decision.TargetLane)
}

::google::protobuf::uint8* TargetLane::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:decision.TargetLane)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), static_cast<int>(this->id().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "decision.TargetLane.id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }

  // optional double start_s = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->start_s(), target);
  }

  // optional double end_s = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->end_s(), target);
  }

  // optional double speed_limit = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->speed_limit(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:decision.TargetLane)
  return target;
}

size_t TargetLane::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:decision.TargetLane)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->id());
    }

    // optional double start_s = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double end_s = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double speed_limit = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TargetLane::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:decision.TargetLane)
  GOOGLE_DCHECK_NE(&from, this);
  const TargetLane* source =
      ::google::protobuf::DynamicCastToGenerated<TargetLane>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:decision.TargetLane)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:decision.TargetLane)
    MergeFrom(*source);
  }
}

void TargetLane::MergeFrom(const TargetLane& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:decision.TargetLane)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
    }
    if (cached_has_bits & 0x00000002u) {
      start_s_ = from.start_s_;
    }
    if (cached_has_bits & 0x00000004u) {
      end_s_ = from.end_s_;
    }
    if (cached_has_bits & 0x00000008u) {
      speed_limit_ = from.speed_limit_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TargetLane::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:decision.TargetLane)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TargetLane::CopyFrom(const TargetLane& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:decision.TargetLane)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TargetLane::IsInitialized() const {
  return true;
}

void TargetLane::Swap(TargetLane* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TargetLane::InternalSwap(TargetLane* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  id_.Swap(&other->id_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(start_s_, other->start_s_);
  swap(end_s_, other->end_s_);
  swap(speed_limit_, other->speed_limit_);
}

::google::protobuf::Metadata TargetLane::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_decision_2eproto);
  return ::file_level_metadata_decision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ObjectIgnore::InitAsDefaultInstance() {
}
class ObjectIgnore::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObjectIgnore::ObjectIgnore()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:decision.ObjectIgnore)
}
ObjectIgnore::ObjectIgnore(const ObjectIgnore& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:decision.ObjectIgnore)
}

void ObjectIgnore::SharedCtor() {
}

ObjectIgnore::~ObjectIgnore() {
  // @@protoc_insertion_point(destructor:decision.ObjectIgnore)
  SharedDtor();
}

void ObjectIgnore::SharedDtor() {
}

void ObjectIgnore::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObjectIgnore& ObjectIgnore::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ObjectIgnore_decision_2eproto.base);
  return *internal_default_instance();
}


void ObjectIgnore::Clear() {
// @@protoc_insertion_point(message_clear_start:decision.ObjectIgnore)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObjectIgnore::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ObjectIgnore*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObjectIgnore::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:decision.ObjectIgnore)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, _internal_metadata_.mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:decision.ObjectIgnore)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:decision.ObjectIgnore)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObjectIgnore::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:decision.ObjectIgnore)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:decision.ObjectIgnore)
}

::google::protobuf::uint8* ObjectIgnore::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:decision.ObjectIgnore)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:decision.ObjectIgnore)
  return target;
}

size_t ObjectIgnore::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:decision.ObjectIgnore)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObjectIgnore::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:decision.ObjectIgnore)
  GOOGLE_DCHECK_NE(&from, this);
  const ObjectIgnore* source =
      ::google::protobuf::DynamicCastToGenerated<ObjectIgnore>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:decision.ObjectIgnore)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:decision.ObjectIgnore)
    MergeFrom(*source);
  }
}

void ObjectIgnore::MergeFrom(const ObjectIgnore& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:decision.ObjectIgnore)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void ObjectIgnore::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:decision.ObjectIgnore)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObjectIgnore::CopyFrom(const ObjectIgnore& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:decision.ObjectIgnore)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectIgnore::IsInitialized() const {
  return true;
}

void ObjectIgnore::Swap(ObjectIgnore* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObjectIgnore::InternalSwap(ObjectIgnore* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::google::protobuf::Metadata ObjectIgnore::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_decision_2eproto);
  return ::file_level_metadata_decision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ObjectStop::InitAsDefaultInstance() {
  ::decision::_ObjectStop_default_instance_._instance.get_mutable()->stop_point_ = const_cast< ::geometry::PointENU*>(
      ::geometry::PointENU::internal_default_instance());
}
class ObjectStop::HasBitSetters {
 public:
  static void set_has_reason_code(ObjectStop* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_distance_s(ObjectStop* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::geometry::PointENU& stop_point(const ObjectStop* msg);
  static void set_has_stop_point(ObjectStop* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_stop_heading(ObjectStop* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::geometry::PointENU&
ObjectStop::HasBitSetters::stop_point(const ObjectStop* msg) {
  return *msg->stop_point_;
}
void ObjectStop::clear_stop_point() {
  if (stop_point_ != nullptr) stop_point_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObjectStop::kReasonCodeFieldNumber;
const int ObjectStop::kDistanceSFieldNumber;
const int ObjectStop::kStopPointFieldNumber;
const int ObjectStop::kStopHeadingFieldNumber;
const int ObjectStop::kWaitForObstacleFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObjectStop::ObjectStop()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:decision.ObjectStop)
}
ObjectStop::ObjectStop(const ObjectStop& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      wait_for_obstacle_(from.wait_for_obstacle_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_stop_point()) {
    stop_point_ = new ::geometry::PointENU(*from.stop_point_);
  } else {
    stop_point_ = nullptr;
  }
  ::memcpy(&distance_s_, &from.distance_s_,
    static_cast<size_t>(reinterpret_cast<char*>(&reason_code_) -
    reinterpret_cast<char*>(&distance_s_)) + sizeof(reason_code_));
  // @@protoc_insertion_point(copy_constructor:decision.ObjectStop)
}

void ObjectStop::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ObjectStop_decision_2eproto.base);
  ::memset(&stop_point_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&stop_heading_) -
      reinterpret_cast<char*>(&stop_point_)) + sizeof(stop_heading_));
  reason_code_ = 1;
}

ObjectStop::~ObjectStop() {
  // @@protoc_insertion_point(destructor:decision.ObjectStop)
  SharedDtor();
}

void ObjectStop::SharedDtor() {
  if (this != internal_default_instance()) delete stop_point_;
}

void ObjectStop::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObjectStop& ObjectStop::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ObjectStop_decision_2eproto.base);
  return *internal_default_instance();
}


void ObjectStop::Clear() {
// @@protoc_insertion_point(message_clear_start:decision.ObjectStop)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  wait_for_obstacle_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(stop_point_ != nullptr);
    stop_point_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&distance_s_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&stop_heading_) -
        reinterpret_cast<char*>(&distance_s_)) + sizeof(stop_heading_));
    reason_code_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObjectStop::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ObjectStop*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .decision.StopReasonCode reason_code = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::decision::StopReasonCode_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_reason_code(static_cast<::decision::StopReasonCode>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional double distance_s = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_distance_s(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional .geometry.PointENU stop_point = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::geometry::PointENU::_InternalParse;
        object = msg->mutable_stop_point();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional double stop_heading = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_stop_heading(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // repeated string wait_for_obstacle = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          ctx->extra_parse_data().SetFieldName("decision.ObjectStop.wait_for_obstacle");
          object = msg->add_wait_for_obstacle();
          if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
            parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
            goto string_till_end;
          }
          GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
          ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
          ptr += size;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 42 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObjectStop::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:decision.ObjectStop)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .decision.StopReasonCode reason_code = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::decision::StopReasonCode_IsValid(value)) {
            set_reason_code(static_cast< ::decision::StopReasonCode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double distance_s = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_distance_s(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &distance_s_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .geometry.PointENU stop_point = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_stop_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double stop_heading = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {
          HasBitSetters::set_has_stop_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &stop_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string wait_for_obstacle = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_wait_for_obstacle()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->wait_for_obstacle(this->wait_for_obstacle_size() - 1).data(),
            static_cast<int>(this->wait_for_obstacle(this->wait_for_obstacle_size() - 1).length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "decision.ObjectStop.wait_for_obstacle");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:decision.ObjectStop)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:decision.ObjectStop)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObjectStop::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:decision.ObjectStop)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .decision.StopReasonCode reason_code = 1;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->reason_code(), output);
  }

  // optional double distance_s = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->distance_s(), output);
  }

  // optional .geometry.PointENU stop_point = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::stop_point(this), output);
  }

  // optional double stop_heading = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->stop_heading(), output);
  }

  // repeated string wait_for_obstacle = 5;
  for (int i = 0, n = this->wait_for_obstacle_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->wait_for_obstacle(i).data(), static_cast<int>(this->wait_for_obstacle(i).length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "decision.ObjectStop.wait_for_obstacle");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->wait_for_obstacle(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:decision.ObjectStop)
}

::google::protobuf::uint8* ObjectStop::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:decision.ObjectStop)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .decision.StopReasonCode reason_code = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->reason_code(), target);
  }

  // optional double distance_s = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->distance_s(), target);
  }

  // optional .geometry.PointENU stop_point = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::stop_point(this), target);
  }

  // optional double stop_heading = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->stop_heading(), target);
  }

  // repeated string wait_for_obstacle = 5;
  for (int i = 0, n = this->wait_for_obstacle_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->wait_for_obstacle(i).data(), static_cast<int>(this->wait_for_obstacle(i).length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "decision.ObjectStop.wait_for_obstacle");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(5, this->wait_for_obstacle(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:decision.ObjectStop)
  return target;
}

size_t ObjectStop::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:decision.ObjectStop)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string wait_for_obstacle = 5;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->wait_for_obstacle_size());
  for (int i = 0, n = this->wait_for_obstacle_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->wait_for_obstacle(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .geometry.PointENU stop_point = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *stop_point_);
    }

    // optional double distance_s = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double stop_heading = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional .decision.StopReasonCode reason_code = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->reason_code());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObjectStop::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:decision.ObjectStop)
  GOOGLE_DCHECK_NE(&from, this);
  const ObjectStop* source =
      ::google::protobuf::DynamicCastToGenerated<ObjectStop>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:decision.ObjectStop)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:decision.ObjectStop)
    MergeFrom(*source);
  }
}

void ObjectStop::MergeFrom(const ObjectStop& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:decision.ObjectStop)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  wait_for_obstacle_.MergeFrom(from.wait_for_obstacle_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_stop_point()->::geometry::PointENU::MergeFrom(from.stop_point());
    }
    if (cached_has_bits & 0x00000002u) {
      distance_s_ = from.distance_s_;
    }
    if (cached_has_bits & 0x00000004u) {
      stop_heading_ = from.stop_heading_;
    }
    if (cached_has_bits & 0x00000008u) {
      reason_code_ = from.reason_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ObjectStop::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:decision.ObjectStop)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObjectStop::CopyFrom(const ObjectStop& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:decision.ObjectStop)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectStop::IsInitialized() const {
  return true;
}

void ObjectStop::Swap(ObjectStop* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObjectStop::InternalSwap(ObjectStop* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  wait_for_obstacle_.InternalSwap(CastToBase(&other->wait_for_obstacle_));
  swap(stop_point_, other->stop_point_);
  swap(distance_s_, other->distance_s_);
  swap(stop_heading_, other->stop_heading_);
  swap(reason_code_, other->reason_code_);
}

::google::protobuf::Metadata ObjectStop::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_decision_2eproto);
  return ::file_level_metadata_decision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ObjectNudge::InitAsDefaultInstance() {
}
class ObjectNudge::HasBitSetters {
 public:
  static void set_has_type(ObjectNudge* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_distance_l(ObjectNudge* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObjectNudge::kTypeFieldNumber;
const int ObjectNudge::kDistanceLFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObjectNudge::ObjectNudge()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:decision.ObjectNudge)
}
ObjectNudge::ObjectNudge(const ObjectNudge& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&distance_l_, &from.distance_l_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&distance_l_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:decision.ObjectNudge)
}

void ObjectNudge::SharedCtor() {
  distance_l_ = 0;
  type_ = 1;
}

ObjectNudge::~ObjectNudge() {
  // @@protoc_insertion_point(destructor:decision.ObjectNudge)
  SharedDtor();
}

void ObjectNudge::SharedDtor() {
}

void ObjectNudge::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObjectNudge& ObjectNudge::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ObjectNudge_decision_2eproto.base);
  return *internal_default_instance();
}


void ObjectNudge::Clear() {
// @@protoc_insertion_point(message_clear_start:decision.ObjectNudge)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    distance_l_ = 0;
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObjectNudge::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ObjectNudge*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .decision.ObjectNudge.Type type = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::decision::ObjectNudge_Type_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_type(static_cast<::decision::ObjectNudge_Type>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional double distance_l = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_distance_l(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObjectNudge::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:decision.ObjectNudge)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .decision.ObjectNudge.Type type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::decision::ObjectNudge_Type_IsValid(value)) {
            set_type(static_cast< ::decision::ObjectNudge_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double distance_l = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_distance_l(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &distance_l_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:decision.ObjectNudge)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:decision.ObjectNudge)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObjectNudge::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:decision.ObjectNudge)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .decision.ObjectNudge.Type type = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional double distance_l = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->distance_l(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:decision.ObjectNudge)
}

::google::protobuf::uint8* ObjectNudge::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:decision.ObjectNudge)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .decision.ObjectNudge.Type type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional double distance_l = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->distance_l(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:decision.ObjectNudge)
  return target;
}

size_t ObjectNudge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:decision.ObjectNudge)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double distance_l = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional .decision.ObjectNudge.Type type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObjectNudge::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:decision.ObjectNudge)
  GOOGLE_DCHECK_NE(&from, this);
  const ObjectNudge* source =
      ::google::protobuf::DynamicCastToGenerated<ObjectNudge>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:decision.ObjectNudge)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:decision.ObjectNudge)
    MergeFrom(*source);
  }
}

void ObjectNudge::MergeFrom(const ObjectNudge& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:decision.ObjectNudge)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      distance_l_ = from.distance_l_;
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ObjectNudge::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:decision.ObjectNudge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObjectNudge::CopyFrom(const ObjectNudge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:decision.ObjectNudge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectNudge::IsInitialized() const {
  return true;
}

void ObjectNudge::Swap(ObjectNudge* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObjectNudge::InternalSwap(ObjectNudge* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(distance_l_, other->distance_l_);
  swap(type_, other->type_);
}

::google::protobuf::Metadata ObjectNudge::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_decision_2eproto);
  return ::file_level_metadata_decision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ObjectYield::InitAsDefaultInstance() {
  ::decision::_ObjectYield_default_instance_._instance.get_mutable()->fence_point_ = const_cast< ::geometry::PointENU*>(
      ::geometry::PointENU::internal_default_instance());
}
class ObjectYield::HasBitSetters {
 public:
  static void set_has_distance_s(ObjectYield* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::geometry::PointENU& fence_point(const ObjectYield* msg);
  static void set_has_fence_point(ObjectYield* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_fence_heading(ObjectYield* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_time_buffer(ObjectYield* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

const ::geometry::PointENU&
ObjectYield::HasBitSetters::fence_point(const ObjectYield* msg) {
  return *msg->fence_point_;
}
void ObjectYield::clear_fence_point() {
  if (fence_point_ != nullptr) fence_point_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObjectYield::kDistanceSFieldNumber;
const int ObjectYield::kFencePointFieldNumber;
const int ObjectYield::kFenceHeadingFieldNumber;
const int ObjectYield::kTimeBufferFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObjectYield::ObjectYield()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:decision.ObjectYield)
}
ObjectYield::ObjectYield(const ObjectYield& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_fence_point()) {
    fence_point_ = new ::geometry::PointENU(*from.fence_point_);
  } else {
    fence_point_ = nullptr;
  }
  ::memcpy(&distance_s_, &from.distance_s_,
    static_cast<size_t>(reinterpret_cast<char*>(&time_buffer_) -
    reinterpret_cast<char*>(&distance_s_)) + sizeof(time_buffer_));
  // @@protoc_insertion_point(copy_constructor:decision.ObjectYield)
}

void ObjectYield::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ObjectYield_decision_2eproto.base);
  ::memset(&fence_point_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&time_buffer_) -
      reinterpret_cast<char*>(&fence_point_)) + sizeof(time_buffer_));
}

ObjectYield::~ObjectYield() {
  // @@protoc_insertion_point(destructor:decision.ObjectYield)
  SharedDtor();
}

void ObjectYield::SharedDtor() {
  if (this != internal_default_instance()) delete fence_point_;
}

void ObjectYield::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObjectYield& ObjectYield::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ObjectYield_decision_2eproto.base);
  return *internal_default_instance();
}


void ObjectYield::Clear() {
// @@protoc_insertion_point(message_clear_start:decision.ObjectYield)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(fence_point_ != nullptr);
    fence_point_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&distance_s_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&time_buffer_) -
        reinterpret_cast<char*>(&distance_s_)) + sizeof(time_buffer_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObjectYield::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ObjectYield*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional double distance_s = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_distance_s(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional .geometry.PointENU fence_point = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::geometry::PointENU::_InternalParse;
        object = msg->mutable_fence_point();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional double fence_heading = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_fence_heading(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double time_buffer = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_time_buffer(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObjectYield::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:decision.ObjectYield)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double distance_s = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_distance_s(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &distance_s_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .geometry.PointENU fence_point = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_fence_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double fence_heading = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_fence_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &fence_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double time_buffer = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {
          HasBitSetters::set_has_time_buffer(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &time_buffer_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:decision.ObjectYield)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:decision.ObjectYield)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObjectYield::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:decision.ObjectYield)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double distance_s = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->distance_s(), output);
  }

  // optional .geometry.PointENU fence_point = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::fence_point(this), output);
  }

  // optional double fence_heading = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->fence_heading(), output);
  }

  // optional double time_buffer = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->time_buffer(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:decision.ObjectYield)
}

::google::protobuf::uint8* ObjectYield::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:decision.ObjectYield)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double distance_s = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->distance_s(), target);
  }

  // optional .geometry.PointENU fence_point = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::fence_point(this), target);
  }

  // optional double fence_heading = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->fence_heading(), target);
  }

  // optional double time_buffer = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->time_buffer(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:decision.ObjectYield)
  return target;
}

size_t ObjectYield::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:decision.ObjectYield)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .geometry.PointENU fence_point = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *fence_point_);
    }

    // optional double distance_s = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double fence_heading = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double time_buffer = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObjectYield::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:decision.ObjectYield)
  GOOGLE_DCHECK_NE(&from, this);
  const ObjectYield* source =
      ::google::protobuf::DynamicCastToGenerated<ObjectYield>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:decision.ObjectYield)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:decision.ObjectYield)
    MergeFrom(*source);
  }
}

void ObjectYield::MergeFrom(const ObjectYield& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:decision.ObjectYield)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_fence_point()->::geometry::PointENU::MergeFrom(from.fence_point());
    }
    if (cached_has_bits & 0x00000002u) {
      distance_s_ = from.distance_s_;
    }
    if (cached_has_bits & 0x00000004u) {
      fence_heading_ = from.fence_heading_;
    }
    if (cached_has_bits & 0x00000008u) {
      time_buffer_ = from.time_buffer_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ObjectYield::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:decision.ObjectYield)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObjectYield::CopyFrom(const ObjectYield& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:decision.ObjectYield)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectYield::IsInitialized() const {
  return true;
}

void ObjectYield::Swap(ObjectYield* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObjectYield::InternalSwap(ObjectYield* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(fence_point_, other->fence_point_);
  swap(distance_s_, other->distance_s_);
  swap(fence_heading_, other->fence_heading_);
  swap(time_buffer_, other->time_buffer_);
}

::google::protobuf::Metadata ObjectYield::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_decision_2eproto);
  return ::file_level_metadata_decision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ObjectFollow::InitAsDefaultInstance() {
  ::decision::_ObjectFollow_default_instance_._instance.get_mutable()->fence_point_ = const_cast< ::geometry::PointENU*>(
      ::geometry::PointENU::internal_default_instance());
}
class ObjectFollow::HasBitSetters {
 public:
  static void set_has_distance_s(ObjectFollow* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::geometry::PointENU& fence_point(const ObjectFollow* msg);
  static void set_has_fence_point(ObjectFollow* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_fence_heading(ObjectFollow* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::geometry::PointENU&
ObjectFollow::HasBitSetters::fence_point(const ObjectFollow* msg) {
  return *msg->fence_point_;
}
void ObjectFollow::clear_fence_point() {
  if (fence_point_ != nullptr) fence_point_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObjectFollow::kDistanceSFieldNumber;
const int ObjectFollow::kFencePointFieldNumber;
const int ObjectFollow::kFenceHeadingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObjectFollow::ObjectFollow()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:decision.ObjectFollow)
}
ObjectFollow::ObjectFollow(const ObjectFollow& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_fence_point()) {
    fence_point_ = new ::geometry::PointENU(*from.fence_point_);
  } else {
    fence_point_ = nullptr;
  }
  ::memcpy(&distance_s_, &from.distance_s_,
    static_cast<size_t>(reinterpret_cast<char*>(&fence_heading_) -
    reinterpret_cast<char*>(&distance_s_)) + sizeof(fence_heading_));
  // @@protoc_insertion_point(copy_constructor:decision.ObjectFollow)
}

void ObjectFollow::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ObjectFollow_decision_2eproto.base);
  ::memset(&fence_point_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&fence_heading_) -
      reinterpret_cast<char*>(&fence_point_)) + sizeof(fence_heading_));
}

ObjectFollow::~ObjectFollow() {
  // @@protoc_insertion_point(destructor:decision.ObjectFollow)
  SharedDtor();
}

void ObjectFollow::SharedDtor() {
  if (this != internal_default_instance()) delete fence_point_;
}

void ObjectFollow::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObjectFollow& ObjectFollow::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ObjectFollow_decision_2eproto.base);
  return *internal_default_instance();
}


void ObjectFollow::Clear() {
// @@protoc_insertion_point(message_clear_start:decision.ObjectFollow)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(fence_point_ != nullptr);
    fence_point_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&distance_s_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fence_heading_) -
        reinterpret_cast<char*>(&distance_s_)) + sizeof(fence_heading_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObjectFollow::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ObjectFollow*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional double distance_s = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_distance_s(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional .geometry.PointENU fence_point = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::geometry::PointENU::_InternalParse;
        object = msg->mutable_fence_point();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional double fence_heading = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_fence_heading(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObjectFollow::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:decision.ObjectFollow)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double distance_s = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_distance_s(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &distance_s_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .geometry.PointENU fence_point = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_fence_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double fence_heading = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_fence_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &fence_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:decision.ObjectFollow)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:decision.ObjectFollow)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObjectFollow::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:decision.ObjectFollow)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double distance_s = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->distance_s(), output);
  }

  // optional .geometry.PointENU fence_point = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::fence_point(this), output);
  }

  // optional double fence_heading = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->fence_heading(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:decision.ObjectFollow)
}

::google::protobuf::uint8* ObjectFollow::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:decision.ObjectFollow)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double distance_s = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->distance_s(), target);
  }

  // optional .geometry.PointENU fence_point = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::fence_point(this), target);
  }

  // optional double fence_heading = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->fence_heading(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:decision.ObjectFollow)
  return target;
}

size_t ObjectFollow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:decision.ObjectFollow)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .geometry.PointENU fence_point = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *fence_point_);
    }

    // optional double distance_s = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double fence_heading = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObjectFollow::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:decision.ObjectFollow)
  GOOGLE_DCHECK_NE(&from, this);
  const ObjectFollow* source =
      ::google::protobuf::DynamicCastToGenerated<ObjectFollow>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:decision.ObjectFollow)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:decision.ObjectFollow)
    MergeFrom(*source);
  }
}

void ObjectFollow::MergeFrom(const ObjectFollow& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:decision.ObjectFollow)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_fence_point()->::geometry::PointENU::MergeFrom(from.fence_point());
    }
    if (cached_has_bits & 0x00000002u) {
      distance_s_ = from.distance_s_;
    }
    if (cached_has_bits & 0x00000004u) {
      fence_heading_ = from.fence_heading_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ObjectFollow::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:decision.ObjectFollow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObjectFollow::CopyFrom(const ObjectFollow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:decision.ObjectFollow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectFollow::IsInitialized() const {
  return true;
}

void ObjectFollow::Swap(ObjectFollow* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObjectFollow::InternalSwap(ObjectFollow* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(fence_point_, other->fence_point_);
  swap(distance_s_, other->distance_s_);
  swap(fence_heading_, other->fence_heading_);
}

::google::protobuf::Metadata ObjectFollow::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_decision_2eproto);
  return ::file_level_metadata_decision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ObjectOvertake::InitAsDefaultInstance() {
  ::decision::_ObjectOvertake_default_instance_._instance.get_mutable()->fence_point_ = const_cast< ::geometry::PointENU*>(
      ::geometry::PointENU::internal_default_instance());
}
class ObjectOvertake::HasBitSetters {
 public:
  static void set_has_distance_s(ObjectOvertake* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::geometry::PointENU& fence_point(const ObjectOvertake* msg);
  static void set_has_fence_point(ObjectOvertake* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_fence_heading(ObjectOvertake* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_time_buffer(ObjectOvertake* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

const ::geometry::PointENU&
ObjectOvertake::HasBitSetters::fence_point(const ObjectOvertake* msg) {
  return *msg->fence_point_;
}
void ObjectOvertake::clear_fence_point() {
  if (fence_point_ != nullptr) fence_point_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObjectOvertake::kDistanceSFieldNumber;
const int ObjectOvertake::kFencePointFieldNumber;
const int ObjectOvertake::kFenceHeadingFieldNumber;
const int ObjectOvertake::kTimeBufferFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObjectOvertake::ObjectOvertake()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:decision.ObjectOvertake)
}
ObjectOvertake::ObjectOvertake(const ObjectOvertake& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_fence_point()) {
    fence_point_ = new ::geometry::PointENU(*from.fence_point_);
  } else {
    fence_point_ = nullptr;
  }
  ::memcpy(&distance_s_, &from.distance_s_,
    static_cast<size_t>(reinterpret_cast<char*>(&time_buffer_) -
    reinterpret_cast<char*>(&distance_s_)) + sizeof(time_buffer_));
  // @@protoc_insertion_point(copy_constructor:decision.ObjectOvertake)
}

void ObjectOvertake::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ObjectOvertake_decision_2eproto.base);
  ::memset(&fence_point_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&time_buffer_) -
      reinterpret_cast<char*>(&fence_point_)) + sizeof(time_buffer_));
}

ObjectOvertake::~ObjectOvertake() {
  // @@protoc_insertion_point(destructor:decision.ObjectOvertake)
  SharedDtor();
}

void ObjectOvertake::SharedDtor() {
  if (this != internal_default_instance()) delete fence_point_;
}

void ObjectOvertake::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObjectOvertake& ObjectOvertake::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ObjectOvertake_decision_2eproto.base);
  return *internal_default_instance();
}


void ObjectOvertake::Clear() {
// @@protoc_insertion_point(message_clear_start:decision.ObjectOvertake)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(fence_point_ != nullptr);
    fence_point_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&distance_s_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&time_buffer_) -
        reinterpret_cast<char*>(&distance_s_)) + sizeof(time_buffer_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObjectOvertake::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ObjectOvertake*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional double distance_s = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_distance_s(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional .geometry.PointENU fence_point = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::geometry::PointENU::_InternalParse;
        object = msg->mutable_fence_point();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional double fence_heading = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_fence_heading(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // optional double time_buffer = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_time_buffer(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObjectOvertake::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:decision.ObjectOvertake)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double distance_s = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_distance_s(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &distance_s_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .geometry.PointENU fence_point = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_fence_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double fence_heading = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_fence_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &fence_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double time_buffer = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {
          HasBitSetters::set_has_time_buffer(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &time_buffer_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:decision.ObjectOvertake)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:decision.ObjectOvertake)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObjectOvertake::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:decision.ObjectOvertake)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double distance_s = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->distance_s(), output);
  }

  // optional .geometry.PointENU fence_point = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::fence_point(this), output);
  }

  // optional double fence_heading = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->fence_heading(), output);
  }

  // optional double time_buffer = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->time_buffer(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:decision.ObjectOvertake)
}

::google::protobuf::uint8* ObjectOvertake::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:decision.ObjectOvertake)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double distance_s = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->distance_s(), target);
  }

  // optional .geometry.PointENU fence_point = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::fence_point(this), target);
  }

  // optional double fence_heading = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->fence_heading(), target);
  }

  // optional double time_buffer = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->time_buffer(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:decision.ObjectOvertake)
  return target;
}

size_t ObjectOvertake::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:decision.ObjectOvertake)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .geometry.PointENU fence_point = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *fence_point_);
    }

    // optional double distance_s = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double fence_heading = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double time_buffer = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObjectOvertake::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:decision.ObjectOvertake)
  GOOGLE_DCHECK_NE(&from, this);
  const ObjectOvertake* source =
      ::google::protobuf::DynamicCastToGenerated<ObjectOvertake>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:decision.ObjectOvertake)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:decision.ObjectOvertake)
    MergeFrom(*source);
  }
}

void ObjectOvertake::MergeFrom(const ObjectOvertake& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:decision.ObjectOvertake)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_fence_point()->::geometry::PointENU::MergeFrom(from.fence_point());
    }
    if (cached_has_bits & 0x00000002u) {
      distance_s_ = from.distance_s_;
    }
    if (cached_has_bits & 0x00000004u) {
      fence_heading_ = from.fence_heading_;
    }
    if (cached_has_bits & 0x00000008u) {
      time_buffer_ = from.time_buffer_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ObjectOvertake::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:decision.ObjectOvertake)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObjectOvertake::CopyFrom(const ObjectOvertake& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:decision.ObjectOvertake)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectOvertake::IsInitialized() const {
  return true;
}

void ObjectOvertake::Swap(ObjectOvertake* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObjectOvertake::InternalSwap(ObjectOvertake* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(fence_point_, other->fence_point_);
  swap(distance_s_, other->distance_s_);
  swap(fence_heading_, other->fence_heading_);
  swap(time_buffer_, other->time_buffer_);
}

::google::protobuf::Metadata ObjectOvertake::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_decision_2eproto);
  return ::file_level_metadata_decision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ObjectSidePass::InitAsDefaultInstance() {
}
class ObjectSidePass::HasBitSetters {
 public:
  static void set_has_type(ObjectSidePass* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObjectSidePass::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObjectSidePass::ObjectSidePass()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:decision.ObjectSidePass)
}
ObjectSidePass::ObjectSidePass(const ObjectSidePass& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:decision.ObjectSidePass)
}

void ObjectSidePass::SharedCtor() {
  type_ = 1;
}

ObjectSidePass::~ObjectSidePass() {
  // @@protoc_insertion_point(destructor:decision.ObjectSidePass)
  SharedDtor();
}

void ObjectSidePass::SharedDtor() {
}

void ObjectSidePass::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObjectSidePass& ObjectSidePass::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ObjectSidePass_decision_2eproto.base);
  return *internal_default_instance();
}


void ObjectSidePass::Clear() {
// @@protoc_insertion_point(message_clear_start:decision.ObjectSidePass)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObjectSidePass::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ObjectSidePass*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .decision.ObjectSidePass.Type type = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::decision::ObjectSidePass_Type_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_type(static_cast<::decision::ObjectSidePass_Type>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObjectSidePass::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:decision.ObjectSidePass)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .decision.ObjectSidePass.Type type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::decision::ObjectSidePass_Type_IsValid(value)) {
            set_type(static_cast< ::decision::ObjectSidePass_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:decision.ObjectSidePass)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:decision.ObjectSidePass)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObjectSidePass::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:decision.ObjectSidePass)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .decision.ObjectSidePass.Type type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:decision.ObjectSidePass)
}

::google::protobuf::uint8* ObjectSidePass::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:decision.ObjectSidePass)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .decision.ObjectSidePass.Type type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:decision.ObjectSidePass)
  return target;
}

size_t ObjectSidePass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:decision.ObjectSidePass)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .decision.ObjectSidePass.Type type = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObjectSidePass::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:decision.ObjectSidePass)
  GOOGLE_DCHECK_NE(&from, this);
  const ObjectSidePass* source =
      ::google::protobuf::DynamicCastToGenerated<ObjectSidePass>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:decision.ObjectSidePass)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:decision.ObjectSidePass)
    MergeFrom(*source);
  }
}

void ObjectSidePass::MergeFrom(const ObjectSidePass& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:decision.ObjectSidePass)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_type()) {
    set_type(from.type());
  }
}

void ObjectSidePass::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:decision.ObjectSidePass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObjectSidePass::CopyFrom(const ObjectSidePass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:decision.ObjectSidePass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectSidePass::IsInitialized() const {
  return true;
}

void ObjectSidePass::Swap(ObjectSidePass* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObjectSidePass::InternalSwap(ObjectSidePass* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(type_, other->type_);
}

::google::protobuf::Metadata ObjectSidePass::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_decision_2eproto);
  return ::file_level_metadata_decision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ObjectAvoid::InitAsDefaultInstance() {
}
class ObjectAvoid::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObjectAvoid::ObjectAvoid()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:decision.ObjectAvoid)
}
ObjectAvoid::ObjectAvoid(const ObjectAvoid& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:decision.ObjectAvoid)
}

void ObjectAvoid::SharedCtor() {
}

ObjectAvoid::~ObjectAvoid() {
  // @@protoc_insertion_point(destructor:decision.ObjectAvoid)
  SharedDtor();
}

void ObjectAvoid::SharedDtor() {
}

void ObjectAvoid::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObjectAvoid& ObjectAvoid::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ObjectAvoid_decision_2eproto.base);
  return *internal_default_instance();
}


void ObjectAvoid::Clear() {
// @@protoc_insertion_point(message_clear_start:decision.ObjectAvoid)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObjectAvoid::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ObjectAvoid*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObjectAvoid::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:decision.ObjectAvoid)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, _internal_metadata_.mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:decision.ObjectAvoid)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:decision.ObjectAvoid)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObjectAvoid::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:decision.ObjectAvoid)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:decision.ObjectAvoid)
}

::google::protobuf::uint8* ObjectAvoid::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:decision.ObjectAvoid)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:decision.ObjectAvoid)
  return target;
}

size_t ObjectAvoid::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:decision.ObjectAvoid)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObjectAvoid::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:decision.ObjectAvoid)
  GOOGLE_DCHECK_NE(&from, this);
  const ObjectAvoid* source =
      ::google::protobuf::DynamicCastToGenerated<ObjectAvoid>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:decision.ObjectAvoid)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:decision.ObjectAvoid)
    MergeFrom(*source);
  }
}

void ObjectAvoid::MergeFrom(const ObjectAvoid& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:decision.ObjectAvoid)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void ObjectAvoid::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:decision.ObjectAvoid)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObjectAvoid::CopyFrom(const ObjectAvoid& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:decision.ObjectAvoid)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectAvoid::IsInitialized() const {
  return true;
}

void ObjectAvoid::Swap(ObjectAvoid* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObjectAvoid::InternalSwap(ObjectAvoid* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::google::protobuf::Metadata ObjectAvoid::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_decision_2eproto);
  return ::file_level_metadata_decision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ObjectStatus::InitAsDefaultInstance() {
  ::decision::_ObjectStatus_default_instance_._instance.get_mutable()->motion_type_ = const_cast< ::decision::ObjectMotionType*>(
      ::decision::ObjectMotionType::internal_default_instance());
  ::decision::_ObjectStatus_default_instance_._instance.get_mutable()->decision_type_ = const_cast< ::decision::ObjectDecisionType*>(
      ::decision::ObjectDecisionType::internal_default_instance());
}
class ObjectStatus::HasBitSetters {
 public:
  static const ::decision::ObjectMotionType& motion_type(const ObjectStatus* msg);
  static void set_has_motion_type(ObjectStatus* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::decision::ObjectDecisionType& decision_type(const ObjectStatus* msg);
  static void set_has_decision_type(ObjectStatus* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::decision::ObjectMotionType&
ObjectStatus::HasBitSetters::motion_type(const ObjectStatus* msg) {
  return *msg->motion_type_;
}
const ::decision::ObjectDecisionType&
ObjectStatus::HasBitSetters::decision_type(const ObjectStatus* msg) {
  return *msg->decision_type_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObjectStatus::kMotionTypeFieldNumber;
const int ObjectStatus::kDecisionTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObjectStatus::ObjectStatus()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:decision.ObjectStatus)
}
ObjectStatus::ObjectStatus(const ObjectStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_motion_type()) {
    motion_type_ = new ::decision::ObjectMotionType(*from.motion_type_);
  } else {
    motion_type_ = nullptr;
  }
  if (from.has_decision_type()) {
    decision_type_ = new ::decision::ObjectDecisionType(*from.decision_type_);
  } else {
    decision_type_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:decision.ObjectStatus)
}

void ObjectStatus::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ObjectStatus_decision_2eproto.base);
  ::memset(&motion_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&decision_type_) -
      reinterpret_cast<char*>(&motion_type_)) + sizeof(decision_type_));
}

ObjectStatus::~ObjectStatus() {
  // @@protoc_insertion_point(destructor:decision.ObjectStatus)
  SharedDtor();
}

void ObjectStatus::SharedDtor() {
  if (this != internal_default_instance()) delete motion_type_;
  if (this != internal_default_instance()) delete decision_type_;
}

void ObjectStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObjectStatus& ObjectStatus::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ObjectStatus_decision_2eproto.base);
  return *internal_default_instance();
}


void ObjectStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:decision.ObjectStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(motion_type_ != nullptr);
      motion_type_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(decision_type_ != nullptr);
      decision_type_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObjectStatus::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ObjectStatus*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .decision.ObjectMotionType motion_type = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::decision::ObjectMotionType::_InternalParse;
        object = msg->mutable_motion_type();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .decision.ObjectDecisionType decision_type = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::decision::ObjectDecisionType::_InternalParse;
        object = msg->mutable_decision_type();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObjectStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:decision.ObjectStatus)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .decision.ObjectMotionType motion_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_motion_type()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .decision.ObjectDecisionType decision_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_decision_type()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:decision.ObjectStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:decision.ObjectStatus)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObjectStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:decision.ObjectStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .decision.ObjectMotionType motion_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::motion_type(this), output);
  }

  // optional .decision.ObjectDecisionType decision_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::decision_type(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:decision.ObjectStatus)
}

::google::protobuf::uint8* ObjectStatus::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:decision.ObjectStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .decision.ObjectMotionType motion_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::motion_type(this), target);
  }

  // optional .decision.ObjectDecisionType decision_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::decision_type(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:decision.ObjectStatus)
  return target;
}

size_t ObjectStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:decision.ObjectStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .decision.ObjectMotionType motion_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *motion_type_);
    }

    // optional .decision.ObjectDecisionType decision_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *decision_type_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObjectStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:decision.ObjectStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const ObjectStatus* source =
      ::google::protobuf::DynamicCastToGenerated<ObjectStatus>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:decision.ObjectStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:decision.ObjectStatus)
    MergeFrom(*source);
  }
}

void ObjectStatus::MergeFrom(const ObjectStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:decision.ObjectStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_motion_type()->::decision::ObjectMotionType::MergeFrom(from.motion_type());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_decision_type()->::decision::ObjectDecisionType::MergeFrom(from.decision_type());
    }
  }
}

void ObjectStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:decision.ObjectStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObjectStatus::CopyFrom(const ObjectStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:decision.ObjectStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectStatus::IsInitialized() const {
  return true;
}

void ObjectStatus::Swap(ObjectStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObjectStatus::InternalSwap(ObjectStatus* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(motion_type_, other->motion_type_);
  swap(decision_type_, other->decision_type_);
}

::google::protobuf::Metadata ObjectStatus::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_decision_2eproto);
  return ::file_level_metadata_decision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ObjectStatic::InitAsDefaultInstance() {
}
class ObjectStatic::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObjectStatic::ObjectStatic()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:decision.ObjectStatic)
}
ObjectStatic::ObjectStatic(const ObjectStatic& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:decision.ObjectStatic)
}

void ObjectStatic::SharedCtor() {
}

ObjectStatic::~ObjectStatic() {
  // @@protoc_insertion_point(destructor:decision.ObjectStatic)
  SharedDtor();
}

void ObjectStatic::SharedDtor() {
}

void ObjectStatic::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObjectStatic& ObjectStatic::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ObjectStatic_decision_2eproto.base);
  return *internal_default_instance();
}


void ObjectStatic::Clear() {
// @@protoc_insertion_point(message_clear_start:decision.ObjectStatic)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObjectStatic::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ObjectStatic*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObjectStatic::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:decision.ObjectStatic)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, _internal_metadata_.mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:decision.ObjectStatic)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:decision.ObjectStatic)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObjectStatic::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:decision.ObjectStatic)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:decision.ObjectStatic)
}

::google::protobuf::uint8* ObjectStatic::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:decision.ObjectStatic)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:decision.ObjectStatic)
  return target;
}

size_t ObjectStatic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:decision.ObjectStatic)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObjectStatic::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:decision.ObjectStatic)
  GOOGLE_DCHECK_NE(&from, this);
  const ObjectStatic* source =
      ::google::protobuf::DynamicCastToGenerated<ObjectStatic>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:decision.ObjectStatic)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:decision.ObjectStatic)
    MergeFrom(*source);
  }
}

void ObjectStatic::MergeFrom(const ObjectStatic& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:decision.ObjectStatic)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void ObjectStatic::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:decision.ObjectStatic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObjectStatic::CopyFrom(const ObjectStatic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:decision.ObjectStatic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectStatic::IsInitialized() const {
  return true;
}

void ObjectStatic::Swap(ObjectStatic* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObjectStatic::InternalSwap(ObjectStatic* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::google::protobuf::Metadata ObjectStatic::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_decision_2eproto);
  return ::file_level_metadata_decision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ObjectDynamic::InitAsDefaultInstance() {
}
class ObjectDynamic::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObjectDynamic::ObjectDynamic()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:decision.ObjectDynamic)
}
ObjectDynamic::ObjectDynamic(const ObjectDynamic& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:decision.ObjectDynamic)
}

void ObjectDynamic::SharedCtor() {
}

ObjectDynamic::~ObjectDynamic() {
  // @@protoc_insertion_point(destructor:decision.ObjectDynamic)
  SharedDtor();
}

void ObjectDynamic::SharedDtor() {
}

void ObjectDynamic::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObjectDynamic& ObjectDynamic::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ObjectDynamic_decision_2eproto.base);
  return *internal_default_instance();
}


void ObjectDynamic::Clear() {
// @@protoc_insertion_point(message_clear_start:decision.ObjectDynamic)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObjectDynamic::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ObjectDynamic*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObjectDynamic::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:decision.ObjectDynamic)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, _internal_metadata_.mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:decision.ObjectDynamic)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:decision.ObjectDynamic)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObjectDynamic::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:decision.ObjectDynamic)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:decision.ObjectDynamic)
}

::google::protobuf::uint8* ObjectDynamic::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:decision.ObjectDynamic)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:decision.ObjectDynamic)
  return target;
}

size_t ObjectDynamic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:decision.ObjectDynamic)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObjectDynamic::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:decision.ObjectDynamic)
  GOOGLE_DCHECK_NE(&from, this);
  const ObjectDynamic* source =
      ::google::protobuf::DynamicCastToGenerated<ObjectDynamic>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:decision.ObjectDynamic)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:decision.ObjectDynamic)
    MergeFrom(*source);
  }
}

void ObjectDynamic::MergeFrom(const ObjectDynamic& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:decision.ObjectDynamic)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void ObjectDynamic::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:decision.ObjectDynamic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObjectDynamic::CopyFrom(const ObjectDynamic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:decision.ObjectDynamic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectDynamic::IsInitialized() const {
  return true;
}

void ObjectDynamic::Swap(ObjectDynamic* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObjectDynamic::InternalSwap(ObjectDynamic* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::google::protobuf::Metadata ObjectDynamic::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_decision_2eproto);
  return ::file_level_metadata_decision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ObjectMotionType::InitAsDefaultInstance() {
  ::decision::_ObjectMotionType_default_instance_.static__ = const_cast< ::decision::ObjectStatic*>(
      ::decision::ObjectStatic::internal_default_instance());
  ::decision::_ObjectMotionType_default_instance_.dynamic_ = const_cast< ::decision::ObjectDynamic*>(
      ::decision::ObjectDynamic::internal_default_instance());
}
class ObjectMotionType::HasBitSetters {
 public:
  static const ::decision::ObjectStatic& static_(const ObjectMotionType* msg);
  static const ::decision::ObjectDynamic& dynamic(const ObjectMotionType* msg);
};

const ::decision::ObjectStatic&
ObjectMotionType::HasBitSetters::static_(const ObjectMotionType* msg) {
  return *msg->motion_tag_.static__;
}
const ::decision::ObjectDynamic&
ObjectMotionType::HasBitSetters::dynamic(const ObjectMotionType* msg) {
  return *msg->motion_tag_.dynamic_;
}
void ObjectMotionType::set_allocated_static_(::decision::ObjectStatic* static_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_motion_tag();
  if (static_) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      static_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, static_, submessage_arena);
    }
    set_has_static_();
    motion_tag_.static__ = static_;
  }
  // @@protoc_insertion_point(field_set_allocated:decision.ObjectMotionType.static)
}
void ObjectMotionType::set_allocated_dynamic(::decision::ObjectDynamic* dynamic) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_motion_tag();
  if (dynamic) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dynamic = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dynamic, submessage_arena);
    }
    set_has_dynamic();
    motion_tag_.dynamic_ = dynamic;
  }
  // @@protoc_insertion_point(field_set_allocated:decision.ObjectMotionType.dynamic)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObjectMotionType::kStaticFieldNumber;
const int ObjectMotionType::kDynamicFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObjectMotionType::ObjectMotionType()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:decision.ObjectMotionType)
}
ObjectMotionType::ObjectMotionType(const ObjectMotionType& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  clear_has_motion_tag();
  switch (from.motion_tag_case()) {
    case kStatic: {
      mutable_static_()->::decision::ObjectStatic::MergeFrom(from.static_());
      break;
    }
    case kDynamic: {
      mutable_dynamic()->::decision::ObjectDynamic::MergeFrom(from.dynamic());
      break;
    }
    case MOTION_TAG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:decision.ObjectMotionType)
}

void ObjectMotionType::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ObjectMotionType_decision_2eproto.base);
  clear_has_motion_tag();
}

ObjectMotionType::~ObjectMotionType() {
  // @@protoc_insertion_point(destructor:decision.ObjectMotionType)
  SharedDtor();
}

void ObjectMotionType::SharedDtor() {
  if (has_motion_tag()) {
    clear_motion_tag();
  }
}

void ObjectMotionType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObjectMotionType& ObjectMotionType::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ObjectMotionType_decision_2eproto.base);
  return *internal_default_instance();
}


void ObjectMotionType::clear_motion_tag() {
// @@protoc_insertion_point(one_of_clear_start:decision.ObjectMotionType)
  switch (motion_tag_case()) {
    case kStatic: {
      delete motion_tag_.static__;
      break;
    }
    case kDynamic: {
      delete motion_tag_.dynamic_;
      break;
    }
    case MOTION_TAG_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = MOTION_TAG_NOT_SET;
}


void ObjectMotionType::Clear() {
// @@protoc_insertion_point(message_clear_start:decision.ObjectMotionType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_motion_tag();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObjectMotionType::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ObjectMotionType*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .decision.ObjectStatic static = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::decision::ObjectStatic::_InternalParse;
        object = msg->mutable_static_();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .decision.ObjectDynamic dynamic = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::decision::ObjectDynamic::_InternalParse;
        object = msg->mutable_dynamic();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObjectMotionType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:decision.ObjectMotionType)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .decision.ObjectStatic static = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_static_()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .decision.ObjectDynamic dynamic = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_dynamic()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:decision.ObjectMotionType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:decision.ObjectMotionType)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObjectMotionType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:decision.ObjectMotionType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (motion_tag_case()) {
    case kStatic:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        1, HasBitSetters::static_(this), output);
      break;
    case kDynamic:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        2, HasBitSetters::dynamic(this), output);
      break;
    default: ;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:decision.ObjectMotionType)
}

::google::protobuf::uint8* ObjectMotionType::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:decision.ObjectMotionType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (motion_tag_case()) {
    case kStatic:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          1, HasBitSetters::static_(this), target);
      break;
    case kDynamic:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          2, HasBitSetters::dynamic(this), target);
      break;
    default: ;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:decision.ObjectMotionType)
  return target;
}

size_t ObjectMotionType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:decision.ObjectMotionType)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (motion_tag_case()) {
    // optional .decision.ObjectStatic static = 1;
    case kStatic: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *motion_tag_.static__);
      break;
    }
    // optional .decision.ObjectDynamic dynamic = 2;
    case kDynamic: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *motion_tag_.dynamic_);
      break;
    }
    case MOTION_TAG_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObjectMotionType::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:decision.ObjectMotionType)
  GOOGLE_DCHECK_NE(&from, this);
  const ObjectMotionType* source =
      ::google::protobuf::DynamicCastToGenerated<ObjectMotionType>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:decision.ObjectMotionType)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:decision.ObjectMotionType)
    MergeFrom(*source);
  }
}

void ObjectMotionType::MergeFrom(const ObjectMotionType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:decision.ObjectMotionType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.motion_tag_case()) {
    case kStatic: {
      mutable_static_()->::decision::ObjectStatic::MergeFrom(from.static_());
      break;
    }
    case kDynamic: {
      mutable_dynamic()->::decision::ObjectDynamic::MergeFrom(from.dynamic());
      break;
    }
    case MOTION_TAG_NOT_SET: {
      break;
    }
  }
}

void ObjectMotionType::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:decision.ObjectMotionType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObjectMotionType::CopyFrom(const ObjectMotionType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:decision.ObjectMotionType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectMotionType::IsInitialized() const {
  return true;
}

void ObjectMotionType::Swap(ObjectMotionType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObjectMotionType::InternalSwap(ObjectMotionType* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(motion_tag_, other->motion_tag_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata ObjectMotionType::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_decision_2eproto);
  return ::file_level_metadata_decision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ObjectDecisionType::InitAsDefaultInstance() {
  ::decision::_ObjectDecisionType_default_instance_.ignore_ = const_cast< ::decision::ObjectIgnore*>(
      ::decision::ObjectIgnore::internal_default_instance());
  ::decision::_ObjectDecisionType_default_instance_.stop_ = const_cast< ::decision::ObjectStop*>(
      ::decision::ObjectStop::internal_default_instance());
  ::decision::_ObjectDecisionType_default_instance_.follow_ = const_cast< ::decision::ObjectFollow*>(
      ::decision::ObjectFollow::internal_default_instance());
  ::decision::_ObjectDecisionType_default_instance_.yield_ = const_cast< ::decision::ObjectYield*>(
      ::decision::ObjectYield::internal_default_instance());
  ::decision::_ObjectDecisionType_default_instance_.overtake_ = const_cast< ::decision::ObjectOvertake*>(
      ::decision::ObjectOvertake::internal_default_instance());
  ::decision::_ObjectDecisionType_default_instance_.nudge_ = const_cast< ::decision::ObjectNudge*>(
      ::decision::ObjectNudge::internal_default_instance());
  ::decision::_ObjectDecisionType_default_instance_.avoid_ = const_cast< ::decision::ObjectAvoid*>(
      ::decision::ObjectAvoid::internal_default_instance());
  ::decision::_ObjectDecisionType_default_instance_.side_pass_ = const_cast< ::decision::ObjectSidePass*>(
      ::decision::ObjectSidePass::internal_default_instance());
}
class ObjectDecisionType::HasBitSetters {
 public:
  static const ::decision::ObjectIgnore& ignore(const ObjectDecisionType* msg);
  static const ::decision::ObjectStop& stop(const ObjectDecisionType* msg);
  static const ::decision::ObjectFollow& follow(const ObjectDecisionType* msg);
  static const ::decision::ObjectYield& yield(const ObjectDecisionType* msg);
  static const ::decision::ObjectOvertake& overtake(const ObjectDecisionType* msg);
  static const ::decision::ObjectNudge& nudge(const ObjectDecisionType* msg);
  static const ::decision::ObjectAvoid& avoid(const ObjectDecisionType* msg);
  static const ::decision::ObjectSidePass& side_pass(const ObjectDecisionType* msg);
};

const ::decision::ObjectIgnore&
ObjectDecisionType::HasBitSetters::ignore(const ObjectDecisionType* msg) {
  return *msg->object_tag_.ignore_;
}
const ::decision::ObjectStop&
ObjectDecisionType::HasBitSetters::stop(const ObjectDecisionType* msg) {
  return *msg->object_tag_.stop_;
}
const ::decision::ObjectFollow&
ObjectDecisionType::HasBitSetters::follow(const ObjectDecisionType* msg) {
  return *msg->object_tag_.follow_;
}
const ::decision::ObjectYield&
ObjectDecisionType::HasBitSetters::yield(const ObjectDecisionType* msg) {
  return *msg->object_tag_.yield_;
}
const ::decision::ObjectOvertake&
ObjectDecisionType::HasBitSetters::overtake(const ObjectDecisionType* msg) {
  return *msg->object_tag_.overtake_;
}
const ::decision::ObjectNudge&
ObjectDecisionType::HasBitSetters::nudge(const ObjectDecisionType* msg) {
  return *msg->object_tag_.nudge_;
}
const ::decision::ObjectAvoid&
ObjectDecisionType::HasBitSetters::avoid(const ObjectDecisionType* msg) {
  return *msg->object_tag_.avoid_;
}
const ::decision::ObjectSidePass&
ObjectDecisionType::HasBitSetters::side_pass(const ObjectDecisionType* msg) {
  return *msg->object_tag_.side_pass_;
}
void ObjectDecisionType::set_allocated_ignore(::decision::ObjectIgnore* ignore) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_object_tag();
  if (ignore) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ignore = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ignore, submessage_arena);
    }
    set_has_ignore();
    object_tag_.ignore_ = ignore;
  }
  // @@protoc_insertion_point(field_set_allocated:decision.ObjectDecisionType.ignore)
}
void ObjectDecisionType::set_allocated_stop(::decision::ObjectStop* stop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_object_tag();
  if (stop) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stop, submessage_arena);
    }
    set_has_stop();
    object_tag_.stop_ = stop;
  }
  // @@protoc_insertion_point(field_set_allocated:decision.ObjectDecisionType.stop)
}
void ObjectDecisionType::set_allocated_follow(::decision::ObjectFollow* follow) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_object_tag();
  if (follow) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      follow = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, follow, submessage_arena);
    }
    set_has_follow();
    object_tag_.follow_ = follow;
  }
  // @@protoc_insertion_point(field_set_allocated:decision.ObjectDecisionType.follow)
}
void ObjectDecisionType::set_allocated_yield(::decision::ObjectYield* yield) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_object_tag();
  if (yield) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      yield = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yield, submessage_arena);
    }
    set_has_yield();
    object_tag_.yield_ = yield;
  }
  // @@protoc_insertion_point(field_set_allocated:decision.ObjectDecisionType.yield)
}
void ObjectDecisionType::set_allocated_overtake(::decision::ObjectOvertake* overtake) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_object_tag();
  if (overtake) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      overtake = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, overtake, submessage_arena);
    }
    set_has_overtake();
    object_tag_.overtake_ = overtake;
  }
  // @@protoc_insertion_point(field_set_allocated:decision.ObjectDecisionType.overtake)
}
void ObjectDecisionType::set_allocated_nudge(::decision::ObjectNudge* nudge) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_object_tag();
  if (nudge) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      nudge = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, nudge, submessage_arena);
    }
    set_has_nudge();
    object_tag_.nudge_ = nudge;
  }
  // @@protoc_insertion_point(field_set_allocated:decision.ObjectDecisionType.nudge)
}
void ObjectDecisionType::set_allocated_avoid(::decision::ObjectAvoid* avoid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_object_tag();
  if (avoid) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      avoid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, avoid, submessage_arena);
    }
    set_has_avoid();
    object_tag_.avoid_ = avoid;
  }
  // @@protoc_insertion_point(field_set_allocated:decision.ObjectDecisionType.avoid)
}
void ObjectDecisionType::set_allocated_side_pass(::decision::ObjectSidePass* side_pass) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_object_tag();
  if (side_pass) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      side_pass = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, side_pass, submessage_arena);
    }
    set_has_side_pass();
    object_tag_.side_pass_ = side_pass;
  }
  // @@protoc_insertion_point(field_set_allocated:decision.ObjectDecisionType.side_pass)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObjectDecisionType::kIgnoreFieldNumber;
const int ObjectDecisionType::kStopFieldNumber;
const int ObjectDecisionType::kFollowFieldNumber;
const int ObjectDecisionType::kYieldFieldNumber;
const int ObjectDecisionType::kOvertakeFieldNumber;
const int ObjectDecisionType::kNudgeFieldNumber;
const int ObjectDecisionType::kAvoidFieldNumber;
const int ObjectDecisionType::kSidePassFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObjectDecisionType::ObjectDecisionType()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:decision.ObjectDecisionType)
}
ObjectDecisionType::ObjectDecisionType(const ObjectDecisionType& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  clear_has_object_tag();
  switch (from.object_tag_case()) {
    case kIgnore: {
      mutable_ignore()->::decision::ObjectIgnore::MergeFrom(from.ignore());
      break;
    }
    case kStop: {
      mutable_stop()->::decision::ObjectStop::MergeFrom(from.stop());
      break;
    }
    case kFollow: {
      mutable_follow()->::decision::ObjectFollow::MergeFrom(from.follow());
      break;
    }
    case kYield: {
      mutable_yield()->::decision::ObjectYield::MergeFrom(from.yield());
      break;
    }
    case kOvertake: {
      mutable_overtake()->::decision::ObjectOvertake::MergeFrom(from.overtake());
      break;
    }
    case kNudge: {
      mutable_nudge()->::decision::ObjectNudge::MergeFrom(from.nudge());
      break;
    }
    case kAvoid: {
      mutable_avoid()->::decision::ObjectAvoid::MergeFrom(from.avoid());
      break;
    }
    case kSidePass: {
      mutable_side_pass()->::decision::ObjectSidePass::MergeFrom(from.side_pass());
      break;
    }
    case OBJECT_TAG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:decision.ObjectDecisionType)
}

void ObjectDecisionType::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ObjectDecisionType_decision_2eproto.base);
  clear_has_object_tag();
}

ObjectDecisionType::~ObjectDecisionType() {
  // @@protoc_insertion_point(destructor:decision.ObjectDecisionType)
  SharedDtor();
}

void ObjectDecisionType::SharedDtor() {
  if (has_object_tag()) {
    clear_object_tag();
  }
}

void ObjectDecisionType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObjectDecisionType& ObjectDecisionType::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ObjectDecisionType_decision_2eproto.base);
  return *internal_default_instance();
}


void ObjectDecisionType::clear_object_tag() {
// @@protoc_insertion_point(one_of_clear_start:decision.ObjectDecisionType)
  switch (object_tag_case()) {
    case kIgnore: {
      delete object_tag_.ignore_;
      break;
    }
    case kStop: {
      delete object_tag_.stop_;
      break;
    }
    case kFollow: {
      delete object_tag_.follow_;
      break;
    }
    case kYield: {
      delete object_tag_.yield_;
      break;
    }
    case kOvertake: {
      delete object_tag_.overtake_;
      break;
    }
    case kNudge: {
      delete object_tag_.nudge_;
      break;
    }
    case kAvoid: {
      delete object_tag_.avoid_;
      break;
    }
    case kSidePass: {
      delete object_tag_.side_pass_;
      break;
    }
    case OBJECT_TAG_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = OBJECT_TAG_NOT_SET;
}


void ObjectDecisionType::Clear() {
// @@protoc_insertion_point(message_clear_start:decision.ObjectDecisionType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_object_tag();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObjectDecisionType::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ObjectDecisionType*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .decision.ObjectIgnore ignore = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::decision::ObjectIgnore::_InternalParse;
        object = msg->mutable_ignore();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .decision.ObjectStop stop = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::decision::ObjectStop::_InternalParse;
        object = msg->mutable_stop();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .decision.ObjectFollow follow = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::decision::ObjectFollow::_InternalParse;
        object = msg->mutable_follow();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .decision.ObjectYield yield = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::decision::ObjectYield::_InternalParse;
        object = msg->mutable_yield();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .decision.ObjectOvertake overtake = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::decision::ObjectOvertake::_InternalParse;
        object = msg->mutable_overtake();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .decision.ObjectNudge nudge = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::decision::ObjectNudge::_InternalParse;
        object = msg->mutable_nudge();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .decision.ObjectAvoid avoid = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::decision::ObjectAvoid::_InternalParse;
        object = msg->mutable_avoid();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .decision.ObjectSidePass side_pass = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 66) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::decision::ObjectSidePass::_InternalParse;
        object = msg->mutable_side_pass();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObjectDecisionType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:decision.ObjectDecisionType)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .decision.ObjectIgnore ignore = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_ignore()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .decision.ObjectStop stop = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_stop()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .decision.ObjectFollow follow = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_follow()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .decision.ObjectYield yield = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_yield()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .decision.ObjectOvertake overtake = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_overtake()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .decision.ObjectNudge nudge = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_nudge()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .decision.ObjectAvoid avoid = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_avoid()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .decision.ObjectSidePass side_pass = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (66 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_side_pass()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:decision.ObjectDecisionType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:decision.ObjectDecisionType)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObjectDecisionType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:decision.ObjectDecisionType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (object_tag_case()) {
    case kIgnore:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        1, HasBitSetters::ignore(this), output);
      break;
    case kStop:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        2, HasBitSetters::stop(this), output);
      break;
    case kFollow:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        3, HasBitSetters::follow(this), output);
      break;
    case kYield:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        4, HasBitSetters::yield(this), output);
      break;
    case kOvertake:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        5, HasBitSetters::overtake(this), output);
      break;
    case kNudge:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        6, HasBitSetters::nudge(this), output);
      break;
    case kAvoid:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        7, HasBitSetters::avoid(this), output);
      break;
    case kSidePass:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        8, HasBitSetters::side_pass(this), output);
      break;
    default: ;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:decision.ObjectDecisionType)
}

::google::protobuf::uint8* ObjectDecisionType::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:decision.ObjectDecisionType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (object_tag_case()) {
    case kIgnore:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          1, HasBitSetters::ignore(this), target);
      break;
    case kStop:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          2, HasBitSetters::stop(this), target);
      break;
    case kFollow:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          3, HasBitSetters::follow(this), target);
      break;
    case kYield:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          4, HasBitSetters::yield(this), target);
      break;
    case kOvertake:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          5, HasBitSetters::overtake(this), target);
      break;
    case kNudge:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          6, HasBitSetters::nudge(this), target);
      break;
    case kAvoid:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          7, HasBitSetters::avoid(this), target);
      break;
    case kSidePass:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          8, HasBitSetters::side_pass(this), target);
      break;
    default: ;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:decision.ObjectDecisionType)
  return target;
}

size_t ObjectDecisionType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:decision.ObjectDecisionType)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (object_tag_case()) {
    // optional .decision.ObjectIgnore ignore = 1;
    case kIgnore: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *object_tag_.ignore_);
      break;
    }
    // optional .decision.ObjectStop stop = 2;
    case kStop: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *object_tag_.stop_);
      break;
    }
    // optional .decision.ObjectFollow follow = 3;
    case kFollow: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *object_tag_.follow_);
      break;
    }
    // optional .decision.ObjectYield yield = 4;
    case kYield: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *object_tag_.yield_);
      break;
    }
    // optional .decision.ObjectOvertake overtake = 5;
    case kOvertake: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *object_tag_.overtake_);
      break;
    }
    // optional .decision.ObjectNudge nudge = 6;
    case kNudge: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *object_tag_.nudge_);
      break;
    }
    // optional .decision.ObjectAvoid avoid = 7;
    case kAvoid: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *object_tag_.avoid_);
      break;
    }
    // optional .decision.ObjectSidePass side_pass = 8;
    case kSidePass: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *object_tag_.side_pass_);
      break;
    }
    case OBJECT_TAG_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObjectDecisionType::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:decision.ObjectDecisionType)
  GOOGLE_DCHECK_NE(&from, this);
  const ObjectDecisionType* source =
      ::google::protobuf::DynamicCastToGenerated<ObjectDecisionType>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:decision.ObjectDecisionType)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:decision.ObjectDecisionType)
    MergeFrom(*source);
  }
}

void ObjectDecisionType::MergeFrom(const ObjectDecisionType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:decision.ObjectDecisionType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.object_tag_case()) {
    case kIgnore: {
      mutable_ignore()->::decision::ObjectIgnore::MergeFrom(from.ignore());
      break;
    }
    case kStop: {
      mutable_stop()->::decision::ObjectStop::MergeFrom(from.stop());
      break;
    }
    case kFollow: {
      mutable_follow()->::decision::ObjectFollow::MergeFrom(from.follow());
      break;
    }
    case kYield: {
      mutable_yield()->::decision::ObjectYield::MergeFrom(from.yield());
      break;
    }
    case kOvertake: {
      mutable_overtake()->::decision::ObjectOvertake::MergeFrom(from.overtake());
      break;
    }
    case kNudge: {
      mutable_nudge()->::decision::ObjectNudge::MergeFrom(from.nudge());
      break;
    }
    case kAvoid: {
      mutable_avoid()->::decision::ObjectAvoid::MergeFrom(from.avoid());
      break;
    }
    case kSidePass: {
      mutable_side_pass()->::decision::ObjectSidePass::MergeFrom(from.side_pass());
      break;
    }
    case OBJECT_TAG_NOT_SET: {
      break;
    }
  }
}

void ObjectDecisionType::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:decision.ObjectDecisionType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObjectDecisionType::CopyFrom(const ObjectDecisionType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:decision.ObjectDecisionType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectDecisionType::IsInitialized() const {
  return true;
}

void ObjectDecisionType::Swap(ObjectDecisionType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObjectDecisionType::InternalSwap(ObjectDecisionType* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_tag_, other->object_tag_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata ObjectDecisionType::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_decision_2eproto);
  return ::file_level_metadata_decision_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace decision
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::decision::TargetLane* Arena::CreateMaybeMessage< ::decision::TargetLane >(Arena* arena) {
  return Arena::CreateInternal< ::decision::TargetLane >(arena);
}
template<> PROTOBUF_NOINLINE ::decision::ObjectIgnore* Arena::CreateMaybeMessage< ::decision::ObjectIgnore >(Arena* arena) {
  return Arena::CreateInternal< ::decision::ObjectIgnore >(arena);
}
template<> PROTOBUF_NOINLINE ::decision::ObjectStop* Arena::CreateMaybeMessage< ::decision::ObjectStop >(Arena* arena) {
  return Arena::CreateInternal< ::decision::ObjectStop >(arena);
}
template<> PROTOBUF_NOINLINE ::decision::ObjectNudge* Arena::CreateMaybeMessage< ::decision::ObjectNudge >(Arena* arena) {
  return Arena::CreateInternal< ::decision::ObjectNudge >(arena);
}
template<> PROTOBUF_NOINLINE ::decision::ObjectYield* Arena::CreateMaybeMessage< ::decision::ObjectYield >(Arena* arena) {
  return Arena::CreateInternal< ::decision::ObjectYield >(arena);
}
template<> PROTOBUF_NOINLINE ::decision::ObjectFollow* Arena::CreateMaybeMessage< ::decision::ObjectFollow >(Arena* arena) {
  return Arena::CreateInternal< ::decision::ObjectFollow >(arena);
}
template<> PROTOBUF_NOINLINE ::decision::ObjectOvertake* Arena::CreateMaybeMessage< ::decision::ObjectOvertake >(Arena* arena) {
  return Arena::CreateInternal< ::decision::ObjectOvertake >(arena);
}
template<> PROTOBUF_NOINLINE ::decision::ObjectSidePass* Arena::CreateMaybeMessage< ::decision::ObjectSidePass >(Arena* arena) {
  return Arena::CreateInternal< ::decision::ObjectSidePass >(arena);
}
template<> PROTOBUF_NOINLINE ::decision::ObjectAvoid* Arena::CreateMaybeMessage< ::decision::ObjectAvoid >(Arena* arena) {
  return Arena::CreateInternal< ::decision::ObjectAvoid >(arena);
}
template<> PROTOBUF_NOINLINE ::decision::ObjectStatus* Arena::CreateMaybeMessage< ::decision::ObjectStatus >(Arena* arena) {
  return Arena::CreateInternal< ::decision::ObjectStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::decision::ObjectStatic* Arena::CreateMaybeMessage< ::decision::ObjectStatic >(Arena* arena) {
  return Arena::CreateInternal< ::decision::ObjectStatic >(arena);
}
template<> PROTOBUF_NOINLINE ::decision::ObjectDynamic* Arena::CreateMaybeMessage< ::decision::ObjectDynamic >(Arena* arena) {
  return Arena::CreateInternal< ::decision::ObjectDynamic >(arena);
}
template<> PROTOBUF_NOINLINE ::decision::ObjectMotionType* Arena::CreateMaybeMessage< ::decision::ObjectMotionType >(Arena* arena) {
  return Arena::CreateInternal< ::decision::ObjectMotionType >(arena);
}
template<> PROTOBUF_NOINLINE ::decision::ObjectDecisionType* Arena::CreateMaybeMessage< ::decision::ObjectDecisionType >(Arena* arena) {
  return Arena::CreateInternal< ::decision::ObjectDecisionType >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
