// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: planner_config.proto

#ifndef PROTOBUF_INCLUDED_planner_5fconfig_2eproto
#define PROTOBUF_INCLUDED_planner_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "fem_pos_deviation.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_planner_5fconfig_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_planner_5fconfig_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_planner_5fconfig_2eproto();
namespace planning {
class BSplineConfig;
class BSplineConfigDefaultTypeInternal;
extern BSplineConfigDefaultTypeInternal _BSplineConfig_default_instance_;
class IterativeAnchoringConfig;
class IterativeAnchoringConfigDefaultTypeInternal;
extern IterativeAnchoringConfigDefaultTypeInternal _IterativeAnchoringConfig_default_instance_;
class PiecewiseJerkSpeedOptimizerConfig;
class PiecewiseJerkSpeedOptimizerConfigDefaultTypeInternal;
extern PiecewiseJerkSpeedOptimizerConfigDefaultTypeInternal _PiecewiseJerkSpeedOptimizerConfig_default_instance_;
class PlannerOpenSpaceConfig;
class PlannerOpenSpaceConfigDefaultTypeInternal;
extern PlannerOpenSpaceConfigDefaultTypeInternal _PlannerOpenSpaceConfig_default_instance_;
class WarmStartConfig;
class WarmStartConfigDefaultTypeInternal;
extern WarmStartConfigDefaultTypeInternal _WarmStartConfig_default_instance_;
}  // namespace planning
namespace google {
namespace protobuf {
template<> ::planning::BSplineConfig* Arena::CreateMaybeMessage<::planning::BSplineConfig>(Arena*);
template<> ::planning::IterativeAnchoringConfig* Arena::CreateMaybeMessage<::planning::IterativeAnchoringConfig>(Arena*);
template<> ::planning::PiecewiseJerkSpeedOptimizerConfig* Arena::CreateMaybeMessage<::planning::PiecewiseJerkSpeedOptimizerConfig>(Arena*);
template<> ::planning::PlannerOpenSpaceConfig* Arena::CreateMaybeMessage<::planning::PlannerOpenSpaceConfig>(Arena*);
template<> ::planning::WarmStartConfig* Arena::CreateMaybeMessage<::planning::WarmStartConfig>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace planning {

// ===================================================================

class PlannerOpenSpaceConfig :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.PlannerOpenSpaceConfig) */ {
 public:
  PlannerOpenSpaceConfig();
  virtual ~PlannerOpenSpaceConfig();

  PlannerOpenSpaceConfig(const PlannerOpenSpaceConfig& from);

  inline PlannerOpenSpaceConfig& operator=(const PlannerOpenSpaceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlannerOpenSpaceConfig(PlannerOpenSpaceConfig&& from) noexcept
    : PlannerOpenSpaceConfig() {
    *this = ::std::move(from);
  }

  inline PlannerOpenSpaceConfig& operator=(PlannerOpenSpaceConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PlannerOpenSpaceConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlannerOpenSpaceConfig* internal_default_instance() {
    return reinterpret_cast<const PlannerOpenSpaceConfig*>(
               &_PlannerOpenSpaceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PlannerOpenSpaceConfig* other);
  friend void swap(PlannerOpenSpaceConfig& a, PlannerOpenSpaceConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlannerOpenSpaceConfig* New() const final {
    return CreateMaybeMessage<PlannerOpenSpaceConfig>(nullptr);
  }

  PlannerOpenSpaceConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlannerOpenSpaceConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlannerOpenSpaceConfig& from);
  void MergeFrom(const PlannerOpenSpaceConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlannerOpenSpaceConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .planning.WarmStartConfig warm_start_config = 2;
  bool has_warm_start_config() const;
  void clear_warm_start_config();
  static const int kWarmStartConfigFieldNumber = 2;
  const ::planning::WarmStartConfig& warm_start_config() const;
  ::planning::WarmStartConfig* release_warm_start_config();
  ::planning::WarmStartConfig* mutable_warm_start_config();
  void set_allocated_warm_start_config(::planning::WarmStartConfig* warm_start_config);

  // optional .planning.IterativeAnchoringConfig iterative_anchoring_smoother_config = 5;
  bool has_iterative_anchoring_smoother_config() const;
  void clear_iterative_anchoring_smoother_config();
  static const int kIterativeAnchoringSmootherConfigFieldNumber = 5;
  const ::planning::IterativeAnchoringConfig& iterative_anchoring_smoother_config() const;
  ::planning::IterativeAnchoringConfig* release_iterative_anchoring_smoother_config();
  ::planning::IterativeAnchoringConfig* mutable_iterative_anchoring_smoother_config();
  void set_allocated_iterative_anchoring_smoother_config(::planning::IterativeAnchoringConfig* iterative_anchoring_smoother_config);

  // optional bool enable_check_parallel_trajectory = 9 [default = false];
  bool has_enable_check_parallel_trajectory() const;
  void clear_enable_check_parallel_trajectory();
  static const int kEnableCheckParallelTrajectoryFieldNumber = 9;
  bool enable_check_parallel_trajectory() const;
  void set_enable_check_parallel_trajectory(bool value);

  // optional bool enable_linear_interpolation = 10 [default = false];
  bool has_enable_linear_interpolation() const;
  void clear_enable_linear_interpolation();
  static const int kEnableLinearInterpolationFieldNumber = 10;
  bool enable_linear_interpolation() const;
  void set_enable_linear_interpolation(bool value);

  // optional float delta_t = 7 [default = 1];
  bool has_delta_t() const;
  void clear_delta_t();
  static const int kDeltaTFieldNumber = 7;
  float delta_t() const;
  void set_delta_t(float value);

  // optional double is_near_destination_threshold = 8 [default = 0.02];
  bool has_is_near_destination_threshold() const;
  void clear_is_near_destination_threshold();
  static const int kIsNearDestinationThresholdFieldNumber = 8;
  double is_near_destination_threshold() const;
  void set_is_near_destination_threshold(double value);

  // optional double is_near_destination_theta_threshold = 11 [default = 0.05];
  bool has_is_near_destination_theta_threshold() const;
  void clear_is_near_destination_theta_threshold();
  static const int kIsNearDestinationThetaThresholdFieldNumber = 11;
  double is_near_destination_theta_threshold() const;
  void set_is_near_destination_theta_threshold(double value);

  // @@protoc_insertion_point(class_scope:planning.PlannerOpenSpaceConfig)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::planning::WarmStartConfig* warm_start_config_;
  ::planning::IterativeAnchoringConfig* iterative_anchoring_smoother_config_;
  bool enable_check_parallel_trajectory_;
  bool enable_linear_interpolation_;
  float delta_t_;
  double is_near_destination_threshold_;
  double is_near_destination_theta_threshold_;
  friend struct ::TableStruct_planner_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class WarmStartConfig :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.WarmStartConfig) */ {
 public:
  WarmStartConfig();
  virtual ~WarmStartConfig();

  WarmStartConfig(const WarmStartConfig& from);

  inline WarmStartConfig& operator=(const WarmStartConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WarmStartConfig(WarmStartConfig&& from) noexcept
    : WarmStartConfig() {
    *this = ::std::move(from);
  }

  inline WarmStartConfig& operator=(WarmStartConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WarmStartConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WarmStartConfig* internal_default_instance() {
    return reinterpret_cast<const WarmStartConfig*>(
               &_WarmStartConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(WarmStartConfig* other);
  friend void swap(WarmStartConfig& a, WarmStartConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WarmStartConfig* New() const final {
    return CreateMaybeMessage<WarmStartConfig>(nullptr);
  }

  WarmStartConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WarmStartConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WarmStartConfig& from);
  void MergeFrom(const WarmStartConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WarmStartConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .planning.PiecewiseJerkSpeedOptimizerConfig s_curve_config = 17;
  bool has_s_curve_config() const;
  void clear_s_curve_config();
  static const int kSCurveConfigFieldNumber = 17;
  const ::planning::PiecewiseJerkSpeedOptimizerConfig& s_curve_config() const;
  ::planning::PiecewiseJerkSpeedOptimizerConfig* release_s_curve_config();
  ::planning::PiecewiseJerkSpeedOptimizerConfig* mutable_s_curve_config();
  void set_allocated_s_curve_config(::planning::PiecewiseJerkSpeedOptimizerConfig* s_curve_config);

  // optional double xy_grid_resolution = 1 [default = 0.1];
  bool has_xy_grid_resolution() const;
  void clear_xy_grid_resolution();
  static const int kXyGridResolutionFieldNumber = 1;
  double xy_grid_resolution() const;
  void set_xy_grid_resolution(double value);

  // optional double phi_grid_resolution = 2 [default = 0.1];
  bool has_phi_grid_resolution() const;
  void clear_phi_grid_resolution();
  static const int kPhiGridResolutionFieldNumber = 2;
  double phi_grid_resolution() const;
  void set_phi_grid_resolution(double value);

  // optional uint64 next_node_num = 3 [default = 10];
  bool has_next_node_num() const;
  void clear_next_node_num();
  static const int kNextNodeNumFieldNumber = 3;
  ::google::protobuf::uint64 next_node_num() const;
  void set_next_node_num(::google::protobuf::uint64 value);

  // optional double step_size = 4 [default = 0.5];
  bool has_step_size() const;
  void clear_step_size();
  static const int kStepSizeFieldNumber = 4;
  double step_size() const;
  void set_step_size(double value);

  // optional double traj_forward_penalty = 5 [default = 10];
  bool has_traj_forward_penalty() const;
  void clear_traj_forward_penalty();
  static const int kTrajForwardPenaltyFieldNumber = 5;
  double traj_forward_penalty() const;
  void set_traj_forward_penalty(double value);

  // optional double traj_back_penalty = 6 [default = 100];
  bool has_traj_back_penalty() const;
  void clear_traj_back_penalty();
  static const int kTrajBackPenaltyFieldNumber = 6;
  double traj_back_penalty() const;
  void set_traj_back_penalty(double value);

  // optional double traj_gear_switch_penalty = 7 [default = 100];
  bool has_traj_gear_switch_penalty() const;
  void clear_traj_gear_switch_penalty();
  static const int kTrajGearSwitchPenaltyFieldNumber = 7;
  double traj_gear_switch_penalty() const;
  void set_traj_gear_switch_penalty(double value);

  // optional double traj_steer_penalty = 8 [default = 50];
  bool has_traj_steer_penalty() const;
  void clear_traj_steer_penalty();
  static const int kTrajSteerPenaltyFieldNumber = 8;
  double traj_steer_penalty() const;
  void set_traj_steer_penalty(double value);

  // optional double traj_steer_change_penalty = 9 [default = 150];
  bool has_traj_steer_change_penalty() const;
  void clear_traj_steer_change_penalty();
  static const int kTrajSteerChangePenaltyFieldNumber = 9;
  double traj_steer_change_penalty() const;
  void set_traj_steer_change_penalty(double value);

  // optional double grid_a_star_xy_resolution = 15 [default = 0.1];
  bool has_grid_a_star_xy_resolution() const;
  void clear_grid_a_star_xy_resolution();
  static const int kGridAStarXyResolutionFieldNumber = 15;
  double grid_a_star_xy_resolution() const;
  void set_grid_a_star_xy_resolution(double value);

  // optional double node_radius = 16 [default = 0.3];
  bool has_node_radius() const;
  void clear_node_radius();
  static const int kNodeRadiusFieldNumber = 16;
  double node_radius() const;
  void set_node_radius(double value);

  // @@protoc_insertion_point(class_scope:planning.WarmStartConfig)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::planning::PiecewiseJerkSpeedOptimizerConfig* s_curve_config_;
  double xy_grid_resolution_;
  double phi_grid_resolution_;
  ::google::protobuf::uint64 next_node_num_;
  double step_size_;
  double traj_forward_penalty_;
  double traj_back_penalty_;
  double traj_gear_switch_penalty_;
  double traj_steer_penalty_;
  double traj_steer_change_penalty_;
  double grid_a_star_xy_resolution_;
  double node_radius_;
  friend struct ::TableStruct_planner_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class PiecewiseJerkSpeedOptimizerConfig :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.PiecewiseJerkSpeedOptimizerConfig) */ {
 public:
  PiecewiseJerkSpeedOptimizerConfig();
  virtual ~PiecewiseJerkSpeedOptimizerConfig();

  PiecewiseJerkSpeedOptimizerConfig(const PiecewiseJerkSpeedOptimizerConfig& from);

  inline PiecewiseJerkSpeedOptimizerConfig& operator=(const PiecewiseJerkSpeedOptimizerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PiecewiseJerkSpeedOptimizerConfig(PiecewiseJerkSpeedOptimizerConfig&& from) noexcept
    : PiecewiseJerkSpeedOptimizerConfig() {
    *this = ::std::move(from);
  }

  inline PiecewiseJerkSpeedOptimizerConfig& operator=(PiecewiseJerkSpeedOptimizerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PiecewiseJerkSpeedOptimizerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PiecewiseJerkSpeedOptimizerConfig* internal_default_instance() {
    return reinterpret_cast<const PiecewiseJerkSpeedOptimizerConfig*>(
               &_PiecewiseJerkSpeedOptimizerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(PiecewiseJerkSpeedOptimizerConfig* other);
  friend void swap(PiecewiseJerkSpeedOptimizerConfig& a, PiecewiseJerkSpeedOptimizerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PiecewiseJerkSpeedOptimizerConfig* New() const final {
    return CreateMaybeMessage<PiecewiseJerkSpeedOptimizerConfig>(nullptr);
  }

  PiecewiseJerkSpeedOptimizerConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PiecewiseJerkSpeedOptimizerConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PiecewiseJerkSpeedOptimizerConfig& from);
  void MergeFrom(const PiecewiseJerkSpeedOptimizerConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PiecewiseJerkSpeedOptimizerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double max_forward_v = 1 [default = 1];
  bool has_max_forward_v() const;
  void clear_max_forward_v();
  static const int kMaxForwardVFieldNumber = 1;
  double max_forward_v() const;
  void set_max_forward_v(double value);

  // optional double max_reverse_v = 2 [default = 1];
  bool has_max_reverse_v() const;
  void clear_max_reverse_v();
  static const int kMaxReverseVFieldNumber = 2;
  double max_reverse_v() const;
  void set_max_reverse_v(double value);

  // optional double max_forward_acc = 3 [default = 0.5];
  bool has_max_forward_acc() const;
  void clear_max_forward_acc();
  static const int kMaxForwardAccFieldNumber = 3;
  double max_forward_acc() const;
  void set_max_forward_acc(double value);

  // optional double max_reverse_acc = 4 [default = 0.5];
  bool has_max_reverse_acc() const;
  void clear_max_reverse_acc();
  static const int kMaxReverseAccFieldNumber = 4;
  double max_reverse_acc() const;
  void set_max_reverse_acc(double value);

  // optional double max_acc_jerk = 5 [default = 0.5];
  bool has_max_acc_jerk() const;
  void clear_max_acc_jerk();
  static const int kMaxAccJerkFieldNumber = 5;
  double max_acc_jerk() const;
  void set_max_acc_jerk(double value);

  // optional double delta_t = 6 [default = 0.2];
  bool has_delta_t() const;
  void clear_delta_t();
  static const int kDeltaTFieldNumber = 6;
  double delta_t() const;
  void set_delta_t(double value);

  // optional double acc_weight = 7 [default = 1];
  bool has_acc_weight() const;
  void clear_acc_weight();
  static const int kAccWeightFieldNumber = 7;
  double acc_weight() const;
  void set_acc_weight(double value);

  // optional double jerk_weight = 8 [default = 10];
  bool has_jerk_weight() const;
  void clear_jerk_weight();
  static const int kJerkWeightFieldNumber = 8;
  double jerk_weight() const;
  void set_jerk_weight(double value);

  // optional double kappa_penalty_weight = 9 [default = 1000];
  bool has_kappa_penalty_weight() const;
  void clear_kappa_penalty_weight();
  static const int kKappaPenaltyWeightFieldNumber = 9;
  double kappa_penalty_weight() const;
  void set_kappa_penalty_weight(double value);

  // optional double ref_s_weight = 10 [default = 1000];
  bool has_ref_s_weight() const;
  void clear_ref_s_weight();
  static const int kRefSWeightFieldNumber = 10;
  double ref_s_weight() const;
  void set_ref_s_weight(double value);

  // optional double ref_v_weight = 11 [default = 10];
  bool has_ref_v_weight() const;
  void clear_ref_v_weight();
  static const int kRefVWeightFieldNumber = 11;
  double ref_v_weight() const;
  void set_ref_v_weight(double value);

  // optional double k_dense_time_resoltuion = 12 [default = 0.5];
  bool has_k_dense_time_resoltuion() const;
  void clear_k_dense_time_resoltuion();
  static const int kKDenseTimeResoltuionFieldNumber = 12;
  double k_dense_time_resoltuion() const;
  void set_k_dense_time_resoltuion(double value);

  // @@protoc_insertion_point(class_scope:planning.PiecewiseJerkSpeedOptimizerConfig)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double max_forward_v_;
  double max_reverse_v_;
  double max_forward_acc_;
  double max_reverse_acc_;
  double max_acc_jerk_;
  double delta_t_;
  double acc_weight_;
  double jerk_weight_;
  double kappa_penalty_weight_;
  double ref_s_weight_;
  double ref_v_weight_;
  double k_dense_time_resoltuion_;
  friend struct ::TableStruct_planner_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class IterativeAnchoringConfig :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.IterativeAnchoringConfig) */ {
 public:
  IterativeAnchoringConfig();
  virtual ~IterativeAnchoringConfig();

  IterativeAnchoringConfig(const IterativeAnchoringConfig& from);

  inline IterativeAnchoringConfig& operator=(const IterativeAnchoringConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IterativeAnchoringConfig(IterativeAnchoringConfig&& from) noexcept
    : IterativeAnchoringConfig() {
    *this = ::std::move(from);
  }

  inline IterativeAnchoringConfig& operator=(IterativeAnchoringConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const IterativeAnchoringConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IterativeAnchoringConfig* internal_default_instance() {
    return reinterpret_cast<const IterativeAnchoringConfig*>(
               &_IterativeAnchoringConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(IterativeAnchoringConfig* other);
  friend void swap(IterativeAnchoringConfig& a, IterativeAnchoringConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IterativeAnchoringConfig* New() const final {
    return CreateMaybeMessage<IterativeAnchoringConfig>(nullptr);
  }

  IterativeAnchoringConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IterativeAnchoringConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IterativeAnchoringConfig& from);
  void MergeFrom(const IterativeAnchoringConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IterativeAnchoringConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .smoother.FemPosDeviationSmootherConfig fem_pos_deviation_smoother_config = 8;
  bool has_fem_pos_deviation_smoother_config() const;
  void clear_fem_pos_deviation_smoother_config();
  static const int kFemPosDeviationSmootherConfigFieldNumber = 8;
  const ::smoother::FemPosDeviationSmootherConfig& fem_pos_deviation_smoother_config() const;
  ::smoother::FemPosDeviationSmootherConfig* release_fem_pos_deviation_smoother_config();
  ::smoother::FemPosDeviationSmootherConfig* mutable_fem_pos_deviation_smoother_config();
  void set_allocated_fem_pos_deviation_smoother_config(::smoother::FemPosDeviationSmootherConfig* fem_pos_deviation_smoother_config);

  // optional .planning.PiecewiseJerkSpeedOptimizerConfig s_curve_config = 16;
  bool has_s_curve_config() const;
  void clear_s_curve_config();
  static const int kSCurveConfigFieldNumber = 16;
  const ::planning::PiecewiseJerkSpeedOptimizerConfig& s_curve_config() const;
  ::planning::PiecewiseJerkSpeedOptimizerConfig* release_s_curve_config();
  ::planning::PiecewiseJerkSpeedOptimizerConfig* mutable_s_curve_config();
  void set_allocated_s_curve_config(::planning::PiecewiseJerkSpeedOptimizerConfig* s_curve_config);

  // optional .planning.BSplineConfig bspline_config = 19;
  bool has_bspline_config() const;
  void clear_bspline_config();
  static const int kBsplineConfigFieldNumber = 19;
  const ::planning::BSplineConfig& bspline_config() const;
  ::planning::BSplineConfig* release_bspline_config();
  ::planning::BSplineConfig* mutable_bspline_config();
  void set_allocated_bspline_config(::planning::BSplineConfig* bspline_config);

  // optional double interpolated_delta_s = 1 [default = 0.1];
  bool has_interpolated_delta_s() const;
  void clear_interpolated_delta_s();
  static const int kInterpolatedDeltaSFieldNumber = 1;
  double interpolated_delta_s() const;
  void set_interpolated_delta_s(double value);

  // optional double reanchoring_pos_stddev = 3 [default = 0.25];
  bool has_reanchoring_pos_stddev() const;
  void clear_reanchoring_pos_stddev();
  static const int kReanchoringPosStddevFieldNumber = 3;
  double reanchoring_pos_stddev() const;
  void set_reanchoring_pos_stddev(double value);

  // optional int32 reanchoring_trails_num = 2 [default = 50];
  bool has_reanchoring_trails_num() const;
  void clear_reanchoring_trails_num();
  static const int kReanchoringTrailsNumFieldNumber = 2;
  ::google::protobuf::int32 reanchoring_trails_num() const;
  void set_reanchoring_trails_num(::google::protobuf::int32 value);

  // optional bool estimate_bound = 5 [default = true];
  bool has_estimate_bound() const;
  void clear_estimate_bound();
  static const int kEstimateBoundFieldNumber = 5;
  bool estimate_bound() const;
  void set_estimate_bound(bool value);

  // optional double reanchoring_length_stddev = 4 [default = 1];
  bool has_reanchoring_length_stddev() const;
  void clear_reanchoring_length_stddev();
  static const int kReanchoringLengthStddevFieldNumber = 4;
  double reanchoring_length_stddev() const;
  void set_reanchoring_length_stddev(double value);

  // optional double default_bound = 6 [default = 2];
  bool has_default_bound() const;
  void clear_default_bound();
  static const int kDefaultBoundFieldNumber = 6;
  double default_bound() const;
  void set_default_bound(double value);

  // optional double vehicle_shortest_dimension = 7 [default = 1.04];
  bool has_vehicle_shortest_dimension() const;
  void clear_vehicle_shortest_dimension();
  static const int kVehicleShortestDimensionFieldNumber = 7;
  double vehicle_shortest_dimension() const;
  void set_vehicle_shortest_dimension(double value);

  // optional double collision_decrease_ratio = 9 [default = 0.9];
  bool has_collision_decrease_ratio() const;
  void clear_collision_decrease_ratio();
  static const int kCollisionDecreaseRatioFieldNumber = 9;
  double collision_decrease_ratio() const;
  void set_collision_decrease_ratio(double value);

  // optional double max_forward_v = 10 [default = 1];
  bool has_max_forward_v() const;
  void clear_max_forward_v();
  static const int kMaxForwardVFieldNumber = 10;
  double max_forward_v() const;
  void set_max_forward_v(double value);

  // optional double max_reverse_v = 11 [default = 1];
  bool has_max_reverse_v() const;
  void clear_max_reverse_v();
  static const int kMaxReverseVFieldNumber = 11;
  double max_reverse_v() const;
  void set_max_reverse_v(double value);

  // optional double max_forward_acc = 12 [default = 2];
  bool has_max_forward_acc() const;
  void clear_max_forward_acc();
  static const int kMaxForwardAccFieldNumber = 12;
  double max_forward_acc() const;
  void set_max_forward_acc(double value);

  // optional double max_reverse_acc = 13 [default = 1];
  bool has_max_reverse_acc() const;
  void clear_max_reverse_acc();
  static const int kMaxReverseAccFieldNumber = 13;
  double max_reverse_acc() const;
  void set_max_reverse_acc(double value);

  // optional double max_acc_jerk = 14 [default = 0.5];
  bool has_max_acc_jerk() const;
  void clear_max_acc_jerk();
  static const int kMaxAccJerkFieldNumber = 14;
  double max_acc_jerk() const;
  void set_max_acc_jerk(double value);

  // optional double delta_t = 15 [default = 0.2];
  bool has_delta_t() const;
  void clear_delta_t();
  static const int kDeltaTFieldNumber = 15;
  double delta_t() const;
  void set_delta_t(double value);

  // optional int64 max_iteration_num = 17 [default = 50];
  bool has_max_iteration_num() const;
  void clear_max_iteration_num();
  static const int kMaxIterationNumFieldNumber = 17;
  ::google::protobuf::int64 max_iteration_num() const;
  void set_max_iteration_num(::google::protobuf::int64 value);

  // optional double k_dense_time_resolution = 18 [default = 0.1];
  bool has_k_dense_time_resolution() const;
  void clear_k_dense_time_resolution();
  static const int kKDenseTimeResolutionFieldNumber = 18;
  double k_dense_time_resolution() const;
  void set_k_dense_time_resolution(double value);

  // @@protoc_insertion_point(class_scope:planning.IterativeAnchoringConfig)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::smoother::FemPosDeviationSmootherConfig* fem_pos_deviation_smoother_config_;
  ::planning::PiecewiseJerkSpeedOptimizerConfig* s_curve_config_;
  ::planning::BSplineConfig* bspline_config_;
  double interpolated_delta_s_;
  double reanchoring_pos_stddev_;
  ::google::protobuf::int32 reanchoring_trails_num_;
  bool estimate_bound_;
  double reanchoring_length_stddev_;
  double default_bound_;
  double vehicle_shortest_dimension_;
  double collision_decrease_ratio_;
  double max_forward_v_;
  double max_reverse_v_;
  double max_forward_acc_;
  double max_reverse_acc_;
  double max_acc_jerk_;
  double delta_t_;
  ::google::protobuf::int64 max_iteration_num_;
  double k_dense_time_resolution_;
  friend struct ::TableStruct_planner_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class BSplineConfig :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.BSplineConfig) */ {
 public:
  BSplineConfig();
  virtual ~BSplineConfig();

  BSplineConfig(const BSplineConfig& from);

  inline BSplineConfig& operator=(const BSplineConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BSplineConfig(BSplineConfig&& from) noexcept
    : BSplineConfig() {
    *this = ::std::move(from);
  }

  inline BSplineConfig& operator=(BSplineConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BSplineConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BSplineConfig* internal_default_instance() {
    return reinterpret_cast<const BSplineConfig*>(
               &_BSplineConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BSplineConfig* other);
  friend void swap(BSplineConfig& a, BSplineConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BSplineConfig* New() const final {
    return CreateMaybeMessage<BSplineConfig>(nullptr);
  }

  BSplineConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BSplineConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BSplineConfig& from);
  void MergeFrom(const BSplineConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BSplineConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 degrees = 1 [default = 3];
  bool has_degrees() const;
  void clear_degrees();
  static const int kDegreesFieldNumber = 1;
  ::google::protobuf::int32 degrees() const;
  void set_degrees(::google::protobuf::int32 value);

  // optional int32 samples = 2 [default = 30];
  bool has_samples() const;
  void clear_samples();
  static const int kSamplesFieldNumber = 2;
  ::google::protobuf::int32 samples() const;
  void set_samples(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:planning.BSplineConfig)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 degrees_;
  ::google::protobuf::int32 samples_;
  friend struct ::TableStruct_planner_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlannerOpenSpaceConfig

// optional .planning.WarmStartConfig warm_start_config = 2;
inline bool PlannerOpenSpaceConfig::has_warm_start_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlannerOpenSpaceConfig::clear_warm_start_config() {
  if (warm_start_config_ != nullptr) warm_start_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::planning::WarmStartConfig& PlannerOpenSpaceConfig::warm_start_config() const {
  const ::planning::WarmStartConfig* p = warm_start_config_;
  // @@protoc_insertion_point(field_get:planning.PlannerOpenSpaceConfig.warm_start_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::planning::WarmStartConfig*>(
      &::planning::_WarmStartConfig_default_instance_);
}
inline ::planning::WarmStartConfig* PlannerOpenSpaceConfig::release_warm_start_config() {
  // @@protoc_insertion_point(field_release:planning.PlannerOpenSpaceConfig.warm_start_config)
  _has_bits_[0] &= ~0x00000001u;
  ::planning::WarmStartConfig* temp = warm_start_config_;
  warm_start_config_ = nullptr;
  return temp;
}
inline ::planning::WarmStartConfig* PlannerOpenSpaceConfig::mutable_warm_start_config() {
  _has_bits_[0] |= 0x00000001u;
  if (warm_start_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::WarmStartConfig>(GetArenaNoVirtual());
    warm_start_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.PlannerOpenSpaceConfig.warm_start_config)
  return warm_start_config_;
}
inline void PlannerOpenSpaceConfig::set_allocated_warm_start_config(::planning::WarmStartConfig* warm_start_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete warm_start_config_;
  }
  if (warm_start_config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      warm_start_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, warm_start_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  warm_start_config_ = warm_start_config;
  // @@protoc_insertion_point(field_set_allocated:planning.PlannerOpenSpaceConfig.warm_start_config)
}

// optional .planning.IterativeAnchoringConfig iterative_anchoring_smoother_config = 5;
inline bool PlannerOpenSpaceConfig::has_iterative_anchoring_smoother_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlannerOpenSpaceConfig::clear_iterative_anchoring_smoother_config() {
  if (iterative_anchoring_smoother_config_ != nullptr) iterative_anchoring_smoother_config_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::planning::IterativeAnchoringConfig& PlannerOpenSpaceConfig::iterative_anchoring_smoother_config() const {
  const ::planning::IterativeAnchoringConfig* p = iterative_anchoring_smoother_config_;
  // @@protoc_insertion_point(field_get:planning.PlannerOpenSpaceConfig.iterative_anchoring_smoother_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::planning::IterativeAnchoringConfig*>(
      &::planning::_IterativeAnchoringConfig_default_instance_);
}
inline ::planning::IterativeAnchoringConfig* PlannerOpenSpaceConfig::release_iterative_anchoring_smoother_config() {
  // @@protoc_insertion_point(field_release:planning.PlannerOpenSpaceConfig.iterative_anchoring_smoother_config)
  _has_bits_[0] &= ~0x00000002u;
  ::planning::IterativeAnchoringConfig* temp = iterative_anchoring_smoother_config_;
  iterative_anchoring_smoother_config_ = nullptr;
  return temp;
}
inline ::planning::IterativeAnchoringConfig* PlannerOpenSpaceConfig::mutable_iterative_anchoring_smoother_config() {
  _has_bits_[0] |= 0x00000002u;
  if (iterative_anchoring_smoother_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::IterativeAnchoringConfig>(GetArenaNoVirtual());
    iterative_anchoring_smoother_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.PlannerOpenSpaceConfig.iterative_anchoring_smoother_config)
  return iterative_anchoring_smoother_config_;
}
inline void PlannerOpenSpaceConfig::set_allocated_iterative_anchoring_smoother_config(::planning::IterativeAnchoringConfig* iterative_anchoring_smoother_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete iterative_anchoring_smoother_config_;
  }
  if (iterative_anchoring_smoother_config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      iterative_anchoring_smoother_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, iterative_anchoring_smoother_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  iterative_anchoring_smoother_config_ = iterative_anchoring_smoother_config;
  // @@protoc_insertion_point(field_set_allocated:planning.PlannerOpenSpaceConfig.iterative_anchoring_smoother_config)
}

// optional float delta_t = 7 [default = 1];
inline bool PlannerOpenSpaceConfig::has_delta_t() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlannerOpenSpaceConfig::clear_delta_t() {
  delta_t_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline float PlannerOpenSpaceConfig::delta_t() const {
  // @@protoc_insertion_point(field_get:planning.PlannerOpenSpaceConfig.delta_t)
  return delta_t_;
}
inline void PlannerOpenSpaceConfig::set_delta_t(float value) {
  _has_bits_[0] |= 0x00000010u;
  delta_t_ = value;
  // @@protoc_insertion_point(field_set:planning.PlannerOpenSpaceConfig.delta_t)
}

// optional double is_near_destination_threshold = 8 [default = 0.02];
inline bool PlannerOpenSpaceConfig::has_is_near_destination_threshold() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlannerOpenSpaceConfig::clear_is_near_destination_threshold() {
  is_near_destination_threshold_ = 0.02;
  _has_bits_[0] &= ~0x00000020u;
}
inline double PlannerOpenSpaceConfig::is_near_destination_threshold() const {
  // @@protoc_insertion_point(field_get:planning.PlannerOpenSpaceConfig.is_near_destination_threshold)
  return is_near_destination_threshold_;
}
inline void PlannerOpenSpaceConfig::set_is_near_destination_threshold(double value) {
  _has_bits_[0] |= 0x00000020u;
  is_near_destination_threshold_ = value;
  // @@protoc_insertion_point(field_set:planning.PlannerOpenSpaceConfig.is_near_destination_threshold)
}

// optional bool enable_check_parallel_trajectory = 9 [default = false];
inline bool PlannerOpenSpaceConfig::has_enable_check_parallel_trajectory() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlannerOpenSpaceConfig::clear_enable_check_parallel_trajectory() {
  enable_check_parallel_trajectory_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool PlannerOpenSpaceConfig::enable_check_parallel_trajectory() const {
  // @@protoc_insertion_point(field_get:planning.PlannerOpenSpaceConfig.enable_check_parallel_trajectory)
  return enable_check_parallel_trajectory_;
}
inline void PlannerOpenSpaceConfig::set_enable_check_parallel_trajectory(bool value) {
  _has_bits_[0] |= 0x00000004u;
  enable_check_parallel_trajectory_ = value;
  // @@protoc_insertion_point(field_set:planning.PlannerOpenSpaceConfig.enable_check_parallel_trajectory)
}

// optional bool enable_linear_interpolation = 10 [default = false];
inline bool PlannerOpenSpaceConfig::has_enable_linear_interpolation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlannerOpenSpaceConfig::clear_enable_linear_interpolation() {
  enable_linear_interpolation_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool PlannerOpenSpaceConfig::enable_linear_interpolation() const {
  // @@protoc_insertion_point(field_get:planning.PlannerOpenSpaceConfig.enable_linear_interpolation)
  return enable_linear_interpolation_;
}
inline void PlannerOpenSpaceConfig::set_enable_linear_interpolation(bool value) {
  _has_bits_[0] |= 0x00000008u;
  enable_linear_interpolation_ = value;
  // @@protoc_insertion_point(field_set:planning.PlannerOpenSpaceConfig.enable_linear_interpolation)
}

// optional double is_near_destination_theta_threshold = 11 [default = 0.05];
inline bool PlannerOpenSpaceConfig::has_is_near_destination_theta_threshold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlannerOpenSpaceConfig::clear_is_near_destination_theta_threshold() {
  is_near_destination_theta_threshold_ = 0.05;
  _has_bits_[0] &= ~0x00000040u;
}
inline double PlannerOpenSpaceConfig::is_near_destination_theta_threshold() const {
  // @@protoc_insertion_point(field_get:planning.PlannerOpenSpaceConfig.is_near_destination_theta_threshold)
  return is_near_destination_theta_threshold_;
}
inline void PlannerOpenSpaceConfig::set_is_near_destination_theta_threshold(double value) {
  _has_bits_[0] |= 0x00000040u;
  is_near_destination_theta_threshold_ = value;
  // @@protoc_insertion_point(field_set:planning.PlannerOpenSpaceConfig.is_near_destination_theta_threshold)
}

// -------------------------------------------------------------------

// WarmStartConfig

// optional double xy_grid_resolution = 1 [default = 0.1];
inline bool WarmStartConfig::has_xy_grid_resolution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WarmStartConfig::clear_xy_grid_resolution() {
  xy_grid_resolution_ = 0.1;
  _has_bits_[0] &= ~0x00000002u;
}
inline double WarmStartConfig::xy_grid_resolution() const {
  // @@protoc_insertion_point(field_get:planning.WarmStartConfig.xy_grid_resolution)
  return xy_grid_resolution_;
}
inline void WarmStartConfig::set_xy_grid_resolution(double value) {
  _has_bits_[0] |= 0x00000002u;
  xy_grid_resolution_ = value;
  // @@protoc_insertion_point(field_set:planning.WarmStartConfig.xy_grid_resolution)
}

// optional double phi_grid_resolution = 2 [default = 0.1];
inline bool WarmStartConfig::has_phi_grid_resolution() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WarmStartConfig::clear_phi_grid_resolution() {
  phi_grid_resolution_ = 0.1;
  _has_bits_[0] &= ~0x00000004u;
}
inline double WarmStartConfig::phi_grid_resolution() const {
  // @@protoc_insertion_point(field_get:planning.WarmStartConfig.phi_grid_resolution)
  return phi_grid_resolution_;
}
inline void WarmStartConfig::set_phi_grid_resolution(double value) {
  _has_bits_[0] |= 0x00000004u;
  phi_grid_resolution_ = value;
  // @@protoc_insertion_point(field_set:planning.WarmStartConfig.phi_grid_resolution)
}

// optional uint64 next_node_num = 3 [default = 10];
inline bool WarmStartConfig::has_next_node_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WarmStartConfig::clear_next_node_num() {
  next_node_num_ = PROTOBUF_ULONGLONG(10);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 WarmStartConfig::next_node_num() const {
  // @@protoc_insertion_point(field_get:planning.WarmStartConfig.next_node_num)
  return next_node_num_;
}
inline void WarmStartConfig::set_next_node_num(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  next_node_num_ = value;
  // @@protoc_insertion_point(field_set:planning.WarmStartConfig.next_node_num)
}

// optional double step_size = 4 [default = 0.5];
inline bool WarmStartConfig::has_step_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WarmStartConfig::clear_step_size() {
  step_size_ = 0.5;
  _has_bits_[0] &= ~0x00000010u;
}
inline double WarmStartConfig::step_size() const {
  // @@protoc_insertion_point(field_get:planning.WarmStartConfig.step_size)
  return step_size_;
}
inline void WarmStartConfig::set_step_size(double value) {
  _has_bits_[0] |= 0x00000010u;
  step_size_ = value;
  // @@protoc_insertion_point(field_set:planning.WarmStartConfig.step_size)
}

// optional double traj_forward_penalty = 5 [default = 10];
inline bool WarmStartConfig::has_traj_forward_penalty() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WarmStartConfig::clear_traj_forward_penalty() {
  traj_forward_penalty_ = 10;
  _has_bits_[0] &= ~0x00000020u;
}
inline double WarmStartConfig::traj_forward_penalty() const {
  // @@protoc_insertion_point(field_get:planning.WarmStartConfig.traj_forward_penalty)
  return traj_forward_penalty_;
}
inline void WarmStartConfig::set_traj_forward_penalty(double value) {
  _has_bits_[0] |= 0x00000020u;
  traj_forward_penalty_ = value;
  // @@protoc_insertion_point(field_set:planning.WarmStartConfig.traj_forward_penalty)
}

// optional double traj_back_penalty = 6 [default = 100];
inline bool WarmStartConfig::has_traj_back_penalty() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WarmStartConfig::clear_traj_back_penalty() {
  traj_back_penalty_ = 100;
  _has_bits_[0] &= ~0x00000040u;
}
inline double WarmStartConfig::traj_back_penalty() const {
  // @@protoc_insertion_point(field_get:planning.WarmStartConfig.traj_back_penalty)
  return traj_back_penalty_;
}
inline void WarmStartConfig::set_traj_back_penalty(double value) {
  _has_bits_[0] |= 0x00000040u;
  traj_back_penalty_ = value;
  // @@protoc_insertion_point(field_set:planning.WarmStartConfig.traj_back_penalty)
}

// optional double traj_gear_switch_penalty = 7 [default = 100];
inline bool WarmStartConfig::has_traj_gear_switch_penalty() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WarmStartConfig::clear_traj_gear_switch_penalty() {
  traj_gear_switch_penalty_ = 100;
  _has_bits_[0] &= ~0x00000080u;
}
inline double WarmStartConfig::traj_gear_switch_penalty() const {
  // @@protoc_insertion_point(field_get:planning.WarmStartConfig.traj_gear_switch_penalty)
  return traj_gear_switch_penalty_;
}
inline void WarmStartConfig::set_traj_gear_switch_penalty(double value) {
  _has_bits_[0] |= 0x00000080u;
  traj_gear_switch_penalty_ = value;
  // @@protoc_insertion_point(field_set:planning.WarmStartConfig.traj_gear_switch_penalty)
}

// optional double traj_steer_penalty = 8 [default = 50];
inline bool WarmStartConfig::has_traj_steer_penalty() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WarmStartConfig::clear_traj_steer_penalty() {
  traj_steer_penalty_ = 50;
  _has_bits_[0] &= ~0x00000100u;
}
inline double WarmStartConfig::traj_steer_penalty() const {
  // @@protoc_insertion_point(field_get:planning.WarmStartConfig.traj_steer_penalty)
  return traj_steer_penalty_;
}
inline void WarmStartConfig::set_traj_steer_penalty(double value) {
  _has_bits_[0] |= 0x00000100u;
  traj_steer_penalty_ = value;
  // @@protoc_insertion_point(field_set:planning.WarmStartConfig.traj_steer_penalty)
}

// optional double traj_steer_change_penalty = 9 [default = 150];
inline bool WarmStartConfig::has_traj_steer_change_penalty() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void WarmStartConfig::clear_traj_steer_change_penalty() {
  traj_steer_change_penalty_ = 150;
  _has_bits_[0] &= ~0x00000200u;
}
inline double WarmStartConfig::traj_steer_change_penalty() const {
  // @@protoc_insertion_point(field_get:planning.WarmStartConfig.traj_steer_change_penalty)
  return traj_steer_change_penalty_;
}
inline void WarmStartConfig::set_traj_steer_change_penalty(double value) {
  _has_bits_[0] |= 0x00000200u;
  traj_steer_change_penalty_ = value;
  // @@protoc_insertion_point(field_set:planning.WarmStartConfig.traj_steer_change_penalty)
}

// optional double grid_a_star_xy_resolution = 15 [default = 0.1];
inline bool WarmStartConfig::has_grid_a_star_xy_resolution() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void WarmStartConfig::clear_grid_a_star_xy_resolution() {
  grid_a_star_xy_resolution_ = 0.1;
  _has_bits_[0] &= ~0x00000400u;
}
inline double WarmStartConfig::grid_a_star_xy_resolution() const {
  // @@protoc_insertion_point(field_get:planning.WarmStartConfig.grid_a_star_xy_resolution)
  return grid_a_star_xy_resolution_;
}
inline void WarmStartConfig::set_grid_a_star_xy_resolution(double value) {
  _has_bits_[0] |= 0x00000400u;
  grid_a_star_xy_resolution_ = value;
  // @@protoc_insertion_point(field_set:planning.WarmStartConfig.grid_a_star_xy_resolution)
}

// optional double node_radius = 16 [default = 0.3];
inline bool WarmStartConfig::has_node_radius() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void WarmStartConfig::clear_node_radius() {
  node_radius_ = 0.3;
  _has_bits_[0] &= ~0x00000800u;
}
inline double WarmStartConfig::node_radius() const {
  // @@protoc_insertion_point(field_get:planning.WarmStartConfig.node_radius)
  return node_radius_;
}
inline void WarmStartConfig::set_node_radius(double value) {
  _has_bits_[0] |= 0x00000800u;
  node_radius_ = value;
  // @@protoc_insertion_point(field_set:planning.WarmStartConfig.node_radius)
}

// optional .planning.PiecewiseJerkSpeedOptimizerConfig s_curve_config = 17;
inline bool WarmStartConfig::has_s_curve_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WarmStartConfig::clear_s_curve_config() {
  if (s_curve_config_ != nullptr) s_curve_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::planning::PiecewiseJerkSpeedOptimizerConfig& WarmStartConfig::s_curve_config() const {
  const ::planning::PiecewiseJerkSpeedOptimizerConfig* p = s_curve_config_;
  // @@protoc_insertion_point(field_get:planning.WarmStartConfig.s_curve_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::planning::PiecewiseJerkSpeedOptimizerConfig*>(
      &::planning::_PiecewiseJerkSpeedOptimizerConfig_default_instance_);
}
inline ::planning::PiecewiseJerkSpeedOptimizerConfig* WarmStartConfig::release_s_curve_config() {
  // @@protoc_insertion_point(field_release:planning.WarmStartConfig.s_curve_config)
  _has_bits_[0] &= ~0x00000001u;
  ::planning::PiecewiseJerkSpeedOptimizerConfig* temp = s_curve_config_;
  s_curve_config_ = nullptr;
  return temp;
}
inline ::planning::PiecewiseJerkSpeedOptimizerConfig* WarmStartConfig::mutable_s_curve_config() {
  _has_bits_[0] |= 0x00000001u;
  if (s_curve_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::PiecewiseJerkSpeedOptimizerConfig>(GetArenaNoVirtual());
    s_curve_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.WarmStartConfig.s_curve_config)
  return s_curve_config_;
}
inline void WarmStartConfig::set_allocated_s_curve_config(::planning::PiecewiseJerkSpeedOptimizerConfig* s_curve_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete s_curve_config_;
  }
  if (s_curve_config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      s_curve_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, s_curve_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  s_curve_config_ = s_curve_config;
  // @@protoc_insertion_point(field_set_allocated:planning.WarmStartConfig.s_curve_config)
}

// -------------------------------------------------------------------

// PiecewiseJerkSpeedOptimizerConfig

// optional double max_forward_v = 1 [default = 1];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_max_forward_v() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_max_forward_v() {
  max_forward_v_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::max_forward_v() const {
  // @@protoc_insertion_point(field_get:planning.PiecewiseJerkSpeedOptimizerConfig.max_forward_v)
  return max_forward_v_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_max_forward_v(double value) {
  _has_bits_[0] |= 0x00000001u;
  max_forward_v_ = value;
  // @@protoc_insertion_point(field_set:planning.PiecewiseJerkSpeedOptimizerConfig.max_forward_v)
}

// optional double max_reverse_v = 2 [default = 1];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_max_reverse_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_max_reverse_v() {
  max_reverse_v_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::max_reverse_v() const {
  // @@protoc_insertion_point(field_get:planning.PiecewiseJerkSpeedOptimizerConfig.max_reverse_v)
  return max_reverse_v_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_max_reverse_v(double value) {
  _has_bits_[0] |= 0x00000002u;
  max_reverse_v_ = value;
  // @@protoc_insertion_point(field_set:planning.PiecewiseJerkSpeedOptimizerConfig.max_reverse_v)
}

// optional double max_forward_acc = 3 [default = 0.5];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_max_forward_acc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_max_forward_acc() {
  max_forward_acc_ = 0.5;
  _has_bits_[0] &= ~0x00000004u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::max_forward_acc() const {
  // @@protoc_insertion_point(field_get:planning.PiecewiseJerkSpeedOptimizerConfig.max_forward_acc)
  return max_forward_acc_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_max_forward_acc(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_forward_acc_ = value;
  // @@protoc_insertion_point(field_set:planning.PiecewiseJerkSpeedOptimizerConfig.max_forward_acc)
}

// optional double max_reverse_acc = 4 [default = 0.5];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_max_reverse_acc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_max_reverse_acc() {
  max_reverse_acc_ = 0.5;
  _has_bits_[0] &= ~0x00000008u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::max_reverse_acc() const {
  // @@protoc_insertion_point(field_get:planning.PiecewiseJerkSpeedOptimizerConfig.max_reverse_acc)
  return max_reverse_acc_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_max_reverse_acc(double value) {
  _has_bits_[0] |= 0x00000008u;
  max_reverse_acc_ = value;
  // @@protoc_insertion_point(field_set:planning.PiecewiseJerkSpeedOptimizerConfig.max_reverse_acc)
}

// optional double max_acc_jerk = 5 [default = 0.5];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_max_acc_jerk() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_max_acc_jerk() {
  max_acc_jerk_ = 0.5;
  _has_bits_[0] &= ~0x00000010u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::max_acc_jerk() const {
  // @@protoc_insertion_point(field_get:planning.PiecewiseJerkSpeedOptimizerConfig.max_acc_jerk)
  return max_acc_jerk_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_max_acc_jerk(double value) {
  _has_bits_[0] |= 0x00000010u;
  max_acc_jerk_ = value;
  // @@protoc_insertion_point(field_set:planning.PiecewiseJerkSpeedOptimizerConfig.max_acc_jerk)
}

// optional double delta_t = 6 [default = 0.2];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_delta_t() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_delta_t() {
  delta_t_ = 0.2;
  _has_bits_[0] &= ~0x00000020u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::delta_t() const {
  // @@protoc_insertion_point(field_get:planning.PiecewiseJerkSpeedOptimizerConfig.delta_t)
  return delta_t_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_delta_t(double value) {
  _has_bits_[0] |= 0x00000020u;
  delta_t_ = value;
  // @@protoc_insertion_point(field_set:planning.PiecewiseJerkSpeedOptimizerConfig.delta_t)
}

// optional double acc_weight = 7 [default = 1];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_acc_weight() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_acc_weight() {
  acc_weight_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::acc_weight() const {
  // @@protoc_insertion_point(field_get:planning.PiecewiseJerkSpeedOptimizerConfig.acc_weight)
  return acc_weight_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_acc_weight(double value) {
  _has_bits_[0] |= 0x00000040u;
  acc_weight_ = value;
  // @@protoc_insertion_point(field_set:planning.PiecewiseJerkSpeedOptimizerConfig.acc_weight)
}

// optional double jerk_weight = 8 [default = 10];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_jerk_weight() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_jerk_weight() {
  jerk_weight_ = 10;
  _has_bits_[0] &= ~0x00000080u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::jerk_weight() const {
  // @@protoc_insertion_point(field_get:planning.PiecewiseJerkSpeedOptimizerConfig.jerk_weight)
  return jerk_weight_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_jerk_weight(double value) {
  _has_bits_[0] |= 0x00000080u;
  jerk_weight_ = value;
  // @@protoc_insertion_point(field_set:planning.PiecewiseJerkSpeedOptimizerConfig.jerk_weight)
}

// optional double kappa_penalty_weight = 9 [default = 1000];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_kappa_penalty_weight() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_kappa_penalty_weight() {
  kappa_penalty_weight_ = 1000;
  _has_bits_[0] &= ~0x00000100u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::kappa_penalty_weight() const {
  // @@protoc_insertion_point(field_get:planning.PiecewiseJerkSpeedOptimizerConfig.kappa_penalty_weight)
  return kappa_penalty_weight_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_kappa_penalty_weight(double value) {
  _has_bits_[0] |= 0x00000100u;
  kappa_penalty_weight_ = value;
  // @@protoc_insertion_point(field_set:planning.PiecewiseJerkSpeedOptimizerConfig.kappa_penalty_weight)
}

// optional double ref_s_weight = 10 [default = 1000];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_ref_s_weight() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_ref_s_weight() {
  ref_s_weight_ = 1000;
  _has_bits_[0] &= ~0x00000200u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::ref_s_weight() const {
  // @@protoc_insertion_point(field_get:planning.PiecewiseJerkSpeedOptimizerConfig.ref_s_weight)
  return ref_s_weight_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_ref_s_weight(double value) {
  _has_bits_[0] |= 0x00000200u;
  ref_s_weight_ = value;
  // @@protoc_insertion_point(field_set:planning.PiecewiseJerkSpeedOptimizerConfig.ref_s_weight)
}

// optional double ref_v_weight = 11 [default = 10];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_ref_v_weight() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_ref_v_weight() {
  ref_v_weight_ = 10;
  _has_bits_[0] &= ~0x00000400u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::ref_v_weight() const {
  // @@protoc_insertion_point(field_get:planning.PiecewiseJerkSpeedOptimizerConfig.ref_v_weight)
  return ref_v_weight_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_ref_v_weight(double value) {
  _has_bits_[0] |= 0x00000400u;
  ref_v_weight_ = value;
  // @@protoc_insertion_point(field_set:planning.PiecewiseJerkSpeedOptimizerConfig.ref_v_weight)
}

// optional double k_dense_time_resoltuion = 12 [default = 0.5];
inline bool PiecewiseJerkSpeedOptimizerConfig::has_k_dense_time_resoltuion() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PiecewiseJerkSpeedOptimizerConfig::clear_k_dense_time_resoltuion() {
  k_dense_time_resoltuion_ = 0.5;
  _has_bits_[0] &= ~0x00000800u;
}
inline double PiecewiseJerkSpeedOptimizerConfig::k_dense_time_resoltuion() const {
  // @@protoc_insertion_point(field_get:planning.PiecewiseJerkSpeedOptimizerConfig.k_dense_time_resoltuion)
  return k_dense_time_resoltuion_;
}
inline void PiecewiseJerkSpeedOptimizerConfig::set_k_dense_time_resoltuion(double value) {
  _has_bits_[0] |= 0x00000800u;
  k_dense_time_resoltuion_ = value;
  // @@protoc_insertion_point(field_set:planning.PiecewiseJerkSpeedOptimizerConfig.k_dense_time_resoltuion)
}

// -------------------------------------------------------------------

// IterativeAnchoringConfig

// optional double interpolated_delta_s = 1 [default = 0.1];
inline bool IterativeAnchoringConfig::has_interpolated_delta_s() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IterativeAnchoringConfig::clear_interpolated_delta_s() {
  interpolated_delta_s_ = 0.1;
  _has_bits_[0] &= ~0x00000008u;
}
inline double IterativeAnchoringConfig::interpolated_delta_s() const {
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.interpolated_delta_s)
  return interpolated_delta_s_;
}
inline void IterativeAnchoringConfig::set_interpolated_delta_s(double value) {
  _has_bits_[0] |= 0x00000008u;
  interpolated_delta_s_ = value;
  // @@protoc_insertion_point(field_set:planning.IterativeAnchoringConfig.interpolated_delta_s)
}

// optional int32 reanchoring_trails_num = 2 [default = 50];
inline bool IterativeAnchoringConfig::has_reanchoring_trails_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IterativeAnchoringConfig::clear_reanchoring_trails_num() {
  reanchoring_trails_num_ = 50;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::int32 IterativeAnchoringConfig::reanchoring_trails_num() const {
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.reanchoring_trails_num)
  return reanchoring_trails_num_;
}
inline void IterativeAnchoringConfig::set_reanchoring_trails_num(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  reanchoring_trails_num_ = value;
  // @@protoc_insertion_point(field_set:planning.IterativeAnchoringConfig.reanchoring_trails_num)
}

// optional double reanchoring_pos_stddev = 3 [default = 0.25];
inline bool IterativeAnchoringConfig::has_reanchoring_pos_stddev() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IterativeAnchoringConfig::clear_reanchoring_pos_stddev() {
  reanchoring_pos_stddev_ = 0.25;
  _has_bits_[0] &= ~0x00000010u;
}
inline double IterativeAnchoringConfig::reanchoring_pos_stddev() const {
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.reanchoring_pos_stddev)
  return reanchoring_pos_stddev_;
}
inline void IterativeAnchoringConfig::set_reanchoring_pos_stddev(double value) {
  _has_bits_[0] |= 0x00000010u;
  reanchoring_pos_stddev_ = value;
  // @@protoc_insertion_point(field_set:planning.IterativeAnchoringConfig.reanchoring_pos_stddev)
}

// optional double reanchoring_length_stddev = 4 [default = 1];
inline bool IterativeAnchoringConfig::has_reanchoring_length_stddev() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IterativeAnchoringConfig::clear_reanchoring_length_stddev() {
  reanchoring_length_stddev_ = 1;
  _has_bits_[0] &= ~0x00000080u;
}
inline double IterativeAnchoringConfig::reanchoring_length_stddev() const {
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.reanchoring_length_stddev)
  return reanchoring_length_stddev_;
}
inline void IterativeAnchoringConfig::set_reanchoring_length_stddev(double value) {
  _has_bits_[0] |= 0x00000080u;
  reanchoring_length_stddev_ = value;
  // @@protoc_insertion_point(field_set:planning.IterativeAnchoringConfig.reanchoring_length_stddev)
}

// optional bool estimate_bound = 5 [default = true];
inline bool IterativeAnchoringConfig::has_estimate_bound() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IterativeAnchoringConfig::clear_estimate_bound() {
  estimate_bound_ = true;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool IterativeAnchoringConfig::estimate_bound() const {
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.estimate_bound)
  return estimate_bound_;
}
inline void IterativeAnchoringConfig::set_estimate_bound(bool value) {
  _has_bits_[0] |= 0x00000040u;
  estimate_bound_ = value;
  // @@protoc_insertion_point(field_set:planning.IterativeAnchoringConfig.estimate_bound)
}

// optional double default_bound = 6 [default = 2];
inline bool IterativeAnchoringConfig::has_default_bound() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IterativeAnchoringConfig::clear_default_bound() {
  default_bound_ = 2;
  _has_bits_[0] &= ~0x00000100u;
}
inline double IterativeAnchoringConfig::default_bound() const {
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.default_bound)
  return default_bound_;
}
inline void IterativeAnchoringConfig::set_default_bound(double value) {
  _has_bits_[0] |= 0x00000100u;
  default_bound_ = value;
  // @@protoc_insertion_point(field_set:planning.IterativeAnchoringConfig.default_bound)
}

// optional double vehicle_shortest_dimension = 7 [default = 1.04];
inline bool IterativeAnchoringConfig::has_vehicle_shortest_dimension() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IterativeAnchoringConfig::clear_vehicle_shortest_dimension() {
  vehicle_shortest_dimension_ = 1.04;
  _has_bits_[0] &= ~0x00000200u;
}
inline double IterativeAnchoringConfig::vehicle_shortest_dimension() const {
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.vehicle_shortest_dimension)
  return vehicle_shortest_dimension_;
}
inline void IterativeAnchoringConfig::set_vehicle_shortest_dimension(double value) {
  _has_bits_[0] |= 0x00000200u;
  vehicle_shortest_dimension_ = value;
  // @@protoc_insertion_point(field_set:planning.IterativeAnchoringConfig.vehicle_shortest_dimension)
}

// optional .smoother.FemPosDeviationSmootherConfig fem_pos_deviation_smoother_config = 8;
inline bool IterativeAnchoringConfig::has_fem_pos_deviation_smoother_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::smoother::FemPosDeviationSmootherConfig& IterativeAnchoringConfig::fem_pos_deviation_smoother_config() const {
  const ::smoother::FemPosDeviationSmootherConfig* p = fem_pos_deviation_smoother_config_;
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.fem_pos_deviation_smoother_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::smoother::FemPosDeviationSmootherConfig*>(
      &::smoother::_FemPosDeviationSmootherConfig_default_instance_);
}
inline ::smoother::FemPosDeviationSmootherConfig* IterativeAnchoringConfig::release_fem_pos_deviation_smoother_config() {
  // @@protoc_insertion_point(field_release:planning.IterativeAnchoringConfig.fem_pos_deviation_smoother_config)
  _has_bits_[0] &= ~0x00000001u;
  ::smoother::FemPosDeviationSmootherConfig* temp = fem_pos_deviation_smoother_config_;
  fem_pos_deviation_smoother_config_ = nullptr;
  return temp;
}
inline ::smoother::FemPosDeviationSmootherConfig* IterativeAnchoringConfig::mutable_fem_pos_deviation_smoother_config() {
  _has_bits_[0] |= 0x00000001u;
  if (fem_pos_deviation_smoother_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::smoother::FemPosDeviationSmootherConfig>(GetArenaNoVirtual());
    fem_pos_deviation_smoother_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.IterativeAnchoringConfig.fem_pos_deviation_smoother_config)
  return fem_pos_deviation_smoother_config_;
}
inline void IterativeAnchoringConfig::set_allocated_fem_pos_deviation_smoother_config(::smoother::FemPosDeviationSmootherConfig* fem_pos_deviation_smoother_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(fem_pos_deviation_smoother_config_);
  }
  if (fem_pos_deviation_smoother_config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fem_pos_deviation_smoother_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fem_pos_deviation_smoother_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fem_pos_deviation_smoother_config_ = fem_pos_deviation_smoother_config;
  // @@protoc_insertion_point(field_set_allocated:planning.IterativeAnchoringConfig.fem_pos_deviation_smoother_config)
}

// optional double collision_decrease_ratio = 9 [default = 0.9];
inline bool IterativeAnchoringConfig::has_collision_decrease_ratio() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IterativeAnchoringConfig::clear_collision_decrease_ratio() {
  collision_decrease_ratio_ = 0.9;
  _has_bits_[0] &= ~0x00000400u;
}
inline double IterativeAnchoringConfig::collision_decrease_ratio() const {
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.collision_decrease_ratio)
  return collision_decrease_ratio_;
}
inline void IterativeAnchoringConfig::set_collision_decrease_ratio(double value) {
  _has_bits_[0] |= 0x00000400u;
  collision_decrease_ratio_ = value;
  // @@protoc_insertion_point(field_set:planning.IterativeAnchoringConfig.collision_decrease_ratio)
}

// optional double max_forward_v = 10 [default = 1];
inline bool IterativeAnchoringConfig::has_max_forward_v() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void IterativeAnchoringConfig::clear_max_forward_v() {
  max_forward_v_ = 1;
  _has_bits_[0] &= ~0x00000800u;
}
inline double IterativeAnchoringConfig::max_forward_v() const {
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.max_forward_v)
  return max_forward_v_;
}
inline void IterativeAnchoringConfig::set_max_forward_v(double value) {
  _has_bits_[0] |= 0x00000800u;
  max_forward_v_ = value;
  // @@protoc_insertion_point(field_set:planning.IterativeAnchoringConfig.max_forward_v)
}

// optional double max_reverse_v = 11 [default = 1];
inline bool IterativeAnchoringConfig::has_max_reverse_v() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void IterativeAnchoringConfig::clear_max_reverse_v() {
  max_reverse_v_ = 1;
  _has_bits_[0] &= ~0x00001000u;
}
inline double IterativeAnchoringConfig::max_reverse_v() const {
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.max_reverse_v)
  return max_reverse_v_;
}
inline void IterativeAnchoringConfig::set_max_reverse_v(double value) {
  _has_bits_[0] |= 0x00001000u;
  max_reverse_v_ = value;
  // @@protoc_insertion_point(field_set:planning.IterativeAnchoringConfig.max_reverse_v)
}

// optional double max_forward_acc = 12 [default = 2];
inline bool IterativeAnchoringConfig::has_max_forward_acc() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void IterativeAnchoringConfig::clear_max_forward_acc() {
  max_forward_acc_ = 2;
  _has_bits_[0] &= ~0x00002000u;
}
inline double IterativeAnchoringConfig::max_forward_acc() const {
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.max_forward_acc)
  return max_forward_acc_;
}
inline void IterativeAnchoringConfig::set_max_forward_acc(double value) {
  _has_bits_[0] |= 0x00002000u;
  max_forward_acc_ = value;
  // @@protoc_insertion_point(field_set:planning.IterativeAnchoringConfig.max_forward_acc)
}

// optional double max_reverse_acc = 13 [default = 1];
inline bool IterativeAnchoringConfig::has_max_reverse_acc() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void IterativeAnchoringConfig::clear_max_reverse_acc() {
  max_reverse_acc_ = 1;
  _has_bits_[0] &= ~0x00004000u;
}
inline double IterativeAnchoringConfig::max_reverse_acc() const {
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.max_reverse_acc)
  return max_reverse_acc_;
}
inline void IterativeAnchoringConfig::set_max_reverse_acc(double value) {
  _has_bits_[0] |= 0x00004000u;
  max_reverse_acc_ = value;
  // @@protoc_insertion_point(field_set:planning.IterativeAnchoringConfig.max_reverse_acc)
}

// optional double max_acc_jerk = 14 [default = 0.5];
inline bool IterativeAnchoringConfig::has_max_acc_jerk() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void IterativeAnchoringConfig::clear_max_acc_jerk() {
  max_acc_jerk_ = 0.5;
  _has_bits_[0] &= ~0x00008000u;
}
inline double IterativeAnchoringConfig::max_acc_jerk() const {
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.max_acc_jerk)
  return max_acc_jerk_;
}
inline void IterativeAnchoringConfig::set_max_acc_jerk(double value) {
  _has_bits_[0] |= 0x00008000u;
  max_acc_jerk_ = value;
  // @@protoc_insertion_point(field_set:planning.IterativeAnchoringConfig.max_acc_jerk)
}

// optional double delta_t = 15 [default = 0.2];
inline bool IterativeAnchoringConfig::has_delta_t() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void IterativeAnchoringConfig::clear_delta_t() {
  delta_t_ = 0.2;
  _has_bits_[0] &= ~0x00010000u;
}
inline double IterativeAnchoringConfig::delta_t() const {
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.delta_t)
  return delta_t_;
}
inline void IterativeAnchoringConfig::set_delta_t(double value) {
  _has_bits_[0] |= 0x00010000u;
  delta_t_ = value;
  // @@protoc_insertion_point(field_set:planning.IterativeAnchoringConfig.delta_t)
}

// optional .planning.PiecewiseJerkSpeedOptimizerConfig s_curve_config = 16;
inline bool IterativeAnchoringConfig::has_s_curve_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IterativeAnchoringConfig::clear_s_curve_config() {
  if (s_curve_config_ != nullptr) s_curve_config_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::planning::PiecewiseJerkSpeedOptimizerConfig& IterativeAnchoringConfig::s_curve_config() const {
  const ::planning::PiecewiseJerkSpeedOptimizerConfig* p = s_curve_config_;
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.s_curve_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::planning::PiecewiseJerkSpeedOptimizerConfig*>(
      &::planning::_PiecewiseJerkSpeedOptimizerConfig_default_instance_);
}
inline ::planning::PiecewiseJerkSpeedOptimizerConfig* IterativeAnchoringConfig::release_s_curve_config() {
  // @@protoc_insertion_point(field_release:planning.IterativeAnchoringConfig.s_curve_config)
  _has_bits_[0] &= ~0x00000002u;
  ::planning::PiecewiseJerkSpeedOptimizerConfig* temp = s_curve_config_;
  s_curve_config_ = nullptr;
  return temp;
}
inline ::planning::PiecewiseJerkSpeedOptimizerConfig* IterativeAnchoringConfig::mutable_s_curve_config() {
  _has_bits_[0] |= 0x00000002u;
  if (s_curve_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::PiecewiseJerkSpeedOptimizerConfig>(GetArenaNoVirtual());
    s_curve_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.IterativeAnchoringConfig.s_curve_config)
  return s_curve_config_;
}
inline void IterativeAnchoringConfig::set_allocated_s_curve_config(::planning::PiecewiseJerkSpeedOptimizerConfig* s_curve_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete s_curve_config_;
  }
  if (s_curve_config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      s_curve_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, s_curve_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  s_curve_config_ = s_curve_config;
  // @@protoc_insertion_point(field_set_allocated:planning.IterativeAnchoringConfig.s_curve_config)
}

// optional int64 max_iteration_num = 17 [default = 50];
inline bool IterativeAnchoringConfig::has_max_iteration_num() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void IterativeAnchoringConfig::clear_max_iteration_num() {
  max_iteration_num_ = PROTOBUF_LONGLONG(50);
  _has_bits_[0] &= ~0x00020000u;
}
inline ::google::protobuf::int64 IterativeAnchoringConfig::max_iteration_num() const {
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.max_iteration_num)
  return max_iteration_num_;
}
inline void IterativeAnchoringConfig::set_max_iteration_num(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00020000u;
  max_iteration_num_ = value;
  // @@protoc_insertion_point(field_set:planning.IterativeAnchoringConfig.max_iteration_num)
}

// optional double k_dense_time_resolution = 18 [default = 0.1];
inline bool IterativeAnchoringConfig::has_k_dense_time_resolution() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void IterativeAnchoringConfig::clear_k_dense_time_resolution() {
  k_dense_time_resolution_ = 0.1;
  _has_bits_[0] &= ~0x00040000u;
}
inline double IterativeAnchoringConfig::k_dense_time_resolution() const {
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.k_dense_time_resolution)
  return k_dense_time_resolution_;
}
inline void IterativeAnchoringConfig::set_k_dense_time_resolution(double value) {
  _has_bits_[0] |= 0x00040000u;
  k_dense_time_resolution_ = value;
  // @@protoc_insertion_point(field_set:planning.IterativeAnchoringConfig.k_dense_time_resolution)
}

// optional .planning.BSplineConfig bspline_config = 19;
inline bool IterativeAnchoringConfig::has_bspline_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IterativeAnchoringConfig::clear_bspline_config() {
  if (bspline_config_ != nullptr) bspline_config_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::planning::BSplineConfig& IterativeAnchoringConfig::bspline_config() const {
  const ::planning::BSplineConfig* p = bspline_config_;
  // @@protoc_insertion_point(field_get:planning.IterativeAnchoringConfig.bspline_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::planning::BSplineConfig*>(
      &::planning::_BSplineConfig_default_instance_);
}
inline ::planning::BSplineConfig* IterativeAnchoringConfig::release_bspline_config() {
  // @@protoc_insertion_point(field_release:planning.IterativeAnchoringConfig.bspline_config)
  _has_bits_[0] &= ~0x00000004u;
  ::planning::BSplineConfig* temp = bspline_config_;
  bspline_config_ = nullptr;
  return temp;
}
inline ::planning::BSplineConfig* IterativeAnchoringConfig::mutable_bspline_config() {
  _has_bits_[0] |= 0x00000004u;
  if (bspline_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::BSplineConfig>(GetArenaNoVirtual());
    bspline_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.IterativeAnchoringConfig.bspline_config)
  return bspline_config_;
}
inline void IterativeAnchoringConfig::set_allocated_bspline_config(::planning::BSplineConfig* bspline_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete bspline_config_;
  }
  if (bspline_config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bspline_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bspline_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  bspline_config_ = bspline_config;
  // @@protoc_insertion_point(field_set_allocated:planning.IterativeAnchoringConfig.bspline_config)
}

// -------------------------------------------------------------------

// BSplineConfig

// optional int32 degrees = 1 [default = 3];
inline bool BSplineConfig::has_degrees() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BSplineConfig::clear_degrees() {
  degrees_ = 3;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 BSplineConfig::degrees() const {
  // @@protoc_insertion_point(field_get:planning.BSplineConfig.degrees)
  return degrees_;
}
inline void BSplineConfig::set_degrees(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  degrees_ = value;
  // @@protoc_insertion_point(field_set:planning.BSplineConfig.degrees)
}

// optional int32 samples = 2 [default = 30];
inline bool BSplineConfig::has_samples() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BSplineConfig::clear_samples() {
  samples_ = 30;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 BSplineConfig::samples() const {
  // @@protoc_insertion_point(field_get:planning.BSplineConfig.samples)
  return samples_;
}
inline void BSplineConfig::set_samples(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  samples_ = value;
  // @@protoc_insertion_point(field_set:planning.BSplineConfig.samples)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_planner_5fconfig_2eproto
